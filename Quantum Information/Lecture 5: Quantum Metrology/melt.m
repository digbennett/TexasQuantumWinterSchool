(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
LoadPauliMatrices[];
Quiet@Needs["MaTeX`"];


(* ::Input::Initialization:: *)
(* Prints in matrix form but does not alter definition *)
Clear[mf];
mf[A_]:=(Print[MatrixForm@Chop@A];A)


(* ::Input::Initialization:: *)
Clear[lmf];
lmf[list_]:=MatrixForm/@list;


(* ::Input::Initialization:: *)
Clear[mfplot];
mfplot[A_]:=(Print[MatrixPlot@Chop@A];A)


(* ::Input::Initialization:: *)
(* FullSimplifty + ComplexExpand (to get rid of "Conjugate"s) *)
Clear[cf];
(*cf[expr_]:=FullSimplify@ComplexExpand@expr;*)
cf[expr_]:=FullSimplify[ComplexExpand@Normal@expr,Thread[DeleteDuplicates@Cases[Normal@expr,_Symbol,\[Infinity]]>0]]

cf[expr_,assumps_]:=FullSimplify[ComplexExpand@Normal@expr,assumps]
cf::usage = "FullSimplify assuming that all symbols are real and positive.";


(* ::Input::Initialization:: *)
Clear[delcon];
(* Delete the conjugates *)
delcon[expr_]:=Module[{vars,vars2,expr2,v},
vars=Cases[Normal@expr,_Symbol,\[Infinity]];
vars2 = Table[v[i],{i,Length@vars}];
expr2 = expr/.Thread[vars->vars2];
Conjugate[v[i_]] ^:=v[i];
expr2/.Thread[vars2->vars]
];

delcon[expr_,vars_]:=Module[{vars2,expr2,v},
vars2 = Table[v[i],{i,Length@vars}];
expr2 = expr/.Thread[vars->vars2];
Conjugate[v[i_]] ^:=v[i];
expr2/.Thread[vars2->vars]
];


(* ::Input::Initialization:: *)
(* Outer product |v\[RightAngleBracket]\[LeftAngleBracket]u| between two vectors *)
(* Properly conjugates *)
Clear[out];
out[v_,u_]:=Outer[Times,v,Conjugate[u]];


(* ::Input::Initialization:: *)
(* \[DoubleStruckCapitalC] writes as esc+dsC+esc *)
Clear[\[DoubleStruckCapitalC]];
\[DoubleStruckCapitalC][A_,B_]:=A . B-B . A;
\[DoubleStruckCapitalC][A_,B_,\[Zeta]_]:=A . B-\[Zeta] B . A


(* ::Input::Initialization:: *)
(* Quick way of checking what are the distinct entries of a matrix or tensor *)
Clear[ChopCheck];
ChopCheck[A_,tol_:10^-10]:=DeleteDuplicates@Flatten@Chop[A,tol]

ChopCheck::usage = "ChopCheck[A] gives 0 when the matrix is 0, to a tolerance of \!\(\*SuperscriptBox[\(10\), \(-10\)]\). I usually do ChopCheck[A-B] whenever I want to check numerically that A = B";

Clear[ChopCheck2]
ChopCheck2[mat_,take_:0]:= Module[{l = If[take===0,Length@mat-5,take]},mat[[1;;l,1;;l]]//ChopCheck]


(* ::Input::Initialization:: *)
(* Use just like Range[] function *)
Clear[range];
range[xi_,xf_,df_:1]:=N@Rationalize@Range[xi,xf,df]; 

(* Stolen from python/Matlab *)
Clear[linspace]
linspace[dd1_,dd2_,n_:100]:=With[{d1=N@dd1,d2=N@dd2},If[n==1,{d1},d1+(d2-d1)/(n-1) Range[0,n-1]]];
linspace::usage = "linspace[a,b,npts] yields npts linearly interpolated between a (inclusive) and b (inclusive).";

Clear[logspace];
logspace[dd1_,dd2_,n_:100]:=10^linspace[dd1,dd2,n];
logspace::usage = "Same as linspace, but in log scale. logscale[2,5,50] will give 50 pts between \!\(\*SuperscriptBox[\(10\), \(2\)]\) and \!\(\*SuperscriptBox[\(10\), \(5\)]\)";


(* ::Input::Initialization:: *)
Clear[PartitionIn];
PartitionIn[list_,x_,pad_:""]:=Partition[list,Ceiling[Length[list]/x],Ceiling[Length[list]/x],1,pad]

PartitionIn::usage = "PartitionIn[list,x] partitions list into x sublists, possibly with paddings at the end.";


(* ::Input::Initialization:: *)
Clear[PrettyTiming];
SetAttributes[PrettyTiming,HoldAll];
PrettyTiming[computation_]:=Module[{t1,t2,output,time,h,m,s},
t1 = UnixTime[];
output=ReleaseHold[computation];
t2 = UnixTime[];
time = t2-t1;
(* h = Floor[time/3600];
m = Floor[Mod[time,3600]/60];
s = Round@Mod[time,60];
*)(*Print[ToString[h]<>"h : "<>ToString[m]<>"m : "<>ToString[s]<>"s"];*)
Print[TimeObject[{0,0,time}]];
Return[output]];

PrettyTiming::usage = "PrettyTiming[computation] uses Mathematica's AbsoluteTiming[] to time a computation, but prints the result in a prettier form.";


(* ::Input::Initialization:: *)
Clear[PrettyRound];
PrettyRound[x_,digits_]:=ToString@N[Round[x,10^-digits]]


(* ::Input::Initialization:: *)
Clear[do];
SetAttributes[do,HoldAll];
do[computation_,iterators__]:=Module[{iters = {iterators}[[All,1]],symb,list,i,d },
symb = ToString/@iters;
d=Length@symb;
list = Flatten[Table[iters,iterators],Length[iters]-1];

PrettyTiming@Monitor[Do[computation,iterators],
(*Check[*)
StringJoin@Table[{symb[[i]]," = ", ToString@StandardForm[iters[[i]]],"\n"},{i,d}]
ProgressIndicator[Position[list,Table[iters[[i]],{i,d}]][[1,1]],{1,Length@list}]
(*," "]*)
]
]


(* ::Input::Initialization:: *)
Clear[table];
SetAttributes[table,HoldAll];
table[computation_,iterators__]:=Module[{iters = {iterators}[[All,1]],symb,list,i,d },
symb = ToString/@iters;
d=Length@symb;
list = Flatten[Table[iters,iterators],Length[iters]-1];

PrettyTiming@Monitor[Table[computation,iterators],
(*Check[*)
StringJoin@Table[{symb[[i]]," = ", ToString@StandardForm[iters[[i]]],"\n"},{i,d}]
ProgressIndicator[Position[list,Table[iters[[i]],{i,d}]][[1,1]],{1,Length@list}]
(*," "]*)
]
]


(* ::Input::Initialization:: *)
Clear[nest];
nest[f_,init_,n_]:=Module[{it=0},PrintTemporary[ProgressIndicator[Dynamic[it/n]] Dynamic[ToString@Round[ 100 it/n]<>"%"]];
Nest[(it++;f[#])&,init,n]]


(* ::Input::Initialization:: *)
(*Clear[nestList0];
nestList0[f_,init_,n_]:=Module[{it=0},PrintTemporary[ProgressIndicator[Dynamic[it/n]] Dynamic[ToString@Round[ 100 it/n]<>"%"]];
NestList[(it++;f[#])&,init,n]]*)


(* ::Input::Initialization:: *)
Clear[nestList];
nestList[f_,init_,n_,split_:1000]:=Module[{it=0,n2=100,\[Delta],f2,list},
If[n<split,
(PrintTemporary[ProgressIndicator[Dynamic[it/n]] Dynamic[ToString@Round[ 100 it/n]<>"%"]];
NestList[(it++;f[#])&,init,n])
,
(
\[Delta] = Floor[n/n2];
f2[x_]:=Rest@NestList[f,x[[-1]],\[Delta]];
PrintTemporary[ProgressIndicator[Dynamic[it/n2]] Dynamic[ToString@Round[ 100 it/n2]<>"%"]];
list=NestList[(it++;f2[#])&,{init},n2];
Join@@Append[list,Rest@NestList[f,list[[-1,-1]],n-n2 \[Delta]]]
)
]
]


(* ::Input::Initialization:: *)
Clear[makeGIF];
SetAttributes[makeGIF,HoldAll];
makeGIF[thing_,iterator_,filename_,duration_,fps_:20]:=Module[{ i0,if,\[CapitalDelta],\[Delta],frames,numberOfframes},

numberOfframes = duration fps;
i0 = iterator[[2]];
if = iterator[[3]];
\[Delta] = If[Length@iterator==4,iterator[[4]],1];

\[CapitalDelta] =  (if-i0)/numberOfframes ;   
If[IntegerQ[\[Delta]],\[CapitalDelta]=Ceiling[\[CapitalDelta]]];

If[Length@iterator==3,
frames = table[thing,Evaluate@Append[iterator, \[CapitalDelta]]],
frames = table[thing,Evaluate@ReplacePart[iterator,4-> \[CapitalDelta]]]
];
If[Length@frames < 0.8 numberOfframes,
Print["Could not match the desired framerate & duration. Reducing framerate to "<>ToString[(duration/Length@frames)^-1//Round]<>" fps"];
Print["Requires a longer list"]
];

Print["Exporting "<>filename<>".gif (can take a while...)"];
Export[filename <>".gif",frames,"DisplayDurations"->duration/Length@frames] ;
Animate[frames[[i]],{i,1,Length@frames,1}]
]


(* ::Input::Initialization:: *)
Clear[RandomRep];
RandomRep[parameters_,seed_:0,frac_:False]:=Module[{},
If[Not[seed===0],SeedRandom[seed]];
If[frac===False,
Thread[parameters->RandomReal[{0,1},Length@parameters]],
Thread[parameters->Rationalize@Round[RandomReal[{0,1},Length@parameters],0.001]]
]
]


(* ::Input::Initialization:: *)
Clear[positionMax];
positionMax[list_,p_:1]:=Module[{list2,ord},
list2 = If[Length@Dimensions@list>1,list[[All,p]],list];
ord = Ordering[list2];
{Last@ord,list[[Last@ord]]}
]

Clear[positionMin]
positionMin[list_,p_:1]:=Module[{list2,ord},
list2 = If[Length@Dimensions@list>1,list[[All,p]],list];
ord = Ordering[list2];
{First@ord,list[[First@ord]]}
]


(* ::Input::Initialization:: *)
Clear[flat1,flat2];
flat1[list_]:=Flatten[list,1];
flat2[list_]:=Flatten[list,2];


(* ::Input::Initialization:: *)
pbc[i_,L_]:=Mod[i,L,1];


(* ::Input::Initialization:: *)
Clear[nodiag];
nodiag[A_]:=A - DiagonalMatrix@Diagonal@A;


(* ::Input::Initialization:: *)
Clear[\[DoubleStruckF]];
\[DoubleStruckF][x_]:=(1-Tanh[x/2])/2(*1/(\[ExponentialE]^x+1)*);
\[DoubleStruckF][\[Epsilon]_,\[Mu]_,T_]:=\[DoubleStruckF][(\[Epsilon]-\[Mu])/T]


(* ::Input::Initialization:: *)
Clear[Squeeze];
Squeeze[array_]:=ArrayReshape[array,DeleteCases[Dimensions[array],1]]


(* ::Input::Initialization:: *)
Clear[frinch];
frinch[frac_]:=(Print@StringJoin[
ToString/@(TraditionalForm/@MixedFractionParts[frac])];frac)


(* ::Input::Initialization:: *)
Clear[toSphericalCoordinates];
toSphericalCoordinates[{x_,y_,z_}]:={Sqrt[x^2+y^2+z^2],If[Norm[{x,y,z}]===0,0,ArcCos[z/Sqrt[x^2+y^2+z^2]]],If[x===0&&y===0,0,Sign[y] ArcCos[x/Sqrt[x^2+y^2]]]}


(* ::Input::Initialization:: *)
Clear[sphericalInt]
sphericalInt[f_]:=2\[Pi] Integrate[Integrate[r^2 Sin[\[Theta]] f,{\[Theta],0,\[Pi]}],{r,0,\[Infinity]}]
sphericalInt[f_,assump_]:=2\[Pi] Integrate[Integrate[r^2 Sin[\[Theta]] f,{\[Theta],0,\[Pi]},Assumptions->assump],{r,0,\[Infinity]},Assumptions->assump]


(* ::Input::Initialization:: *)
Clear[sphericalUnitVectors]
sphericalUnitVectors[\[Theta]_,\[Phi]_]:=
{
{Sin[\[Theta]] Cos[\[Phi]],Sin[\[Theta]] Sin[\[Phi]],Cos[\[Theta]]},
{Cos[\[Theta]] Cos[\[Phi]],Cos[\[Theta]] Sin[\[Phi]],-Sin[\[Theta]]},
{-Sin[\[Phi]],Cos[\[Phi]],0}
};
sphericalUnitVectors[{x_,y_,z_}]:=Module[{r,\[Theta],\[Phi]},
{r,\[Theta],\[Phi]}=toSphericalCoordinates[{x,y,z}];
sphericalUnitVectors[\[Theta],\[Phi]]
]


(* ::Input::Initialization:: *)
Clear[kron];
kron[mats__?MatrixQ]:=KroneckerProduct[mats];
kron[vecs__?VectorQ]:=Flatten@KroneckerProduct[vecs];

(*a_\[CircleTimes]b_:=kron[a,b];*)
Clear[CircleTimes]
CircleTimes = kron


(* ::Input::Initialization:: *)
Clear[KronEye];
KronEye[A_,\[ScriptCapitalN]_,j_]:=kron[Eye[Length[A]^(j-1)],A,Eye[Length[A]^(\[ScriptCapitalN]-j)]]

KronEye::usage = "KronEye[A,\[ScriptCapitalN],j] = (\[DoubleStruckCapitalI] \[CircleTimes] ... \[DoubleStruckCapitalI] \[CircleTimes] A \[CircleTimes] \[DoubleStruckCapitalI] ... \[CircleTimes] \[DoubleStruckCapitalI], with A at site j and \[ScriptCapitalN] sites in total.";


(* ::Input::Initialization:: *)
Clear[Proj];
Proj[n_,i_]:=SparseArray[{{i,i}->1},{n,n}];
Proj[n_,i_,j_]:=SparseArray[{{i,j}->1},{n,n}];

Proj[{n_,m_},i_]:=SparseArray[{{i,i}->1},{n,m}];
Proj[{n_,m_},i_,j_]:=SparseArray[{{i,j}->1},{n,m}];


(* ::Input::Initialization:: *)
Clear[Basis];
Basis[n_,i_]:=Normal@SparseArray[{i->1},n]
Basis[n_,ilist_?ArrayQ]:=Total@Table[Basis[n,i],{i,ilist}]


(* ::Input::Initialization:: *)
Clear[subspaceProj]
subspaceProj[dtot_,subspace_]:=Eye[dtot][[subspace]]


(* ::Input::Initialization:: *)
Clear[Eye,NEye];
Eye[n_]:=SparseArray[{{i_,i_}->1},{n,n}];
Eye[A_?ArrayQ]:=Eye[Length@A]

NEye[n_]:=SparseArray[{{i_,i_}->1.},{n,n},0.];
NEye[A_?ArrayQ]:=NEye[Length@A]


(* ::Input::Initialization:: *)
Clear[toeplitzMatrix];
toeplitzMatrix[a_,k_,L_]:=If[L==1,If[k==1,{{a}},{{0}}],SparseArray[{Band[{1,k}]->a,Band[{k,1}]->a},{L,L}]]


(* ::Input::Initialization:: *)
Clear[StiffnessMatrix,CirculantMatrix];
StiffnessMatrix[n_]:=toeplitzMatrix[-1,2,n];
CirculantMatrix[n_]:=toeplitzMatrix[-1,2,n]+toeplitzMatrix[-1,-1,n];


(* ::Input::Initialization:: *)
Clear[FirstDerivative];
FirstDerivative[n_,\[CapitalDelta]x_:1,boundary_:None]:=
If[boundary===None,
1/(2\[CapitalDelta]x) SparseArray[{
Band[{1,2}]->1,
Band[{2,1}]->-1
},{n,n}],
1/(2\[CapitalDelta]x) SparseArray[{
{i_,j_}/;j==i+1&&i!=1->1,
{i_,j_}/;j==i-1&&i!=n->-1,
{1,2}->2,
{1,1}->-2,
{n,n}->2,
{n,n-1}->-2
},{n,n}]];

Clear[SecondDerivative]
SecondDerivative[n_,\[CapitalDelta]x_:1,boundary_:None]:=Module[{mat=-(2Eye[n]+StiffnessMatrix[n])},
If[boundary===None,
1/\[CapitalDelta]x^2 mat,
(mat[[1,-1]]=1; mat[[-1,1]]=1; 1/\[CapitalDelta]x^2 mat)
]]



(* ::Input::Initialization:: *)
Clear[Boxcar];
Boxcar[a_,b_][x_]:=UnitStep[x-a]-UnitStep[x-b]

Boxcar[a_,b_,smooth_][x_]:=If[Abs[smooth]<10^-14,Boxcar[a,b][x],1/2 (Tanh[(x-a)/smooth]-Tanh[(x-b)/smooth] )]

Boxcar::usage = "Boxcar[a,b][x] returns a boxcar function from a to b";


(* ::Input::Initialization:: *)
Clear[Eigvals,Eigvecs,Eigsys];

Eigvals[A_,neigs_:"all",\[CapitalDelta]_:10^5]:=If[neigs==="all",
Sort@Eigenvalues[N@A],
Reverse@Eigenvalues[A + \[CapitalDelta] NEye@Length@A,-neigs]-\[CapitalDelta]];

Eigvecs[A_,neigs_:"all",\[CapitalDelta]_:10^5]:=
Module[{tmp,e,v,ord},
If[neigs=="all",(
{e,v}=Eigensystem[N@A];
ord=Ordering[e];
(*Transpose[v\[LeftDoubleBracket]ord\[RightDoubleBracket]]*)
v[[ord]]
),
(
{e,v}=Eigensystem[A + \[CapitalDelta] NEye@Length@A,-neigs];
 (*Transpose@Reverse@v*)Reverse@v
)
]
]

Clear[Eigsys];
Eigsys[A_, neigs_:"all",\[CapitalDelta]_:10^5]:=Module[{tmp,e,v,ord},

If[neigs=="all",(
{e,v}=Eigensystem[N@A];
ord=Ordering[e];
{e[[ord]],(*Transpose[v\[LeftDoubleBracket]ord\[RightDoubleBracket]]*)v[[ord]]}
),
(
{e,v}=Eigensystem[A + \[CapitalDelta] NEye@Length@A,-neigs];
 {Reverse@e-\[CapitalDelta],(*Transpose@*)Reverse@v}
)
]
]




(* ::Input::Initialization:: *)
Clear[GroundState];
(*GroundState[H_]:=Eigvecs[H,1]\[LeftDoubleBracket]1\[RightDoubleBracket]
GroundState[H_,n_]:=Eigvecs[H,n]\[LeftDoubleBracket]-1\[RightDoubleBracket];*)
GroundState[H_]:=Module[{eigs,\[Psi]s,min},
{eigs,\[Psi]s} = Eigensystem[H];
min = First@PositionSmallest[eigs];
{eigs[[min]],\[Psi]s[[min]]}
]


(* ::Input::Initialization:: *)
Clear[TransitionFrequencies];
TransitionFrequencies[H_,n_:1]:=Module[{\[Epsilon] = Eigvals[H,n+1]},\[Epsilon][[2;;n+1]]-First@\[Epsilon]]


(* ::Input::Initialization:: *)
(* y can be a ket or a density matrix *)
Clear[expect];
expect[A_,y_]:=If[Length@Dimensions@y==2,Tr[A . y],y\[Conjugate] . A . y];


(* ::Input::Initialization:: *)
Clear[OrthogonalProjectors]
OrthogonalProjectors[\[DoubleStruckCapitalO]_,tol_:10^-10]:=Module[{eigs,group,distinctEigs,projs,vecs},
eigs = Eigensystem[\[DoubleStruckCapitalO]]\[Transpose];
group=Gather[eigs,Abs[#1[[1]]-#2[[1]]]<10^-5&];
distinctEigs = group[[All,1,1]];
projs = Table[
vecs =g[[All,2]];
Sum[out[v,v],{v,vecs}]
,{g,group}];
{distinctEigs,projs}

]


(* ::Input::Initialization:: *)
Clear[OutcomeDistribution];
OutcomeDistribution[\[DoubleStruckCapitalO]_,y_,tol_:10^-10]:=Module[{distinctEigs,projs},
{distinctEigs,projs}=OrthogonalProjectors[\[DoubleStruckCapitalO]];
Chop@Table[
{distinctEigs[[i]],expect[projs[[i]],y]},{i,Length@distinctEigs}]
]


(* ::Input::Initialization:: *)
Clear[DirectSum]
DirectSum[mats__]:=Module[{m=List@mats,tab, diag,a},
tab= Table[a[i],{i,Length@m}];
diag=DiagonalMatrix[Table[a[i],{i,Length@m}]];
diag/.Thread[tab->m]//ArrayFlatten
]

DirectSum::usage = "DirectSum[A,B,...] yields a diagonal block matrix diag(A,B,...)";


(* ::Input::Initialization:: *)
BCHderiv[G_,dG_,nmax_:100]:=Module[{M},

M = dG;
(dG + Total@Table[
M=G . M-M . G;
1/n! M,{n,2,nmax} ]) . MatrixExp[G]
]


(* ::Input::Initialization:: *)
Clear[LoadPauliMatrices];
LoadPauliMatrices[]:=Module[{},
Clear[\[Sigma]0,\[Sigma]x,\[Sigma]y,\[Sigma]z,\[Sigma]p,\[Sigma]m,GMAT];
\[Sigma]0 = {{1,0},{0,1}};
\[Sigma]x = {{0,1},{1,0}};
\[Sigma]y = {{0,-I},{I,0}};
\[Sigma]z = {{1,0},{0,-1}};
\[Sigma]p = {{0,1},{0,0}}(*(\[Sigma]x + I \[Sigma]y)/2*);
\[Sigma]m = {{0,0},{1,0}}(*(\[Sigma]x - I \[Sigma]y)/2*);
(*nn = \[Sigma]p.\[Sigma]m; *)

GMAT[\[Theta]_,\[Phi]_] := MatrixExp[-I \[Phi] \[Sigma]z/2] . MatrixExp[-I \[Theta] \[Sigma]y/2];

"Matrices loaded: \[Sigma]0 (=1), \[Sigma]x, \[Sigma]y, \[Sigma]z, \[Sigma]p, \[Sigma]m, GMAT[\[Theta],\[Phi]]"
];


(* ::Input::Initialization:: *)
LoadPauliMatrices[]


(* ::Input::Initialization:: *)
LoadSpinChainMatrices[\[ScriptCapitalN]_,type_:"n"]:=Module[{one,\[Sigma]0,\[Sigma]x,\[Sigma]y,\[Sigma]z,\[Sigma]p,\[Sigma]m},

(* 2 x 2 Pauli matrices *)
one = If[type=="n",1.0,1];
\[Sigma]0 = SparseArray[one{{1,0},{0,1}}];
\[Sigma]x = SparseArray[one{{0,1},{1,0}}];
\[Sigma]y = SparseArray[one{{0,-I},{I,0}}];
\[Sigma]z =SparseArray[ one{{1,0},{0,-1}}];
\[Sigma]p =(\[Sigma]x + I \[Sigma]y)/2;
\[Sigma]m = (\[Sigma]x - I \[Sigma]y)/2;

Clear[eye,sp,sm,sx,sy,sz,c,cd];
eye = one Eye[2^\[ScriptCapitalN]];

If[\[ScriptCapitalN]>1,
Do[
eyeL = one Eye[2^(i-1)];
eyeR = one Eye[2^(\[ScriptCapitalN]-i)];
(* Spin matrices of site i *)
sx[i] = kron[eyeL,\[Sigma]x,eyeR];
sy[i] = kron[eyeL,\[Sigma]y,eyeR];
sz[i] = kron[eyeL,\[Sigma]z,eyeR];
sp[i] = kron[eyeL,\[Sigma]p,eyeR];
sm[i] = sp[i]\[Transpose];

(* Fermionic operators using the Jordan Wigner transformation *)
c[i] = kron@@Join[Table[(-\[Sigma]z),{j,1,i-1}],{\[Sigma]m},Table[\[Sigma]0,{j,i+1,\[ScriptCapitalN]}]];
cd[i] = c[i]\[ConjugateTranspose];

,{i,1,\[ScriptCapitalN]}],
(
sx[1] = \[Sigma]x;
sy[1] =\[Sigma]y;
sz[1] = \[Sigma]z;
sp[1] = \[Sigma]p;
sm[1] = \[Sigma]m;
c[1] = \[Sigma]m;
cd[1] = \[Sigma]p;)];

"Matrices loaded: \[Sigma]0 (=1), \[Sigma]x, \[Sigma]y, \[Sigma]z, \[Sigma]p, \[Sigma]m, eye, sm, sp, sx, sy, sz, c, cd"

];


(* ::Input::Initialization:: *)
Clear[LoadFermionicOperators];
LoadFermionicOperators[\[ScriptCapitalN]_,type_:"n",ord_:"non-local"]:=Module[{},

LoadSpinChainMatrices[\[ScriptCapitalN],type];
Clear[sp,sm,sx,sy,sz];
Clear[\[CapitalGamma]];
If[ord=="local",
Do[
\[CapitalGamma][2n-1] = 1/Sqrt[2] (c[n] + cd[n]);
\[CapitalGamma][2n]= I/Sqrt[2] (cd[n]-c[n]),
{n,1,\[ScriptCapitalN]}],
Do[
\[CapitalGamma][n] = 1/Sqrt[2] (c[n] + cd[n]);
\[CapitalGamma][\[ScriptCapitalN]+n]= I/Sqrt[2] (cd[n]-c[n]),
{n,1,\[ScriptCapitalN]}]
];

Clear[sp,sm,sx,sy,sz];
"Matrices loaded: eye, c, cd, \[CapitalGamma]"
]


(* ::Input::Initialization:: *)
Clear[LoadFermionicOperatorsWithSpin];
LoadFermionicOperatorsWithSpin[\[ScriptCapitalN]_,type_:"n",ord_:"non-local"]:=Module[{},

LoadSpinChainMatrices[2\[ScriptCapitalN],type];
Do[
c[i,\[Sigma]] = c[2i - (\[Sigma]+1)/2];
cd[i,\[Sigma]] = cd[2i - (\[Sigma]+1)/2];
,{i,\[ScriptCapitalN]},{\[Sigma],{1,-1}}]
]


(* ::Input::Initialization:: *)
Clear[LoadArbitrarySpinMatrices];
LoadArbitrarySpinMatrices[S_,type_:"n",chain_:1]:=Module[{it,srange,tmp,Opset,opset},

it=If[type=="a",1,1.0];
srange = Range[S,-S,-it];

Clear[Sz,Sp,Sm,Sx,Sy,S0];

Sz= SparseArray@DiagonalMatrix[srange];
Sp = SparseArray@Table[Sqrt[(S-s)(S+s+1)]KroneckerDelta[r,s+1],{r,srange},{s,srange}];
Sm = Sp\[Transpose];
Sx = (Sp+Sm)/2;
Sy = (Sp-Sm)/(2I);
S0 =Eye[2S+1];


If[chain===1,
"Matrices loaded: S0 (=1), Sx, Sy, Sz, Sp, Sm",
(Clear[\[ScriptCapitalS]x,\[ScriptCapitalS]y,\[ScriptCapitalS]z,\[ScriptCapitalS]p,\[ScriptCapitalS]m];
Opset={\[ScriptCapitalS]x,\[ScriptCapitalS]y,\[ScriptCapitalS]z,\[ScriptCapitalS]p,\[ScriptCapitalS]m};
opset={Sx,Sy,Sz,Sp,Sm};
Do[Opset[[n]][i]=KronEye[opset[[n]],chain,i],{n,Length@Opset},{i,chain}];
"Matrices loaded: S0 (=1), Sx, Sy, Sz, Sp, Sm and multi-site \[ScriptCapitalS]x,\[ScriptCapitalS]y,\[ScriptCapitalS]z,\[ScriptCapitalS]p,\[ScriptCapitalS]m"
)
]
];


(* ::Input::Initialization:: *)
LoadBosonicOperators[\[ScriptCapitalN]_,type_:"n",chain_:1]:=Module[{one,tmp,n,m,Opset,opset},
one = If[type=="a",1,1.0];
Clear[\[DoubleStruckCapitalI],a,X,P,CoherentState];
\[DoubleStruckCapitalI]= Eye[\[ScriptCapitalN]];
a=one DiagonalMatrix[SparseArray[Table[Sqrt[n],{n,1,\[ScriptCapitalN]-1}]],1];
\[DoubleStruckCapitalX] = 1/Sqrt[2] (a\[ConjugateTranspose]+a);
\[DoubleStruckCapitalP] = I/Sqrt[2] (a\[ConjugateTranspose]-a);
CoherentState[\[Alpha]_]:=Exp[-Abs[\[Alpha]]^2/2] Table[\[Alpha]^n/Sqrt[n!],{n,0,\[ScriptCapitalN]-1}];
BosonicThermalState[n0_]:=DiagonalMatrix@Table[n0^n (1+n0)^(-1-n),{n,0,\[ScriptCapitalN]-1}];

If[chain===1,
"Matrices loaded: \[DoubleStruckCapitalI] (=1), a, \[DoubleStruckCapitalX], \[DoubleStruckCapitalP], CoherentState[\[Alpha]], ThermalState[n0]",
(Clear[\[ScriptCapitalI],\[ScriptA],\[ScriptX],\[ScriptP]];
Opset={\[ScriptCapitalI],\[ScriptA],\[ScriptX],\[ScriptP]};
opset={\[DoubleStruckCapitalI],a,\[DoubleStruckCapitalX],\[DoubleStruckCapitalP]};
Do[Opset[[n]][i]=KronEye[opset[[n]],chain,i],{n,Length@Opset},{i,chain}];
"Matrices loaded: \[DoubleStruckCapitalI] (=1), a, \[DoubleStruckCapitalX], \[DoubleStruckCapitalP], CoherentState[\[Alpha]], BosonicThermalState[n0], and multi-site \[ScriptCapitalI],\[ScriptA],\[ScriptX],\[ScriptP]"
)
]


]


(* ::Input::Initialization:: *)
LoadGellMannMatrices[]:=Module[{},
Clear[\[Lambda]];
\[Lambda][0]=Eye[3];
\[Lambda][1] = ({
 {0, 1, 0},
 {1, 0, 0},
 {0, 0, 0}
});
\[Lambda][2] = ({
 {0, -I, 0},
 {I, 0, 0},
 {0, 0, 0}
});
\[Lambda][3] = ({
 {1, 0, 0},
 {0, -1, 0},
 {0, 0, 0}
});
\[Lambda][4] = ({
 {0, 0, 1},
 {0, 0, 0},
 {1, 0, 0}
});
\[Lambda][5] = ({
 {0, 0, -I},
 {0, 0, 0},
 {I, 0, 0}
});
\[Lambda][6] = ({
 {0, 0, 0},
 {0, 0, 1},
 {0, 1, 0}
});
\[Lambda][7] = ({
 {0, 0, 0},
 {0, 0, -I},
 {0, I, 0}
});
\[Lambda][8] =1/Sqrt[3] ({
 {1, 0, 0},
 {0, 1, 0},
 {0, 0, -2}
});
"Matrices loaded: \[Lambda][0] = 1, \[Lambda][1],...,\[Lambda][8]"
]


(* ::Input::Initialization:: *)
Clear[Trapz];
Trapz[fs_,\[CapitalDelta]x_]:=\[CapitalDelta]x/2 (fs[[1]] + 2 Total[fs[[2;;-2]]] + fs[[-1]]);

Trapz::usage = "Trapz[fs,\[CapitalDelta]x] integrates the list fs using the trapezoidal rule, with step \[CapitalDelta]x";


(* ::Input::Initialization:: *)
Clear[BracketRoot];
BracketRoot[f_,xmin_,xmax_,npts_:1000]:=Module[{xrange,tab,par,roots,pos,xtab,x},
xrange=linspace[xmin,xmax,npts];
tab = f/@xrange;
par = {Range[1,Length@tab-1],Most[tab] Rest[tab]}\[Transpose];
pos =Select[par,#[[2]]<= 0.0&][[All,1]];
Table[{xrange[[p]],xrange[[p+1]]},{p,pos}]
]

BracketRoot::usage = "BracketRoot[f,xmin,xmax] tries to bracket all roots of f(x) within the interval [xmin,xmax].";


(* ::Input::Initialization:: *)
Clear[FindAllRoots];
FindAllRoots[f_,xmin_,xmax_,npts_:1000]:=Module[{x,xtab},
xtab = BracketRoot[f,xmin,xmax,npts];
Table[x/.FindRoot[f[x],{x,xt[[1]],xt[[2]]}],{xt,xtab}]
]

FindAllRoots::usage = "FindAllRoots[f,xmin,xmax] finds all roots of f(x) within the interval [xmin,xmax].";


(* ::Input::Initialization:: *)
Clear[LegendreGauss];
LegendreGauss[n_,prec_]:=Block[{roots,p,x,w},
roots=Solve[LegendreP[n,x]==0,x];
p=N[\[Pi]/4(x+1)/.roots,prec];
w=(\[Pi]/4)N[2(1-x^2)/((n+1)LegendreP[n+1,x])^2/.roots,prec];
{Join[p,p+\[Pi]/2],Join[w Sin[p],w Sin[p+\[Pi]/2]]}
];

LegendreGauss[n\[Theta]_,n\[Phi]_,prec_]:=Block[{p\[Theta],w\[Theta],p\[Phi],w\[Phi],p,w},
{p\[Theta],w\[Theta]} = LegendreGauss[n\[Theta],prec];
p\[Phi] = linspace[0,2\[Pi],n\[Phi]];
w\[Phi] = ConstantArray[(2\[Pi])/( n\[Phi]-1),{n\[Phi]}];  
p = Tuples[{p\[Theta],p\[Phi]}];
w = Times@@#&/@Tuples[{w\[Theta],w\[Phi]}];
{p,w}
]

LegendreGauss::usage = "Generates grid of (points,weights) for numerical integration in a sphere.";


(* ::Input::Initialization:: *)
Clear[RK4,RK4t];
(* For time-indeendent RHS f(y) *)
RK4[f_,y0_,\[CapitalDelta]t_,tf_,onlyLastOutput_:False,quiet_:False]:=Module[{F},
(* input function f[y] *)
F[y_]:=Block[{k1,k2,k3,k4},
k1 = f[y];
k2 = f[y + \[CapitalDelta]t k1/2];
k3 = f[y + \[CapitalDelta]t k2/2];
k4 = f[y+\[CapitalDelta]t k3];
y + \[CapitalDelta]t/6 (k1+2k2+2k3+k4)
];
If[quiet===False,
If[onlyLastOutput===False,
Transpose[{Range[0,tf,\[CapitalDelta]t],nestList[F,y0,Round[tf/\[CapitalDelta]t]]}],
nest[F,y0,Round[tf/\[CapitalDelta]t]]
],
If[onlyLastOutput===False,
Transpose[{Range[0,tf,\[CapitalDelta]t],NestList[F,y0,Round[tf/\[CapitalDelta]t]]}],
Nest[F,y0,Round[tf/\[CapitalDelta]t]]
]
]
]

(* for a time-dependent RHS f(t,y) -> y' *)
RK4t[f_,y0_,\[CapitalDelta]t_,tf_,onlyLastOutput_:False, quiet_:False]:=Module[{F},
(* input function f[t, y] *)
F[{t_,y_}]:=Block[{k1,k2,k3,k4},
k1 = f[t,y];
k2 = f[t+\[CapitalDelta]t/2,y + \[CapitalDelta]t k1/2];
k3 = f[t+\[CapitalDelta]t/2,y + \[CapitalDelta]t k2/2];
k4 = f[t+\[CapitalDelta]t,y+\[CapitalDelta]t k3];
{t+\[CapitalDelta]t,y + \[CapitalDelta]t/6 (k1+2k2+2k3+k4)}
];

If[quiet===False,
If[onlyLastOutput===False,
nestList[F,{0,y0},Round[tf/\[CapitalDelta]t]],
nest[F,{0,y0},Round[tf/\[CapitalDelta]t]][[2]]
],
If[onlyLastOutput===False,
NestList[F,{0,y0},Round[tf/\[CapitalDelta]t]],
Nest[F,{0,y0},Round[tf/\[CapitalDelta]t]][[2]]
]
]

]

Clear[RK4linear];
RK4linear[A_,y0_,\[CapitalDelta]t_,tf_,onlyLastOutput_:False, quiet_:False]:=RK4[Function[x,A . x],y0,\[CapitalDelta]t,tf,onlyLastOutput, quiet]


(* ::Input::Initialization:: *)
GramChalierEdgeworth[cumulants_]:=Module[{d = Length@cumulants,\[Mu],\[Sigma],\[Kappa]list,Bn},
\[Mu] = cumulants[[1]];
\[Sigma] = Sqrt[cumulants[[2]]];
\[Kappa]list = Join[{0,0},cumulants[[3;;-1]]];
Bn = Table[Sum[BellY[n,k,\[Kappa]list],{k,1,n}],{n,3,d}];

Function[1/Sqrt[2\[Pi] \[Sigma]^2] Exp[-((#-\[Mu])^2/(2\[Sigma]^2))] (1 + Sum[1/(n! \[Sigma]^n) Bn[[n-2]] 2^(-n/2) HermiteH[n,(#-\[Mu])/(\[Sigma] Sqrt[2])],{n,3,d}])]

(*1/Sqrt[2\[Pi] \[Sigma]^2]Exp[-((x-\[Mu])^2/(2\[Sigma]^2))] (1 + Sum[1/(n!\[Sigma]^n)Bn\[LeftDoubleBracket]n-2\[RightDoubleBracket] 2^(-n/2)HermiteH[n,(x-\[Mu])/(\[Sigma] Sqrt[2])],{n,3,d}])
*)]


(* ::Input::Initialization:: *)
(* The Ps do not have to be normalised *)
Clear[SillySample];
SillySample[xs_?VectorQ,Ps_?VectorQ,nsamp_:1]:=If[nsamp===1,RandomChoice[Ps->xs],RandomChoice[Ps->xs,nsamp]]
SillySample[P_?MatrixQ,nsamp_:1]:=SillySample[P[[All,1]],P[[All,2]],nsamp]


(* ::Input::Initialization:: *)
Clear[TwoPointCorrelation];
TwoPointCorrelation[data_,hmax_,dt_:None,steps_:1]:=Module[{\[ScriptCapitalN]=Length@data,ave = Mean[data],vec1,M,corr},
vec1 = data[[1;;\[ScriptCapitalN]-hmax]]-ave;
M = Table[data[[1+i;;\[ScriptCapitalN]-hmax+i]]-ave,{i,1,hmax,steps}];
corr = 1/(\[ScriptCapitalN]-hmax) M . vec1;
If[dt===None,corr,{dt Range[1, hmax,steps],corr}\[Transpose]]
]


(* ::Input::Initialization:: *)
(* Computes \!\(
\*SubsuperscriptBox[\(\[Integral]\), \(-\[Infinity]\), \(\[Infinity]\)]\(dk\ C\((k)\)\ 
\*SuperscriptBox[\(e\), \(ikx\)]\ for\ a\ generic\ function\ C\((k)\)\ and\ a\ discrete\ set\ of\ points\ x\ from\ 
\*SubscriptBox[\(x\), \(i\)]\ to\ 
\*SubscriptBox[\(x\), \(f\)]\ in\ steps\ of\ dx\)\) *)

(* To compute with e^-ikx use "sign = -1" *)
Clear[FourierWithFreqs]
FourierWithFreqs[\[ScriptCapitalC]_,xi_,xf_,dx_,sign_:1]:=Module[{xs,M,dk,kf,ki,ur,P},
xs = range[xi,xf,dx];
M = Length@xs;
If[EvenQ[M],
M = M+1;
xs = range[xi,xf+dx,dx]
];
dk =( 2\[Pi])/(M dx);
kf = (M-1)/M \[Pi]/dx;
ki = -kf;
If[sign==1,
ur = Table[E^(I xi(r-1)dk) \[ScriptCapitalC][ki + (r-1) dk],{r,1,M}];
P=dk  Sqrt[M] Table[E^(I ki xi+I ki(s-1) dx),{s,1,M}]Fourier[ur]//Chop(*//Reverse*);
,
ur = Table[E^(-I xi(r-1)dk) \[ScriptCapitalC][ki + (r-1) dk],{r,1,M}];
P=dk  Sqrt[M] Table[E^(-I ki xi-I ki(s-1) dx),{s,1,M}]InverseFourier[ur]//Chop(*//Reverse*);
];
(*{xs[[2;;-1;;1]],P[[1;;-2;;1]]}\[Transpose]*)
{xs,P}\[Transpose]
]


(* ::Input::Initialization:: *)
(* OLD VERSION *)
(*Clear[FourierWithFreqs];
FourierWithFreqs[x_,dt_,transform_:Fourier]:=Module[{d,xf,\[Omega]s,\[Omega]s2,hamm},
d = Length@x;
If[OddQ[d],d=d-1];
hamm = Table[1/2(1.0-Cos[(2\[Pi] j)/d]),{j,0,d-1}];
xf = transform[x\[LeftDoubleBracket]1;;d\[RightDoubleBracket] hamm];
\[Omega]s = Range[0,d/2] (2\[Pi])/(d dt);
\[Omega]s2 = -Reverse@Drop[Drop[\[Omega]s,1],{-1}];
{Join[\[Omega]s2,\[Omega]s],Join[xf\[LeftDoubleBracket]d/2+2;;d\[RightDoubleBracket],xf\[LeftDoubleBracket]1;;d/2+1\[RightDoubleBracket]]}\[Transpose]
]*)


(* ::Input::Initialization:: *)
Clear[PowerSpectrum];
PowerSpectrum[x_,dt_,averaging_:1,overlap_:0.3]:=Module[{d,xf,\[Omega]s,hamm,S,k,xs,Ss},
d = Length@x;
If[OddQ[d],d=d-1];

k=If[averaging==1,d,(2d)/(2averaging-1)//Floor]; 
If[OddQ[k],k=k-1];

(*hamm = Table[1/2(1.0-Cos[(2\[Pi] j)/k]),{j,0,k-1}]; *)
\[Omega]s = Range[1,k/2] (2\[Pi])/(k dt); 
\[Omega]s = Join[-Reverse@Drop[\[Omega]s,{-1}],\[Omega]s];

xs  = Partition[x,k,Floor[overlap k]];

xf = Table[Fourier[(*hamm*)(xx[[1;;k]]-Mean[xx])],{xx,xs}]; 
S = Mean@Table[dt Abs[xxf]^2,{xxf,xf}];      

{\[Omega]s,Join[S[[k/2+2;;k]],S[[2;;k/2+1]]]}\[Transpose]  
]


(* ::Input::Initialization:: *)
(* averaging = number of segments to divide the data and average *)
(* overlap = percentage overlap between each segment *)
(* Variables passed to Python must be kept as global (apparently) *)
Clear[PowerSpectrumPython];
PowerSpectrumPython[x_,dt_,averaging_:1,overlap_:0.3]:=Module[{\[ScriptCapitalN],res},
\[ScriptCapitalN] = Length@x;
Clear[ddata,nperseg,noverlap,fs];
ddata = x; 
(* Number of points in each segment *)
nperseg = Ceiling[\[ScriptCapitalN]/averaging]; 
(* Number of points of overlap between each segment *)
noverlap = Ceiling[overlap nperseg];
fs = 1/dt;
res=ExternalEvaluate["Python","from scipy.signal import welch;welch(<* ddata *>, fs= <* fs *>, window='hann', nperseg=<* nperseg *>, noverlap=<* noverlap *>)"];
Clear[ddata,nperseg,noverlap,fs];
Transpose@{2\[Pi] Normal[res[[1]]] ,1/2 Normal[res[[2]]]}
]


(* ::Input::Initialization:: *)
Clear[butter];
butter[data_,\[Omega]c_,dt_:1,order_:2]:=Module[{f,b},
f=RecurrenceFilter[ToDiscreteTimeModel[ButterworthFilterModel[{"Lowpass",order,\[Omega]c }],dt],data];
b=RecurrenceFilter[ToDiscreteTimeModel[ButterworthFilterModel[{"Lowpass",order,\[Omega]c }],dt],Reverse[data]];
(f+Reverse[b])/2
]


(* ::Input::Initialization:: *)
Clear[DistributionFromData];
DistributionFromData[data_,\[CapitalDelta]\[CapitalDelta]x_:Automatic]:=Module[{\[CapitalDelta]x,max,min,d,x,p},
min = Min@data;
max = Max@data;
d = Length@data;
\[CapitalDelta]x=Which[
NumberQ[\[CapitalDelta]\[CapitalDelta]x],\[CapitalDelta]\[CapitalDelta]x,
matchString["discrete",\[CapitalDelta]\[CapitalDelta]x] &&Not[ Head[data[[1]]]===Real],First@DeleteCases[Sort@Differences@Sort@Y,0],
True,10 (max-min)/d];

x = N@Range[min,max,\[CapitalDelta]x];
p=BinCounts[data, {min,max+\[CapitalDelta]x,\[CapitalDelta]x}]/d  //N;    

{x,p}\[Transpose]
]


(* ::Input::Initialization:: *)
antiSymmetric4Tensor[\[Alpha]_,\[Beta]_]:=({
 {0, -\[Alpha][[1]], -\[Alpha][[2]], -\[Alpha][[3]]},
 {\[Alpha][[1]], 0, \[Beta][[3]], -\[Beta][[2]]},
 {\[Alpha][[2]], -\[Beta][[3]], 0, \[Beta][[1]]},
 {\[Alpha][[3]], \[Beta][[2]], -\[Beta][[1]], 0}
});


(* ::Input::Initialization:: *)
Clear[LoadGeneratorsofRotations]
LoadGeneratorsofRotations[]:=Module[{},
Clear[Jx,Jy,Jz];
Jx = ({
 {0, 0, 0},
 {0, 0, -I},
 {0, I, 0}
});
Jy = ({
 {0, 0, I},
 {0, 0, 0},
 {-I, 0, 0}
});
Jz = ({
 {0, -I, 0},
 {I, 0, 0},
 {0, 0, 0}
});
]


(* ::Input::Initialization:: *)
Clear[LoadLorentzGenerators]
LoadLorentzGenerators[]:=Module[{},
Clear[K,J,\[ScriptCapitalJ],g];
g = DiagonalMatrix[{1,-1,-1,-1}];

K[1] = \!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"0", 
RowBox[{"-", "I"}], "0", "0"},
{
RowBox[{"-", "I"}], "0", "0", "0"},
{"0", "0", "0", "0"},
{"0", "0", "0", "0"}
},
GridBoxAlignment->{"Columns" -> {{Center}}, "Rows" -> {{Baseline}}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\);
K[2] = \!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"0", "0", 
RowBox[{"-", "I"}], "0"},
{"0", "0", "0", "0"},
{
RowBox[{"-", "I"}], "0", "0", "0"},
{"0", "0", "0", "0"}
},
GridBoxAlignment->{"Columns" -> {{Center}}, "Rows" -> {{Baseline}}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\);
K[3] = ({
 {0, 0, 0, -I},
 {0, 0, 0, 0},
 {0, 0, 0, 0},
 {-I, 0, 0, 0}
});
J[1] = ({
 {0, 0, 0, 0},
 {0, 0, 0, 0},
 {0, 0, 0, -I},
 {0, 0, I, 0}
});
J[2] = ({
 {0, 0, 0, 0},
 {0, 0, 0, I},
 {0, 0, 0, 0},
 {0, -I, 0, 0}
});
J[3] = ({
 {0, 0, 0, 0},
 {0, 0, -I, 0},
 {0, I, 0, 0},
 {0, 0, 0, 0}
});
\[ScriptCapitalJ][0,0]= \[ScriptCapitalJ][1,1]=\[ScriptCapitalJ][2,2]=\[ScriptCapitalJ][3,3]= 0 K[1];
\[ScriptCapitalJ][1,0] = K[1];
\[ScriptCapitalJ][0,1] = -K[1];
\[ScriptCapitalJ][2,0] = K[2];
\[ScriptCapitalJ][0,2]=-K[2];
\[ScriptCapitalJ][3,0] = K[3]; 
\[ScriptCapitalJ][0,3] = -K[3];
\[ScriptCapitalJ][2,3] = J[1];
\[ScriptCapitalJ][3,2] = -J[1];
\[ScriptCapitalJ][3,1] = J[2];
\[ScriptCapitalJ][1,3] = -J[2];
\[ScriptCapitalJ][1,2] = J[3];
\[ScriptCapitalJ][2,1]=-J[3];

]


(* ::Input::Initialization:: *)
Clear[TightBindingHamiltonian];
TightBindingHamiltonian[L_,V_:1,J_:1]:=J StiffnessMatrix[L] + Which[
ArrayQ[V],DiagonalMatrix@SparseArray[Flatten[Table[V,{Ceiling[L/Length@V]}]][[1;;L]]],
True,toeplitzMatrix[V,1,L]
];


(* ::Input::Initialization:: *)
Clear[TightBindingHamiltonianPBC];
TightBindingHamiltonianPBC[L_,V_:1,J_:1]:=J CirculantMatrix[L] + Which[
ArrayQ[V],DiagonalMatrix@SparseArray[Flatten[Table[V,{Ceiling[L/Length@V]}]][[1;;L]]],
True,toeplitzMatrix[V,1,L]
];


(* ::Input::Initialization:: *)
(* Subscript[\[Lambda], c] = 2 *)
Clear[aubryAndreHarper];
aubryAndreHarper[L_,\[Phi]_:0,\[Alpha]_:0]:=Table[Cos[ 2.0\[Pi] GoldenRatio n + \[Phi]]/(1-\[Alpha] Cos[2\[Pi] GoldenRatio n + \[Phi]]),{n,1,L}];


(* ::Input::Initialization:: *)
Clear[fibonacciString];
fibonacciString[L_]:=Table[IntegerPart[(n+1) 1/GoldenRatio^2]-IntegerPart[n 1/GoldenRatio^2],{n,1,L}];

fibonacciString[L_,a_,b_]:=fibonacciString[L]/.{0->a,1->b}


(* ::Input::Initialization:: *)
sshHamiltonian[L_,\[Tau]0_,\[Delta]\[Tau]_,\[Epsilon]_:1]:= Module[{hop = Table[\[Tau]0-(-1)^j \[Delta]\[Tau],{j,1,L-1}]},
- \[Epsilon] DiagonalMatrix[ConstantArray[\[Epsilon],L]]  + DiagonalMatrix[hop,1] + DiagonalMatrix[hop,-1]//SparseArray
]


(* ::Input::Initialization:: *)
(*Clear[UnitaryDynamics];
UnitaryDynamics[H_,\[Psi]0_,tf_,quiet_:False]:=Module[{eqs,\[Psi],time},
Clear[t];
eqs = {
\[Psi]'[t]==-\[ImaginaryI] Normal[H].\[Psi][t],
\[Psi][0]==Normal[\[Psi]0]};

If[quiet===False,
(Monitor[
NDSolveValue[eqs,\[Psi],{t,0,tf},
StepMonitor:>(time=t)],
If[NumberQ[time],ProgressIndicator[time/tf],""]]
),(
NDSolveValue[eqs,\[Psi],{t,0,tf}])
]
]*)


(* ::Input::Initialization:: *)
Clear[UnitaryDynamics];
UnitaryDynamics[H_,\[Psi]0_,tf_,quiet_:False,args___]:=Module[{eqs,\[Psi],time},
Clear[t];
eqs = {
\[Psi]'[t]==-I Normal[H] . \[Psi][t],
\[Psi][0]==Normal[\[Psi]0]};

If[quiet===False,
(Monitor[
NDSolveValue[eqs,\[Psi],{t,0,tf},
StepMonitor:>(time=t),
Method->{"Projection",Method->"ImplicitRungeKutta","Invariants"->Norm[\[Psi][t]]^2},
args
],
If[NumberQ[time],ProgressIndicator[time/tf],""]]
),(
NDSolveValue[eqs,\[Psi],{t,0,tf},Method->{"Projection",Method->"ImplicitRungeKutta","Invariants"->Norm[\[Psi][t]]^2},
args])
]
]


(* ::Input::Initialization:: *)
Clear[CounterDiabaticHamiltonian];
CounterDiabaticHamiltonian[Hs_,tf_,dt_]:=Module[{Hbare,T,Vs,HCD,hcd,V},

Hbare = Table[Hs[t],{t,0,tf,dt}];
T = Length@Hbare;

Vs=Normal@Table[
V=Eigvecs[Hbare[[n]]];
(V\[Transpose] Exp[I Arg[V[[1]]]])\[Transpose]  (* fixes so that eigenvectors always have the same phases *)
,{n,T}];

HCD =  Table[
hcd=I ((Vs[[n+1]]-Vs[[n-1]])/(2dt)) . Vs[[n]]\[ConjugateTranspose]; 
(hcd+hcd\[ConjugateTranspose])/2,{n,2,T-1}];

HCD=Join[{0 Hbare[[1]]},HCD,{0 Hbare[[1]]}];
{Hbare,HCD}

]


(* ::Input::Initialization:: *)
Clear[UnitaryPeriodicDriving]
UnitaryPeriodicDriving[H_,T_,nperi_,\[Psi]0_,npts_:100,onlyLastOutput_:False]:=Module[{dt=T/npts,Vs,\[Psi],U,Us,states,\[Psi]s},
Vs = Table[MatrixExp[-I H[(n-1) dt] dt],{n,1,npts}]; 
\[Psi]=\[Psi]0;
If[onlyLastOutput===True,
((*Stroboscopic list of states*)
U =NEye[Length@\[Psi]0];
Do[U = Vs[[n]] . U,{n,npts}];
\[Psi]s = Table[\[Psi] = U . \[Psi],{j,nperi}];
{T Range[1,nperi ],\[Psi]s}\[Transpose]
),
(
\[Psi]s=Flatten[Table[\[Psi] = Vs[[n]] . \[Psi],{j,nperi},{n,npts}],1];
Prepend[{dt Range[1,Length@\[Psi]s,1],\[Psi]s}\[Transpose],{0,\[Psi]0}]
)]
]


(* ::Input::Initialization:: *)
(* \[ExponentialE]^-\[ImaginaryI]\[Phi]|n\[RightAngleBracket] = |n+1\[RightAngleBracket] *)
Clear[TransmonExpMinusPhi];
TransmonExpMinusPhi[nmax_]:=DiagonalMatrix[ConstantArray[1,{2nmax}],-1]//SparseArray

Clear[TransmonNop];
TransmonNop[nmax_]:=DiagonalMatrix@Range[-nmax,nmax,1]//SparseArray;

Clear[TransmonH];
TransmonH[nmax_,EJ_,ng_,EC_:1]:=Module[{n,em\[Phi],\[DoubleStruckCapitalI]},
n = TransmonNop[nmax];
em\[Phi] = TransmonExpMinusPhi[nmax];
\[DoubleStruckCapitalI] = Eye[2nmax+1];
4 EC (n-ng \[DoubleStruckCapitalI]) . (n-ng \[DoubleStruckCapitalI])- EJ/2 (em\[Phi] + em\[Phi]\[ConjugateTranspose])
]


(* ::Input::Initialization:: *)
(*SchriefferWolffSolve[Ps_,H0_,V_]:=Module[{i,j,s,S1,eqs,vars,sol,H2,Vd,Vo},
Vd = Sum[P.V.P,{P,Ps}];
Vo = V-Vd;
S1 = Table[s[i,j],{i,Length@H0},{j,Length@H0}];
S1 = S1-DiagonalMatrix@Diagonal@S1;
eqs = Flatten[\[DoubleStruckCapitalC][H0,S1]-Vo];
vars = DeleteCases[Flatten[S1],0];
sol=First@Solve[Thread[eqs==ConstantArray[0,Length@eqs]],vars];
S1=S1/.sol;
H2 = 1/2\[DoubleStruckCapitalC][S1,Vo];
{S1,Vd,H2,Sum[P.H2.P,{P,Ps}],H0+Vd+H2}
]*)


(* ::Input::Initialization:: *)
Clear[SchriefferWolffSolve];
SchriefferWolffSolve[Ps_,H0_,V_]:=Module[{i,j,s,S,eqs,vars,sol,H2,Vd,Vo,d=Length@H0},
Vd = Sum[P . V . P,{P,Ps}];
Vo = V-Vd;
S = Table[s[i,j],{i,d},{j,d}];
S = Sum[Ps[[i]] . S . Ps[[j]],{i,1,Length@Ps},{j,1,i-1}]+Sum[Ps[[i]] . S . Ps[[j]],{i,1,Length@Ps},{j,i+1,Length@Ps}];
eqs=Flatten[\[DoubleStruckCapitalC][H0,S]-Vo];
vars = DeleteCases[Flatten[S],0];
sol=First@Solve[Thread[eqs==ConstantArray[0,Length@eqs]],vars];
S=S/.sol;
H2 = 1/2 \[DoubleStruckCapitalC][S,Vo];
{S,H0+Vd+Sum[P . H2 . P,{P,Ps}]}
]


(* ::Input::Initialization:: *)
Clear[MagnusFloquetExpansion];
MagnusFloquetExpansion[H0_,V_,\[Omega]_,t0_:0]:=1/\[Omega] Sum[1/n (\[DoubleStruckCapitalC][V[[n]],V[[n]]\[ConjugateTranspose]]+\[DoubleStruckCapitalC][H0,V[[n]] E^(I n \[Omega] t0)-V[[n]]\[ConjugateTranspose] E^(-I n \[Omega] t0)]),{n,1,Length@V}]


(* ::Input::Initialization:: *)
Clear[MagnusFloquetMicroMotion];
MagnusFloquetMicroMotion[H0_,V_,\[Omega]_,\[Phi]_]:=Module[{K,n,t0=\[Phi]/\[Omega]},
K = H0 t0 + Sum[1/(I n \[Omega]) (V[[n]] (E^(I n \[Phi])-1)-V[[n]]\[ConjugateTranspose] (E^(-I n \[Phi])-1)),{n,Length@V}]
]


(* ::Input::Initialization:: *)
Clear[EigenoperatorDecomposition];
EigenoperatorDecomposition[H_,b_]:=Module[{\[ScriptCapitalE],S},
{\[ScriptCapitalE],S}=Eigensystem[N@H];
EigenoperatorDecomposition[\[ScriptCapitalE],S,b]
];

EigenoperatorDecomposition[\[ScriptCapitalE]_,S_,b_,ana_:False]:=Module[{tol=10^-11,d=Length@\[ScriptCapitalE],\[Omega]s,\[Omega],\[Psi],\[Phi],bs,test},
\[Omega]s = Sort@DeleteDuplicates[Flatten@Table[\[Epsilon]-\[Epsilon]p,{\[Epsilon],\[ScriptCapitalE]},{\[Epsilon]p,\[ScriptCapitalE]}],Abs[#1-#2]<=tol&];
If[ana==False,test[x_]:=Abs[x]<tol,test[x_]:=Simplify[x]===0];
(*bs=Table[{\[Omega],Sum[out[S[[i]],S[[i]]].b.out[S[[j]],S[[j]]]If[Abs[\[ScriptCapitalE][[j]]-\[ScriptCapitalE][[i]]-\[Omega]]<tol,1,0](*KroneckerDelta[\[ScriptCapitalE][[j]]-\[ScriptCapitalE][[i]],\[Omega]]*),{i,d},{j,d}]},{\[Omega],\[Omega]s}];*)
bs=Table[{\[Omega],Sum[out[S[[i]],S[[i]]] . b . out[S[[j]],S[[j]]]If[test[\[ScriptCapitalE][[j]]-\[ScriptCapitalE][[i]]-\[Omega]],1,0](*KroneckerDelta[\[ScriptCapitalE][[j]]-\[ScriptCapitalE][[i]],\[Omega]]*),{i,d},{j,d}]},{\[Omega],\[Omega]s}];
Select[bs,Norm[#[[2]]]>tol&]\[Transpose]
];




(* ::Input::Initialization:: *)
Clear[HydrogenAtom\[Psi]];
HydrogenAtom\[Psi][n_,l_,m_,a_:1]:=Module[{\[Rho]},
Clear[r,\[Theta],\[Phi]];
\[Rho] = (2r)/(n a);
If[l<=n-1 && Abs[m]<=l,
Sqrt[(2/(n a))^3 (n-l-1)!/(2n ((n+l)!))] E^(-\[Rho]/2) \[Rho]^l LaguerreL[n-l-1,2l+1,\[Rho]] SphericalHarmonicY[l,m,\[Theta],\[Phi]],
0]
]


(* ::Input::Initialization:: *)
(* Blocks is a list of lists of the form {{1,2,4},{3,5},{6}} etc. *)
(* It is assumed that H is already block diagonal in these blocks *)
Clear[BlockDiagonalize]
BlockDiagonalize[H_,blocks_,tol_:10^-10]:=Module[{\[ScriptCapitalE],\[ScriptCapitalK],tab,Z,z,\[ScriptCapitalE]distinct,newbs},
(* Matrix with all zeros *)
Z = ConstantArray[0,{Length@H,Length@H}];

tab=Table[
{\[ScriptCapitalE],\[ScriptCapitalK]} = Eigensystem[H[[b,b]]];
\[ScriptCapitalK] = \[ScriptCapitalK]\[Transpose];
(* Embed on Z the eigenvector matrix \[ScriptCapitalK] of the corresponding block *);
z = Z;
z[[b,b]]=\[ScriptCapitalK];

(* Find new blocks within each old block *)
\[ScriptCapitalE]distinct = DeleteDuplicates[\[ScriptCapitalE],Abs[#1-#2]<=tol&];
newbs=Table[Select[{Range[1,Length@b],\[ScriptCapitalE]}\[Transpose],Abs[#[[2]]-\[Lambda]]<tol&][[All,1]],{\[Lambda],\[ScriptCapitalE]distinct}];

{Table[b[[\[Beta]]],{\[Beta],newbs}],Chop@Table[\[ScriptCapitalE][[\[Beta]]],{\[Beta],newbs}],z}
,{b,blocks}];

{flat1@Join[tab[[All,1]]],flat1@Join[tab[[All,2]]],Total@tab[[All,3]]}
]


(* ::Input::Initialization:: *)
Clear[SimultaneousDiagonalization];
SimultaneousDiagonalization[oplist_,tol_:10^-8]:=Module[{A,\[CapitalLambda],Q,q,nops,dim,range,blocks,U,n,fblocks,degeneracies,eiglist,eigblocks,commtest},

nops = Length@oplist;
dim = Length@First@oplist;
range = Range[1,dim];

(* Check if all operators indeed commute *)
commtest=Max@Abs@Flatten@Table[ChopCheck[\[DoubleStruckCapitalC][oplist[[i]],oplist[[j]]]],{i,nops},{j,i+1,nops}];
If[commtest>tol,(Print["Operators do not commute"];Abort[])];

(* Block diagonalize each operator, rotating the basis each time *)
(* Matrix U will ultimately give the final unitary that diagonalizes everything *)
U = Eye[dim];
blocks[0] = {range};
Do[
{blocks[n],\[CapitalLambda][n],Q[n]} = BlockDiagonalize[U\[ConjugateTranspose] . oplist[[n]] . U,blocks[n-1],tol];
U = U . Q[n];
,{n,1,nops}];

(* The last block structure of the above loop is the finest block structure *)
fblocks = blocks[nops];
degeneracies = Length/@fblocks;
eiglist=Table[Diagonal[U\[ConjugateTranspose] . op . U],{op,oplist}]\[Transpose];
(* Lists only the distinct eigenvalues in each block *)
eigblocks=Table[eiglist[[b[[1]]]],{b,fblocks}];
{fblocks,degeneracies,eigblocks,U}
]



(* ::Input::Initialization:: *)
Clear[BlochVector];
BlochVector[y_]:=cf@Chop@{expect[PauliMatrix[1],y],expect[PauliMatrix[2],y],expect[PauliMatrix[3],y]}


(* ::Input::Initialization:: *)
ThermalState[H_]:=Module[{\[Rho] = MatrixExp[-H]},\[Rho]/Tr[\[Rho]]]


(* ::Input::Initialization:: *)
Clear[DM];
DM[\[Rho]_?MatrixQ]:=\[Rho]/Tr[\[Rho]];
DM[p_?VectorQ]:=p/Total[p];


(* ::Input::Initialization:: *)
Clear[PTr]
PTr[state_,list_,locdimlist_]:=Module[{i,eye,v,L,n,tups,tab,\[ScriptCapitalN],\[Rho]},
\[Rho] = If[Length@Dimensions[state]===2,state,out[state,state]];
n = Length@locdimlist;
Do[eye[l] = Eye[locdimlist[[l]]],{l,n}];

Do[v[l,i] = {eye[l][[i]]}\[Transpose],{l,n},{i,locdimlist[[l]]}];
tups = Tuples@Table[Range[1,l],{l,locdimlist[[list]]}];
tab = Table[
kron@@Table[If[MemberQ[list,l],v[l,j[[Position[list,l][[1,1]]]]],eye[l]],{l,n}],{j,tups}];
Total@Table[(tab[[i]])\[Transpose] . \[Rho] . tab[[i]],{i,Length@tab}]
];

PTr[\[Rho]_,list_,locdim_?NumberQ]:= PTr[\[Rho],list,ConstantArray[locdim,Log[locdim, Length@\[Rho]]]]

PTr[\[Rho]_,list_]:=PTr[\[Rho],list,2];


(* ::Input::Initialization:: *)
(* Faster *)
Clear[TwoQubitPTr];
TwoQubitPTr[\[Rho]_,tracingout_]:=Module[{},
If[tracingout===2,
({
 {\[Rho][[1,1]]+\[Rho][[2,2]], \[Rho][[1,3]]+\[Rho][[2,4]]},
 {\[Rho][[3,1]]+\[Rho][[4,2]], \[Rho][[3,3]]+\[Rho][[4,4]]}
}),
({
 {\[Rho][[1,1]]+\[Rho][[3,3]], \[Rho][[1,2]]+\[Rho][[3,4]]},
 {\[Rho][[2,1]]+\[Rho][[4,3]], \[Rho][[2,2]]+\[Rho][[4,4]]}
})
]
]


(* ::Input::Initialization:: *)
Clear[vonNeumann];
vonNeumann[\[Rho]_?MatrixQ,base_:E]:= Module[{eigs,func},
eigs = Eigenvalues[\[Rho]];
func[x_]:= If[NumberQ[x]&&Re@x<10^-12,0,-x Log[base,x]];
Chop@Sum[func[eigs[[i]]],{i,1,Length@eigs}]
]

vonNeumann[\[Rho]_?VectorQ,base_:E]:= Module[{func},
func[x_]:= If[NumberQ[x]&&Re@x<10^-12,0,-x Log[base,x]];
Chop@Sum[func[\[Rho][[i]]],{i,1,Length@\[Rho]}]
]



(* ::Input::Initialization:: *)
Clear[Renyi];
Renyi[\[Rho]_?MatrixQ,\[Alpha]_,base_:E]:= Module[{eigs,func},
Which[
\[Alpha] ==1.0,vonNeumann[\[Rho]],
\[Alpha] ==\[Infinity],-Log[base,Max@Eigenvalues[\[Rho]]],
True,(eigs = Eigenvalues[\[Rho]];
1/(1-\[Alpha]) Log[base,Sum[(eigs[[i]])^\[Alpha],{i,1,Length@eigs}]])]//Chop
]

Renyi[\[Rho]_?VectorQ,\[Alpha]_,base_:E]:= Module[{func},
Which[
\[Alpha] ==1.0,vonNeumann[\[Rho]],
\[Alpha] ==\[Infinity],-Log[base,Max@\[Rho]],
True,(
1/(1-\[Alpha]) Log[base,Sum[(\[Rho][[i]])^\[Alpha],{i,1,Length@\[Rho]}]])]//Chop
]



(* ::Input::Initialization:: *)
(* D(\[Rho]||\[Sigma]) *)
Clear[KullbackLeibler];
KullbackLeibler[\[Rho]_?MatrixQ,\[Sigma]_?MatrixQ]:=Module[{S1,S2,\[Lambda],Q,log},

S1 = vonNeumann[\[Rho]];
{\[Lambda],Q} = Eigensystem[\[Sigma]];
Q = Q\[Transpose]; 
log = DiagonalMatrix@Log[\[Lambda]];
S2 = - Tr[Q\[ConjugateTranspose] . \[Rho] . Q . log];
-S1+S2//Chop
]

KullbackLeibler[p_?VectorQ,q_?VectorQ]:=Total@Table[If[Abs[p[[i]]]<10^-12,0,p[[i]] Log[p[[i]]/q[[i]]]],{i,Length@p}]


(* ::Input::Initialization:: *)
Clear[RelativeEntropy];
RelativeEntropy[\[Rho]_,\[Sigma]_]:=KullbackLeibler[\[Rho],\[Sigma]]


(* ::Input::Initialization:: *)
(* Subscript[D, \[Alpha]](\[Rho]||\[Sigma]) *)
Clear[RenyiDivergence];
RenyiDivergence[\[Rho]_?MatrixQ,\[Sigma]_?MatrixQ,\[Alpha]_]:=Module[{S1,S2,\[Lambda],Q,log,m1},

If[Abs[\[Alpha]-1]<10^-12,KullbackLeibler[\[Rho],\[Sigma]],
m1 = MatrixPower[\[Sigma],(1-\[Alpha])/(2\[Alpha])];
-(1/(1-\[Alpha]))Log@Tr[MatrixPower[m1 . \[Rho] . m1,\[Alpha]]]]//Chop
]



(* ::Input::Initialization:: *)
Clear[MutualInformation];
MutualInformation[\[Rho]_,{A_,B_},locdimlist_]:=Module[{\[Rho]A,\[Rho]B,\[Rho]AB,n},
n= Length@locdimlist;(* Number of sub-systems in this case *)
\[Rho]A = PTr[\[Rho],Complement[Range[n],Flatten@{A}],locdimlist];
\[Rho]B = PTr[\[Rho],Complement[Range[n],Flatten@{B}],locdimlist];
\[Rho]AB = PTr[\[Rho],Complement[Range[n],Flatten@Join[Flatten@{A},Flatten@{B}]],locdimlist];
Chop[vonNeumann[\[Rho]A]+vonNeumann[\[Rho]B]-vonNeumann[\[Rho]AB],10^-12]
];

(* When all subsystems have different dimensions *)
MutualInformation[\[Rho]_,{A_,B_},locdim_?NumberQ]:= MutualInformation[\[Rho],{A,B},ConstantArray[locdim,Log[locdim, Length@\[Rho]]]]

(* When all subsystems are qubits *)
MutualInformation[\[Rho]_,{A_,B_}]:= MutualInformation[\[Rho],{A,B},ConstantArray[2,Log[2, Length@\[Rho]]]]


(* ::Input::Initialization:: *)
Concurrence[\[Rho]_]:=Module[{\[Sigma]y,\[Rho]t,\[Rho]sq,R,eigs},
\[Sigma]y = {{0,-I},{I,0}};
\[Rho]t = kron[\[Sigma]y,\[Sigma]y] . \[Rho]\[Conjugate] . kron[\[Sigma]y,\[Sigma]y];
\[Rho]sq = MatrixPower[\[Rho],1/2];
R = MatrixPower[\[Rho]sq . \[Rho]t . \[Rho]sq,1/2];
eigs = Chop@Reverse@Sort@Eigenvalues[R];
Max[0,Re[eigs[[1]]-eigs[[2]]-eigs[[3]]-eigs[[4]]]]
];


(* ::Input::Initialization:: *)
EntanglementOfFormation[\[Rho]_,b_:2]:=Module[{c,h},
h[x_]:=If[(x==0)||(x==1),0,-x Log[b,x]-(1-x)Log[b,1-x]];
c = Concurrence[\[Rho]];
h[(1+Sqrt[1-c^2])/2]
]



(* ::Input::Initialization:: *)
Clear[QuantumFidelity];
QuantumFidelity[\[Rho]_,\[Sigma]_]:=Tr[MatrixPower[MatrixPower[\[Rho],1/2] . \[Sigma] . MatrixPower[\[Rho],1/2],1/2]]^2


(* ::Input::Initialization:: *)
Clear[RelativeEntropyofCoherence];
RelativeEntropyofCoherence[\[Rho]_,X_]:=Module[{v,V,\[CapitalDelta]\[Rho]},
V = Normalize/@Eigenvectors[X];
\[CapitalDelta]\[Rho] = Total@Table[out[v,v] . \[Rho] . out[v,v],{v,V}];
Chop[vonNeumann[\[CapitalDelta]\[Rho]]-vonNeumann[\[Rho]],10^-12]
];


(* ::Input::Initialization:: *)
Clear[TraceDistance]
TraceDistance[\[Rho]_,\[Sigma]_]:=With[{sings = SingularValueList[\[Rho]-\[Sigma]]}, 1/2 Total@sings]


(* ::Input::Initialization:: *)
(* Based on https://pennylane.ai/qml/demos/tutorial_haar_measure *)
Clear[HaarMeasure];
HaarMeasure[d_]:=Module[{a,b,Z,Q,R,\[CapitalLambda]},
a = RandomVariate[NormalDistribution[],{d,d}];
b = RandomVariate[NormalDistribution[],{d,d}];
Z = a + I b; 
{Q,R} = QRDecomposition[Z];
\[CapitalLambda] = DiagonalMatrix@Table[r/Abs[r],{r,Diagonal@R}];
Q . \[CapitalLambda]
]


(* ::Input::Initialization:: *)
(* MatrixPower but with A^0=identity, even if A is singular *)
matrixpower[A_,n_]:=If[n==0,Eye[Length@A],MatrixPower[A,n]]
matrixpower[A_,n_,y_]:=If[n==0,y,MatrixPower[A,n,y]]


(* ::Input::Initialization:: *)
Clear[WorkMoments];
WorkMoments[nn_,y_,Hi_,Hf_]:=Module[{n,Y,result},
result=Which[
y[[1]]==="thermal",
Y = MatrixExp[-y[[2]] Hi];
Y = Y/Tr[Y];

Table[Sum[(-1)^(n-k) Binomial[n,k] Tr[matrixpower[Hf,k] . matrixpower[Hi,n-k] . Y],{k,0,n}],{n,Flatten[{nn}]}],

y[[1]]=="GS",
Y = GroundState[Hi];
Re@Table[Sum[(-1)^(n-k) Binomial[n,k] Conjugate[matrixpower[Hf,k,Y]] . matrixpower[Hi,n-k,Y],{k,0,n}],{n,Flatten[{nn}]}],

y[[1]]=="eigenstate",
Y = GroundState[Hi,y[[2]]];
Re@Table[Sum[(-1)^(n-k) Binomial[n,k] Conjugate[matrixpower[Hf,k,Y]] . matrixpower[Hi,n-k,Y],{k,0,n}],{n,Flatten[{nn}]}],

Length@Dimensions@y==2,
Table[
Sum[(-1)^(n-k) Binomial[n,k] Tr[matrixpower[Hf,k] . matrixpower[Hi,n-k] . y],{k,0,n}],{n,Flatten[{nn}]}],

True,Table[Sum[(-1)^(n-k) Binomial[n,k] Conjugate[matrixpower[Hf,k,y]] . matrixpower[Hi,n-k,y],{k,0,n}],{n,Flatten[{nn}]}]
]//Chop;
If[Head[nn]===List,result,First@result]
]
WorkMoments[n_,y_,Hi_,Hf_,U_]:=WorkMoments[n,y,Hi,U\[ConjugateTranspose] . Hf . U]



(* ::Input::Initialization:: *)
getCumulants[moms_]:=Module[{nmoms = Length@moms,rep,n},
rep = Thread[Table[Moment[j],{j,nmoms}]->moms];
Table[MomentConvert[Cumulant[n],Moment]/.rep,{n,1,nmoms}]]


(* ::Input::Initialization:: *)
ProbMerger[x_,P_,tol_:10^-11]:=List@@@Normal[GroupBy[Table[{N[Round[x[[i]],tol]],P[[i]]},{i,1,Length[x]}],First-> Last,Total]]


(* ::Input::Initialization:: *)
(* Full work distribution *)
Clear[WorkDistribution];
WorkDistribution[Hi_,Hf_,\[Rho]0type_,y_,U_:1,mergetol_:10^-11]:=Module[{ord,i,Ei,Vi,Ef,Vf,\[ScriptCapitalM],\[ScriptCapitalQ],d = Length@Hi,pi,works,probs},
{Ei,Vi} =Eigsys[Hi]; 
{Ef,Vf} =If[U===1,Eigsys[Hf],Eigsys[U\[ConjugateTranspose] . Hf . U]];
\[ScriptCapitalQ] = Abs[Vf\[ConjugateTranspose] . Vi]^2 (* The matrix |\[LeftAngleBracket]j|U|i\[RightAngleBracket]|^2 *);

(* Initial probabilities *)
Which[
(* ground-state *)
\[Rho]0type =="GS",
pi=IdentityMatrix[d][[1]],

(* Thermal: in this case y = \[Beta] = 1/T *)
\[Rho]0type=="thermal",
(pi = Table[Exp[-y(Ei[[i]]-Ei[[1]])],{i,1,d}];
pi = pi/Total@pi;
),

(* Eigenstate of Subscript[H, i]. In this case y labels the eigenstate, with y = 1 being the GS *)
\[Rho]0type =="eigenstate",
pi = IdentityMatrix[d][[y]],

(* Infinite temperature state *)
\[Rho]0type =="identity",
pi = ConstantArray[1/d,{d}],

(* Generic. In this case y is the initial density matrix *)
\[Rho]0type=="generic",
pi = Table[Vi[[All,i]]\[Conjugate] . y . Vi[[All,i]],{i,d}]
];

works = Flatten@Table[ef-ei,{ei,Ei},{ef,Ef}];
probs = Flatten@Table[\[ScriptCapitalQ][[j,i]] pi[[i]],{i,d},{j,d}];
ord = Ordering[works];

Select[ProbMerger[works[[ord]],probs[[ord]],mergetol],Abs[#[[2]]]>10^-10&]
]

(*WorkDistribution[Hi_,Hf_,\[Rho]0type_,y_,U_]:=WorkDistribution[Hi,U\[ConjugateTranspose].Hf.U,\[Rho]0type,y]*)


(* ::Input::Initialization:: *)
(* Given probabilities and energies, yields the points (x,y) of a thermo-majorization curve *)
ThermoMajorizationCurve[pps_,Es_,\[Beta]_]:=Module[{ord,x,y,ps},
ps = pps/Total[pps];
ord=Reverse@Ordering[ps Exp[\[Beta] Es]];
y=Prepend[Accumulate[ps[[ord]]],0];
x = Prepend[Accumulate[Exp[-\[Beta] Es][[ord]]],0]//N;
Transpose[{x,y}]
]


(* ::Input::Initialization:: *)
Ergotropy[H_,\[Rho]_]:=Module[{P,\[ScriptCapitalE],psiRho,psiH},
{P,psiRho}=Eigensystem[N@\[Rho]];
{\[ScriptCapitalE],psiH}=Eigensystem[1000 NEye[Length@H]-H];
\[ScriptCapitalE] = 1000 - \[ScriptCapitalE];
Sum[P[[i]] \[ScriptCapitalE][[j]](Abs[psiH[[j]]\[Conjugate] . psiRho[[i]]]^2-KroneckerDelta[i,j]),{i,Length@\[Rho]},{j,Length@H}]
]


(* ::Input::Initialization:: *)
(* Determines if y = density matrix or if y = ket *)
(* For numerics use "eigen" *)
Clear[QuantumFisherInformation];
QuantumFisherInformation[y_,dy_]:=Module[{},
If[Length@Dimensions@y===2,
2Vec[dy\[Transpose]] . LinearSolve[kron[y\[Transpose],Eye[Length@y]]+kron[Eye[Length@y],y],Vec[dy]]//Chop,
4 (dy\[Conjugate] . dy + (dy\[Conjugate] . y)^2)//Chop
]
]

QuantumFisherInformation[\[Rho]_,d\[Rho]_,"pseudo"]:=2Vec[d\[Rho]\[Transpose]] . PseudoInverse[kron[\[Rho]\[Transpose],Eye[\[Rho]]]+kron[Eye[\[Rho]],\[Rho]]] . Vec[d\[Rho]]//Chop

QuantumFisherInformation[\[Rho]_,d\[Rho]_,"eigen"]:=Module[{p,\[Psi],F},
{p,\[Psi]} = Eigensystem[\[Rho]];
(*\[CapitalLambda] =2 Sum[If[p[[i]]+p[[j]]<10^-13,0,1/(p[[i]]+p[[j]])out[\[Psi][[i]],\[Psi][[i]]].d\[Rho].out[\[Psi][[j]],\[Psi][[j]]]],{i,Length@\[Rho]},{j,Length@\[Rho]}]*)
F = 2 Sum[If[Re[p[[i]]+p[[j]]]<10^-13,0,1/(p[[i]]+p[[j]]) Abs[\[Psi][[i]]\[Conjugate] . d\[Rho] . \[Psi][[j]]]^2],{i,Length@\[Rho]},{j,Length@\[Rho]}]//Chop
]


(* ::Input::Initialization:: *)
SymmetricLogarithmicDerivative[\[Rho]_,d\[Rho]_]:=Module[{n,A,b},
n = Length@\[Rho];
A = kron[\[Rho]\[Transpose],Eye[n]] + kron[Eye[n],\[Rho]];
b = 2 Vec[d\[Rho]];
LinearSolve[A,b]//Unvec
]


(* ::Input::Initialization:: *)
Clear[GammelmarkMolmerMFisher];
GammelmarkMolmerMFisher[\[Rho]_,\[ScriptCapitalL]_, H_,Hp_,cops_,copsprime_]:=Module[{op1,\[DoubleStruckCapitalI],op2,\[ScriptCapitalL]L,\[ScriptCapitalL]R,\[ScriptCapitalL]inv,outie},
op1 = -I Hp - 1/2 Sum[copsprime[[k]]\[ConjugateTranspose] . cops[[k]] + cops[[k]]\[ConjugateTranspose] . copsprime[[k]],{k,Length@cops}];
op2 = I Hp - 1/2 Sum[copsprime[[k]]\[ConjugateTranspose] . cops[[k]] + cops[[k]]\[ConjugateTranspose] . copsprime[[k]],{k,Length@cops}];
\[DoubleStruckCapitalI] = Eye[Length@H];
\[ScriptCapitalL]L=kron[\[DoubleStruckCapitalI], op1] + Sum[kron[cops[[k]]\[Conjugate],copsprime[[k]]],{k,Length@cops}];
\[ScriptCapitalL]R=kron[op2\[Transpose],\[DoubleStruckCapitalI]] + Sum[kron[copsprime[[k]]\[Conjugate],cops[[k]]],{k,Length@cops}];

(*outie = Eye[Length@\[ScriptCapitalL]]  - out[Vec[\[Rho]], Vec[Eye[Length@\[Rho]]]];
\[ScriptCapitalL]inv = outie.PseudoInverse[\[ScriptCapitalL]].outie;
4Re@(Sum[Tr[c.\[Rho].c\[ConjugateTranspose]],{c,copsprime}]- UnTr[\[ScriptCapitalL]L.\[ScriptCapitalL]inv.\[ScriptCapitalL]R.Vec[\[Rho]]]-UnTr[\[ScriptCapitalL]R.\[ScriptCapitalL]inv.\[ScriptCapitalL]L.Vec[\[Rho]]])*)
4Re@(Sum[Tr[c . \[Rho] . c\[ConjugateTranspose]],{c,copsprime}]- UnTr[\[ScriptCapitalL]L . DrazinApply2[\[ScriptCapitalL],Vec[\[Rho]],\[ScriptCapitalL]R . Vec[\[Rho]]]]-UnTr[\[ScriptCapitalL]R . DrazinApply2[\[ScriptCapitalL],Vec[\[Rho]],\[ScriptCapitalL]L . Vec[\[Rho]]]])
]


(* ::Input::Initialization:: *)
Clear[SequentialMaxLikelihood];
SequentialMaxLikelihood[loglike_,outcomes_,\[Theta]grid_,outputstep_:1]:=Module[{ll,posML,Lmax,\[Theta]max},
ll = Accumulate@Table[loglike[x,\[Theta]],{x,outcomes},{\[Theta],\[Theta]grid}];
posML = First@Ordering[#,-1]&/@ll;
(*Lmax=Max/@ll;*)
\[Theta]max = \[Theta]grid[[posML]];
\[Theta]max[[1;;-1;;outputstep]]
]


(* ::Input::Initialization:: *)
Clear[MeanSquaredError];
MeanSquaredError[\[Theta]est_?MatrixQ,\[Theta]real_]:=Mean/@Transpose[(\[Theta]est-\[Theta]real)^2]
MeanSquaredError[\[Theta]est_?VectorQ,\[Theta]real_]:=MeanSquaredError[{\[Theta]est},\[Theta]real]


(* ::Input::Initialization:: *)
Clear[EmpiricalDistributionFisherMatrix];
EmpiricalDistributionFisherMatrix[p_,\[ScriptCapitalC]_,Nmax_:100,L_:1]:=Module[{d = Length@p,\[DoubleStruckCapitalP],\[CapitalPsi]},
\[DoubleStruckCapitalP] = DiagonalMatrix@p;
\[CapitalPsi] = Table[
Total@Table[(1-k/(Nmax+1-L))(\[ScriptCapitalC][x,y,k]-p[[x]]),{k,1,Nmax-L}],{x,1,d},{y,1,d}
];
\[DoubleStruckCapitalP] + \[CapitalPsi] . \[DoubleStruckCapitalP] + \[DoubleStruckCapitalP] . \[CapitalPsi]\[Transpose]
]


(* ::Input::Initialization:: *)
Clear[AmplitudeDampingKrausOperators];
AmplitudeDampingKrausOperators[f_,\[Gamma]_]:=Module[{M},
M[0] = Sqrt[f]({
 {1, 0},
 {0, Sqrt[1-\[Gamma]]}
});
M[1] = Sqrt[f]({
 {0, Sqrt[\[Gamma]]},
 {0, 0}
});
M[2] = Sqrt[1-f]({
 {Sqrt[1-\[Gamma]], 0},
 {0, 1}
});
M[3] = Sqrt[1-f]({
 {0, 0},
 {Sqrt[\[Gamma]], 0}
});
{M[0],M[1],M[2],M[3]}

]


(* ::Input::Initialization:: *)
Clear[AmplitudeDamping];
AmplitudeDamping[f_,\[Gamma]_][\[Rho]_]:=Module[{M = AmplitudeDampingKrausOperators[f,\[Gamma]]},Total@Table[M[[i]] . \[Rho] . M[[i]]\[Transpose],{i,Length@M}]]

AmplitudeDamping[f_,\[Gamma]_,qubit_][\[Rho]_]:=Module[{M = AmplitudeDampingKrausOperators[f,\[Gamma]]},
Total@Table[KronEye[M[[i]],Log2[Length@\[Rho]],qubit] . \[Rho] . KronEye[M[[i]],Log2[Length@\[Rho]],qubit]\[Transpose],{i,Length@M}]

]


(* ::Input::Initialization:: *)
Clear[SWAP]
SWAP[a_,b_,L_]:=Module[{\[DoubleStruckCapitalI],\[Sigma]x,\[Sigma]y,\[Sigma]z},

\[DoubleStruckCapitalI] = Eye[2^L];
\[Sigma]x = {{0,1},{1,0}};
\[Sigma]y = {{0,-I},{I,0}};
\[Sigma]z = {{1,0},{0,-1}};

1/2 (\[DoubleStruckCapitalI] + KronEye[\[Sigma]x,L,a] . KronEye[\[Sigma]x,L,b]+ KronEye[\[Sigma]y,L,a] . KronEye[\[Sigma]y,L,b]+ KronEye[\[Sigma]z,L,a] . KronEye[\[Sigma]z,L,b])
]

SWAP[]:=SWAP[1,2,2];

(*SWAP[a_,b_,L_,\[Eta]_]:=Cos[\[Eta]] Eye[2^L] + \[ImaginaryI] Sin[\[Eta]] SWAP[a,b,L]*)


(* ::Input::Initialization:: *)
Clear[PartialSWAP]
(*PartialSWAP[s_,a_,b_,L_]:=( -\[ImaginaryI] Sqrt[1-s^2] Eye[2^L] +s SWAP[a,b,L])*)
PartialSWAP[\[Eta]_,a_,b_,L_]:=(  Cos[\[Eta]] Eye[2^L] -I Sin[\[Eta]] SWAP[a,b,L])
PartialSWAP[\[Eta]_] := PartialSWAP[\[Eta],1,2,2] 


(* ::Input::Initialization:: *)
Clear[RealPartialSWAP];
RealPartialSWAP[s_,a_,b_,L_]:=Module[{\[ScriptCapitalX],\[Sigma]p,\[Sigma]m},
\[Sigma]p = {{0,1},{0,0}};
\[Sigma]m = {{0,0},{1,0}};
\[ScriptCapitalX] = KronEye[\[Sigma]p,L,a] . KronEye[\[Sigma]m,L,b]-KronEye[\[Sigma]m,L,a] . KronEye[\[Sigma]p,L,b];
Eye[2^L] + s \[ScriptCapitalX] +(1-Sqrt[1-s^2])\[ScriptCapitalX] . \[ScriptCapitalX]
]
RealPartialSWAP[s_]:=RealPartialSWAP[s,1,2,2]


(* ::Input::Initialization:: *)
Clear[CNOT]
CNOT[a_,b_,L_]:=Module[{\[Sigma]0,\[Sigma]x,\[Sigma]p,\[Sigma]m},

\[Sigma]0 = {{1,0},{0,1}};
\[Sigma]x = {{0,1},{1,0}};
\[Sigma]p = {{0,1},{0,0}};
\[Sigma]m = {{0,0},{1,0}};

(* Partial SWAP *)
KronEye[\[Sigma]p . \[Sigma]m,L,a] . KronEye[\[Sigma]0,L,b]+ KronEye[\[Sigma]m . \[Sigma]p,L,a] . KronEye[\[Sigma]x,L,b]
]

(*CNOT[] := Normal@CNOT[1,2,2];*)
CNOT[]:=\!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"1", "0", "0", "0"},
{"0", "1", "0", "0"},
{"0", "0", "0", "1"},
{"0", "0", "1", "0"}
},
GridBoxAlignment->{"Columns" -> {{Center}}, "Rows" -> {{Baseline}}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\);

CNOT::usage = "CNOT[] calls the standard 4x4 CNOT gate. 

CNOT[a,b,L] loads a CNOT gate in a space of L qubits, with a (=1,...,L) being the control qubit and b (=1,...,L) the target qubit. 

CNOT[1,2,2] is equivalent to CNOT[].";


(* ::Input::Initialization:: *)
Clear[Hadamard]
Hadamard[]:=1/Sqrt[2] ({
 {1, 1},
 {1, -1}
});
Hadamard[i_,\[ScriptCapitalN]_]:=kron[Eye[2^(i-1)],\!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{
FractionBox["1", 
SqrtBox["2"]], 
FractionBox["1", 
SqrtBox["2"]]},
{
FractionBox["1", 
SqrtBox["2"]], 
RowBox[{"-", 
FractionBox["1", 
SqrtBox["2"]]}]}
},
GridBoxAlignment->{"Columns" -> {{Center}}, "Rows" -> {{Baseline}}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\),Eye[2^(\[ScriptCapitalN]-i)]]
Hadamard::usage = "Hadamard[] calls the 2x2 Hadamard matrix. 

Hadamard[i,\[ScriptCapitalN]] is a Hadamard gate on qubit i, in a space of \[ScriptCapitalN] qubits";


(* ::Input::Initialization:: *)
Clear[Toffoli]
Toffoli[a_,b_,c_,L_]:=Module[{\[Sigma]0,\[Sigma]x,\[Sigma]p,\[Sigma]m},

\[Sigma]0 = {{1,0},{0,1}};
\[Sigma]x = {{0,1},{1,0}};
\[Sigma]p = {{0,1},{0,0}};
\[Sigma]m = {{0,0},{1,0}};

(* Partial SWAP *)
KronEye[\[Sigma]p . \[Sigma]m,L,a] . KronEye[\[Sigma]m . \[Sigma]p,L,b] . KronEye[\[Sigma]0,L,c]+KronEye[\[Sigma]m . \[Sigma]p,L,a] . KronEye[\[Sigma]p . \[Sigma]m,L,b] . KronEye[\[Sigma]0,L,c]+KronEye[\[Sigma]p . \[Sigma]m,L,a] . KronEye[\[Sigma]p . \[Sigma]m,L,b] . KronEye[\[Sigma]0,L,c]+ KronEye[\[Sigma]m . \[Sigma]p,L,a] . KronEye[\[Sigma]m . \[Sigma]p,L,b] . KronEye[\[Sigma]x,L,c]
]


(* ::Input::Initialization:: *)
(* Dephases A in the eigenbasis of X *)
Clear[FullDephasingMap]
FullDephasingMap[A_,X_,degeneracy_:False]:=Module[{\[Lambda],v,kd},

{\[Lambda],v}=Eigsys[X];
v=v\[Transpose];
kd[a_,b_,tol_:10^-10] := If[Abs[a-b]<tol,1,0];
If[degeneracy===False,
Total@Table[(v[[i]]\[Conjugate] . A . v[[i]]) out[v[[i]],v[[i]]],{i,Length@v}],
Total@Flatten[Table[(v[[i]]\[Conjugate] . A . v[[j]]) out[v[[i]],v[[j]]] kd[\[Lambda][[i]],\[Lambda][[j]]],{i,Length@\[Lambda]},{j,Length@\[Lambda]}],1]]
]


(* ::Input::Initialization:: *)
(* Not vectorized *)
Clear[LindbladDissipator]
LindbladDissipator[A_,\[Rho]_]:=A . \[Rho] . A\[ConjugateTranspose]-1/2 (A\[ConjugateTranspose] . A . \[Rho]+\[Rho] . A\[ConjugateTranspose] . A);
LindbladDissipator[A_,B_,\[Rho]_]:=A . \[Rho] . B-1/2 (B . A . \[Rho]+\[Rho] . B . A);


(* ::Input::Initialization:: *)
Clear[AdjointDissipator];
AdjointDissipator[\[ScriptCapitalO]_,L_]:=L\[ConjugateTranspose] . \[ScriptCapitalO] . L-1/2 (L\[ConjugateTranspose] . L . \[ScriptCapitalO]+\[ScriptCapitalO] . L\[ConjugateTranspose] . L)
AdjointDissipator[\[ScriptCapitalO]_,Ls_,\[Gamma]s_]:=Sum[\[Gamma]s[[i]] AdjointDissipator[\[ScriptCapitalO],Ls[[i]]],{i,Length@Ls}]


(* ::Input::Initialization:: *)
Vec[X_]:=Flatten[X\[Transpose]];
Unvec[x_]:=With[{d = Sqrt[Length@x]},Partition[x,d]\[Transpose]];
UnTr[X_]:=Tr@Unvec@X


(* ::Input::Initialization:: *)
Clear[UnitaryToVec,LindbladToVec,AdjointToVec];

UnitaryToVec[H_]:=With[{\[ScriptCapitalI] = Eye[Length@H]},-I (kron[\[ScriptCapitalI],H]- kron[H\[Transpose],\[ScriptCapitalI]])]

LindbladToVec[L_]:=With[{\[ScriptCapitalI] = Eye[Length@L]},kron[Conjugate[L],L]-1/2 kron[(L\[ConjugateTranspose] . L)\[Transpose],\[ScriptCapitalI]]-1/2 kron[\[ScriptCapitalI],L\[ConjugateTranspose] . L]]

AdjointToVec[L_]:=With[{\[ScriptCapitalI]=Eye[Length[L]]},kron[L\[Transpose],L\[ConjugateTranspose]]-1/2 kron[Transpose[ConjugateTranspose[L] . L],\[ScriptCapitalI]]-1/2 kron[\[ScriptCapitalI],ConjugateTranspose[L] . L]]


(* ::Input::Initialization:: *)
Clear[Liouvillian];
Liouvillian[H_,cops_]:=Module[{c},
If[Length[H]!=Length[cops[[1]]],0,UnitaryToVec[H]]+ 
If[Length@Dimensions@cops===3,
Sum[LindbladToVec[c],{c,cops}],
LindbladToVec[cops]
]]

Liouvillian[H_,cops_,rates_]:=Module[{c},
If[Length[H]!=Length[cops[[1]]],0,
UnitaryToVec[H]] +
If[Length@Dimensions@cops===3,
Sum[rates[[i]] LindbladToVec[cops[[i]]],{i,Length@cops}],
rates LindbladToVec[cops]
]
 ]


(* ::Input::Initialization:: *)
Clear[EffectiveNonHermitianHamiltonian];
EffectiveNonHermitianHamiltonian[H_,cops_]:=Module[{c},
H -I/2 Sum[c\[ConjugateTranspose] . c,{c,cops}]]

EffectiveNonHermitianHamiltonian[H_,cops_,rates_]:=Module[{c},
H -I/2 Sum[rates[[i]] cops[[i]]\[ConjugateTranspose] . cops[[i]],{i,Length@cops}]]


(* ::Input::Initialization:: *)
(* Orders a d^2 list such that the first d elements correspond to the diagonals and the last d^2-d to the off diagonals *)
Clear[VecDiagsOrdering];
VecDiagsOrdering[d_]:=Module[{diags=Table[(d+1)i - d,{i,1,d}]},
Join[diags,Complement[Range[1,d^2],diags]]];


(* ::Input::Initialization:: *)
Clear[PerturbedLiouvillianPopBlock];
PerturbedLiouvillianPopBlock[\[ScriptCapitalL]_]:=Module[{\[ScriptCapitalL]2,\[ScriptCapitalL]pop,\[ScriptCapitalL]pop2},
\[ScriptCapitalL]2=\[ScriptCapitalL][[ord,ord]];
\[ScriptCapitalL]pop = \[ScriptCapitalL]2[[1;;4,1;;4]];
\[ScriptCapitalL]pop2=\[ScriptCapitalL]pop - DiagonalMatrix@Diagonal@\[ScriptCapitalL]pop//Simplify;
\[ScriptCapitalL]pop2[[oo,oo]]
]


(* ::Input::Initialization:: *)
(* Eq. (A59) of Kacper's https://arxiv.org/pdf/2212.03835 *)
(* Computes (\[ScriptCapitalP].\[ScriptCapitalV].\[ScriptCapitalQ].DrazinInverse[\[ScriptCapitalL]0].\[ScriptCapitalQ].\[ScriptCapitalV].\[ScriptCapitalP]) *)
Clear[PerturbedLiouvillian]
PerturbedLiouvillian[\[ScriptCapitalL]0_,\[ScriptCapitalV]_,exact_:False]:=Module[{d,\[ScriptCapitalP],vs,v,func,res,\[ScriptCapitalQ],tmp,\[ScriptCapitalO]},
d = Sqrt[Length@\[ScriptCapitalL]0];
vs=VecDiagsOrdering[d];
\[ScriptCapitalQ] = Sum[Proj[d^2,v,v],{v,Drop[vs,d]}];
\[ScriptCapitalP] = Eye[\[ScriptCapitalQ]]-\[ScriptCapitalQ];
tmp = \[ScriptCapitalQ] . \[ScriptCapitalV] . \[ScriptCapitalP];
\[ScriptCapitalO] = If[exact===False,\[ScriptCapitalQ] . \[ScriptCapitalL]0 . \[ScriptCapitalQ],\[ScriptCapitalQ] . (\[ScriptCapitalL]0+\[ScriptCapitalV]) . \[ScriptCapitalQ]];
(-\[ScriptCapitalP] . \[ScriptCapitalV] . \[ScriptCapitalQ] . Table[LinearSolve[\[ScriptCapitalO],tmp[[All,i]]],{i,Length@tmp}]\[Transpose])[[vs[[1;;d]],vs[[1;;d]]]]
]

PerturbedLiouvillian[\[ScriptCapitalL]0_,\[ScriptCapitalV]_,\[ScriptCapitalP]_,\[ScriptCapitalQ]_,exact_:False]:=Module[{d,vs,v,func,res,tmp,\[ScriptCapitalO]},
d = Sqrt[Length@\[ScriptCapitalL]0];
vs=VecDiagsOrdering[d];
tmp = \[ScriptCapitalQ] . \[ScriptCapitalV] . \[ScriptCapitalP];
\[ScriptCapitalO] = If[exact===False,\[ScriptCapitalQ] . \[ScriptCapitalL]0 . \[ScriptCapitalQ],\[ScriptCapitalQ] . (\[ScriptCapitalL]0+\[ScriptCapitalV]) . \[ScriptCapitalQ]];
(-\[ScriptCapitalP] . \[ScriptCapitalV] . \[ScriptCapitalQ] . Table[LinearSolve[\[ScriptCapitalO],tmp[[All,i]]],{i,Length@tmp}]\[Transpose])[[vs[[1;;d]],vs[[1;;d]]]]
]

(*Clear[PerturbedLiouvillianExact];
PerturbedLiouvillianExact[\[ScriptCapitalL]0_,\[ScriptCapitalV]_]:=Module[{d,\[ScriptCapitalP],vs,v,func,res,\[ScriptCapitalQ],tmp},
d = Sqrt[Length@\[ScriptCapitalL]0];
vs=VecDiagsOrdering[d];
\[ScriptCapitalQ] = Sum[Proj[d^2,v,v],{v,Drop[vs,d]}];
\[ScriptCapitalP] = Eye[\[ScriptCapitalQ]]-\[ScriptCapitalQ];
tmp = \[ScriptCapitalQ].\[ScriptCapitalV].\[ScriptCapitalP];
(-\[ScriptCapitalP].\[ScriptCapitalV].\[ScriptCapitalQ].Table[LinearSolve[\[ScriptCapitalQ].(\[ScriptCapitalL]0+\[ScriptCapitalV]).\[ScriptCapitalQ],tmp[[All,i]]],{i,Length@tmp}]\[Transpose])[[vs[[1;;d]],vs[[1;;d]]]]
]*)


(* ::Input::Initialization:: *)
Clear[PerturbedLiouvillianContributionFromCoherences]
PerturbedLiouvillianContributionFromCoherences[\[ScriptCapitalL]_,exact_:True]:=Module[{\[ScriptCapitalL]0,\[ScriptCapitalV],d,ord,pop,coh,\[ScriptCapitalQ],\[ScriptCapitalP],\[ScriptCapitalL]eff},
d = Sqrt[Length@\[ScriptCapitalL]];
ord=VecDiagsOrdering[d];
pop = ord[[1;;d]];
coh = ord[[d+1;;d^2]];
\[ScriptCapitalQ] = Sum[Proj[d^2,v,v],{v,Drop[ord,d]}];
\[ScriptCapitalP] = Eye[\[ScriptCapitalQ]]-\[ScriptCapitalQ];
\[ScriptCapitalL]0 = \[ScriptCapitalP] . \[ScriptCapitalL] . \[ScriptCapitalP];
\[ScriptCapitalV] = \[ScriptCapitalL]-\[ScriptCapitalL]0//Simplify;
\[ScriptCapitalL]eff=PerturbedLiouvillian[\[ScriptCapitalL]0,\[ScriptCapitalV],exact];
\[ScriptCapitalL]eff-DiagonalMatrix@Diagonal@\[ScriptCapitalL]eff//Simplify
]


(* ::Input::Initialization:: *)
Clear[mesolve];
mesolve[\[ScriptCapitalL]_,\[Rho]0_,tf_,quiet_:False]:=Module[{eqs,\[Rho],time,sol},
Clear[t];
eqs = {
\[Rho]'[t]==\[ScriptCapitalL] . \[Rho][t],
\[Rho][0]==Normal@Vec[\[Rho]0]};

If[quiet===False,
(Monitor[
sol=NDSolveValue[eqs,\[Rho],{t,0,tf},
StepMonitor:>(time=t)],
If[NumberQ[time],ProgressIndicator[time/tf],""]]
),(
sol=NDSolveValue[eqs,\[Rho],{t,0,tf}])
];
Function[t,Unvec[sol[t]]]

]


(* ::Input::Initialization:: *)
(* Only meant for numerics *)
Clear[SteadyState];
SteadyState[A_]:=Module[{\[Rho],x,numeric},

numeric= AllTrue[Flatten@Normal@A,NumberQ];
If[numeric===False, AnalyticalSteadyState[A],
(x=SparseArray@First@Eigenvectors[A,-1];
\[Rho] = Unvec[x] ;
\[Rho] = (\[Rho]+\[Rho]\[HermitianConjugate]);
\[Rho] = \[Rho]/Tr[\[Rho]]//Chop
)]
];

SteadyState[A_,\[DoubleStruckCapitalI]_]:=AnalyticalSteadyState[A,\[DoubleStruckCapitalI]]


(* ::Input::Initialization:: *)
Clear[AnalyticalSteadyState];
AnalyticalSteadyState[\[ScriptCapitalL]_]:=Module[{\[ScriptCapitalL]2,d,\[Rho]},
d = Length@\[ScriptCapitalL];
(*\[ScriptCapitalL]2 = Join[\[ScriptCapitalL],{ConstantArray[1,d]}];*)
\[ScriptCapitalL]2 = Normal@Join[\[ScriptCapitalL],{Vec@Eye[Sqrt[d]]}];
\[Rho] = Unvec@LinearSolve[\[ScriptCapitalL]2,Eye[d+1][[-1]]];
\[Rho]
]

(* Specify the vectorized identity matrix \[DoubleStruckCapitalI]. Output in this case is not unvectorized. *)
AnalyticalSteadyState[\[ScriptCapitalL]_,\[DoubleStruckCapitalI]\[DoubleStruckCapitalI]_]:=Module[{\[ScriptCapitalL]2,d,\[DoubleStruckCapitalI]},
d = Length@\[ScriptCapitalL];
\[DoubleStruckCapitalI]= If[Head[\[DoubleStruckCapitalI]\[DoubleStruckCapitalI]]===String,ConstantArray[1,{d}],\[DoubleStruckCapitalI]\[DoubleStruckCapitalI]];
\[ScriptCapitalL]2 = Normal@Join[\[ScriptCapitalL],Normal@{\[DoubleStruckCapitalI]}];
LinearSolve[\[ScriptCapitalL]2,Eye[d+1][[-1]]]
]


(* ::Input::Initialization:: *)
(* Kind of buggy: use with care *)
Clear[AnalyticalSteadyStateSequential]
AnalyticalSteadyStateSequential[\[ScriptCapitalL]_]:=Module[{B,nn,x,i,p,ph,phh,\[Rho],tr},
Clear[B];
B = Normal@\[ScriptCapitalL];
nn=Length@\[ScriptCapitalL];
Do[
Do[
B[[i]] = Together[B[[i]]-B[[j]]B[[i,j]]/B[[j,j]]]
,{i,j+1,nn}];
PrintTemporary[j];
(*Print[Normal@B\[LeftDoubleBracket]j+1\[RightDoubleBracket]];*)
,{j,1,nn}];
x=ConstantArray[0,nn];
x[[nn]]=1;
Do[
x[[i]]=-Together@Total@Table[B[[i,j]]x[[j]],{j,i+1,nn}]/B[[i,i]];
(*Print[x\[LeftDoubleBracket]i\[RightDoubleBracket]];*)
PrintTemporary[i]
,{i,nn-1,1,-1}];

Do[x[[i]] = Simplify[x[[i]]];PrintTemporary[i];PrintTemporary[x[[i]]];,{i,Length@x}];
p = Unvec[x];
ph = ConstantArray[0,{Length@p,Length@p}];
phh = p\[HermitianConjugate];
Do[
ph[[i,j]]=cf[phh[[i,j]]];
PrintTemporary[{i,j}];
PrintTemporary[ph[[i,j]]];
,{i,Length@p},{j,Length@p}];
\[Rho] = p + ph;
tr = Tr[\[Rho]]//Simplify;
\[Rho] = \[Rho]/tr;
Simplify@\[Rho]
]


(* ::Input::Initialization:: *)
Clear[WaitingTimeDistribution];
WaitingTimeDistribution[t_,\[ScriptCapitalL]0_,\[ScriptCapitalJ]i_,\[ScriptCapitalJ]f_,\[Rho]0_:None]:=Module[{\[Rho],d=Sqrt[Length@\[ScriptCapitalL]0]},
\[Rho]=If[\[Rho]0===None,Eye[d]/d,\[Rho]0];
UnTr[\[ScriptCapitalJ]f . MatrixExp[\[ScriptCapitalL]0 t,\[ScriptCapitalJ]i . Vec[\[Rho]]]]/UnTr[\[ScriptCapitalJ]i . Vec[\[Rho]]]//Chop
]
  
WaitingTimeDistribution[ts_?ArrayQ, \[ScriptCapitalL]0_,\[ScriptCapitalJ]i_,\[ScriptCapitalJ]f_,\[Rho]0_:None]:=Table[WaitingTimeDistribution[t,\[ScriptCapitalL]0,\[ScriptCapitalJ]i,\[ScriptCapitalJ]f,\[Rho]0],{t,ts}]


(* ::Input::Initialization:: *)
Clear[WaitingTimeDistributionClassical]
WaitingTimeDistributionClassical[t_,\[ScriptCapitalL]0_,\[ScriptCapitalJ]i_,\[ScriptCapitalJ]f_,\[Rho]0_:None]:=Module[{\[Rho],d=Length@\[ScriptCapitalL]0},
\[Rho]=If[\[Rho]0===None,ConstantArray[1,d]/d,\[Rho]0];
Total[\[ScriptCapitalJ]f . MatrixExp[\[ScriptCapitalL]0 t,\[ScriptCapitalJ]i . \[Rho]]]/Total[\[ScriptCapitalJ]i . \[Rho]]]      

WaitingTimeDistributionClassical[ts_?ArrayQ, \[ScriptCapitalL]0_,\[ScriptCapitalJ]i_,\[ScriptCapitalJ]f_,\[Rho]0_:None]:=Table[WaitingTimeDistributionClassical[t,\[ScriptCapitalL]0,\[ScriptCapitalJ]i,\[ScriptCapitalJ]f,\[Rho]0],{t,ts}]


(* ::Input::Initialization:: *)
(*Clear[WaitingTimeMoments];
WaitingTimeMoments[\[Rho]_?MatrixQ,\[ScriptCapitalL]_,\[ScriptCapitalL]1_,n_,reset_:True]:=Module[{f,\[Alpha],\[Rho]0},
f = LinearSolve[\[ScriptCapitalL]-\[ScriptCapitalL]1];
\[Rho]0 = If[reset==True,\[ScriptCapitalL]1.Vec[\[Rho]]/UnTr[\[ScriptCapitalL]1.Vec[\[Rho]]],Vec[\[Rho]]];
\[Alpha] = Nest[f,\[Rho]0,n];
(-1)^nn! UnTr[\[Alpha]] //Chop 
];
*)

Clear[WaitingTimeMoments]
WaitingTimeMoments[\[Rho]_?MatrixQ,\[ScriptCapitalL]0_,\[ScriptCapitalL]2_,\[ScriptCapitalL]1_,n_,reset_:True]:=Module[{f,\[Alpha],\[Rho]0},
f = LinearSolve[\[ScriptCapitalL]0];
\[Rho]0 = If[reset==True,\[ScriptCapitalL]1 . Vec[\[Rho]]/UnTr[\[ScriptCapitalL]1 . Vec[\[Rho]]],Vec[\[Rho]]];
\[Alpha] = Nest[f,\[Rho]0,n+1];
(-1)^(n+1) n! UnTr[\[ScriptCapitalL]2 . \[Alpha]]  //Chop
];


WaitingTimeMoments[\[Rho]_?VectorQ,\[ScriptCapitalL]_,\[ScriptCapitalL]1_,n_,reset_:True]:=Module[{f,\[Alpha],\[Rho]0},
f = LinearSolve[\[ScriptCapitalL]-\[ScriptCapitalL]1];
\[Rho]0 = If[reset==True,\[ScriptCapitalL]1 . \[Rho]/Total[\[ScriptCapitalL]1 . \[Rho]],\[Rho]];
\[Alpha] = Nest[f,\[Rho]0,n];
(-1)^n n! Total[\[Alpha]]  //Chop
]


(* ::Input::Initialization:: *)
(* The actual no-jump distribution is computed as Subscript[P, no]=tr(\[Rho]f), where f is the output of "NoJumpDistributionFactor" *)
(* This is what the function NoJumpDistribution does *)

Clear[NoJumpDistributionFactor];
NoJumpDistributionFactor[ts_,\[ScriptCapitalL]0_]:=Module[{d = (Length[\[ScriptCapitalL]0])^(1/2)},
Table[UnTr@MatrixExp[\[ScriptCapitalL]0 t, kron[Basis[d,j],Basis[d,i]]],{j,d},{i,d},{t,ts}]]

NoJumpDistributionFactor[ts_,H_,cops_]:=Module[{d = H,He,\[ScriptCapitalE]},
He = H - I/2 Total@Table[c\[ConjugateTranspose] . c,{c,cops}];
Transpose[Table[
\[ScriptCapitalE] = MatrixExp[-I He t];
\[ScriptCapitalE]\[ConjugateTranspose] . \[ScriptCapitalE],{t,ts}],{3,1,2}]
]


(* ::Input::Initialization:: *)
Clear[NoJumpDistribution];
NoJumpDistribution[\[Rho]_,f_]:=Vec[\[Rho]] . Flatten[f,1]//Chop

NoJumpDistribution[\[Rho]_,ts_,\[ScriptCapitalL]0_]:=With[{f = NoJumpDistributionFactor[ts,\[ScriptCapitalL]0]},NoJumpDistribution[\[Rho],f]];

NoJumpDistribution[\[Rho]_,ts_,H_,cops_]:=With[{f = NoJumpDistributionFactor[ts,H,cops]},NoJumpDistribution[\[Rho],f]];


(* ::Input::Initialization:: *)
Clear[EmissionSpectrum];
EmissionSpectrum[\[Rho]_,\[Omega]s_,L_,c_]:=Module[{one,J,\[Alpha],\[Beta],tab,tmp,\[DoubleStruckCapitalI]=Eye[Length@L]},

tab = Table[
\[Alpha] = LinearSolve[L-I \[Omega] \[DoubleStruckCapitalI], Vec[c . \[Rho]]];
(*\[Beta] = LinearSolve[L+\[ImaginaryI] \[Omega] Eye[Length@L], Vec[\[Rho].c\[ConjugateTranspose]]];*)
tmp= -Tr[c\[ConjugateTranspose] . Unvec[\[Alpha]]](*-Tr[c.Unvec[\[Beta]]]*);
tmp+tmp\[Conjugate]
,{\[Omega],\[Omega]s}];

tab//Chop
]


(* ::Input::Initialization:: *)
Clear[AbsorptionSpectrum];
AbsorptionSpectrum[\[Rho]_,\[Omega]s_,L_,c_]:=Module[{one,J,\[Alpha],\[Beta],tab,tmp},

tab = Table[
\[Alpha] = LinearSolve[L-I \[Omega] Eye[Length@L], Vec[\[Rho] . c]];
(*\[Beta] = LinearSolve[L+\[ImaginaryI] \[Omega] Eye[Length@L], Vec[c\[ConjugateTranspose].\[Rho]]];*)
tmp= -Tr[c\[ConjugateTranspose] . Unvec[\[Alpha]]](*-Tr[c.Unvec[\[Beta]]]*);
tmp+tmp\[Conjugate]
,{\[Omega],\[Omega]s}];

tab//Chop
]


(* ::Input::Initialization:: *)
Clear[CollisionMap];
CollisionMap[\[Rho]s0_,Y_,\[Rho]a_,n_,output_:"system"]:=Module[{ds=Length@\[Rho]s0,da=Length@\[Rho]a,U,\[ScriptCapitalE]},

(* Check to see if Y = Unitary or if Y = channel *)
If[Length[Y] == Length[\[Rho]s0] Length[\[Rho]a],
(
U = Y;
Which[
output=="system",
NestList[PTr[U . kron[#,\[Rho]a] . U\[ConjugateTranspose],{2},{ds,da}]&,\[Rho]s0,n],
output=="all",
NestList[
With[{\[Rho]sa=U . kron[#[[1]],\[Rho]a] . U\[ConjugateTranspose]} , 
{PTr[\[Rho]sa,{2},{ds,da}],PTr[\[Rho]sa,{1},{ds,da}]}]&,{\[Rho]s0,\[Rho]a},n]
]),
(
\[ScriptCapitalE] = Y;
Which[
output=="system",
NestList[PTr[Unvec[\[ScriptCapitalE] . Vec[kron[#,\[Rho]a]]],{2},{ds,da}]&,\[Rho]s0,n],
output=="all",
NestList[
With[{\[Rho]sa=Unvec[\[ScriptCapitalE] . Vec[kron[#[[1]],\[Rho]a]]]} , 
{PTr[\[Rho]sa,{2},{ds,da}],PTr[\[Rho]sa,{1},{ds,da}]}]&,{\[Rho]s0,\[Rho]a},n]
]
)]
]


(* ::Input::Initialization:: *)
Clear[CollisionModelSteadyState]
CollisionModelSteadyState[U_,\[Rho]a_]:=Module[{da=Length@\[Rho]a,ds,\[Rho],\[ScriptCapitalT],p},
ds = Length[U]/da;
\[Rho] = Table[p[i,j],{i,ds},{j,ds}];
\[ScriptCapitalT]=Last@CoefficientArrays[Vec[PTr[U . kron[\[Rho],\[Rho]a] . U\[ConjugateTranspose],{2},{ds,da}]],Vec[\[Rho]]];
(*SteadyState[\[ScriptCapitalT]-Eye[ds^2]]*)
AnalyticalSteadyState[\[ScriptCapitalT]-Eye[ds^2]] (* "AnalyticalSteadyState handles multiple steady-states, by selecting one that is guaranteed physical *)
]

CollisionModelSteadyState[U_,Ud_,\[Rho]a_]:=Module[{da=Length@\[Rho]a,ds,\[Rho],\[ScriptCapitalT],p},
ds = Length[U]/da;
\[Rho] = Table[p[i,j],{i,ds},{j,ds}];
\[ScriptCapitalT]=Last@CoefficientArrays[Vec[PTr[U . kron[\[Rho],\[Rho]a] . Ud,{2},{ds,da}]],Vec[\[Rho]]];
(*SteadyState[\[ScriptCapitalT]-Eye[ds^2]]*)
AnalyticalSteadyState[\[ScriptCapitalT]-Eye[ds^2]] (* "AnalyticalSteadyState handles multiple steady-states, by selecting one that is guaranteed physical *)
]


(* ::Input::Initialization:: *)
Clear[SwapOperatorMatrix];
SwapOperatorMatrix[d_]:=Module[{mat,i,j,row,col},mat=ConstantArray[0,{d^2,d^2}];
For[i=0,i<d,i++,For[j=0,j<d,j++,row=i*d+j+1;
col=j*d+i+1;
mat[[row,col]]=1;]];
mat]


(* ::Input::Initialization:: *)
Clear[SuperopHC];
SuperopHC[A_]:= With[{U = SwapOperatorMatrix[Sqrt[Length@A]]},A + U . (A\[Conjugate]) . U\[Transpose]]


(* ::Input::Initialization:: *)
Clear[\[DoubleStruckCapitalO]L,\[DoubleStruckCapitalO]R,\[DoubleStruckCapitalO]LR];
\[DoubleStruckCapitalO]LR[A_,B_]:=B\[Transpose]\[CircleTimes]A;
\[DoubleStruckCapitalO]L[A_]:=Eye[A]\[CircleTimes]A
\[DoubleStruckCapitalO]R[A_]:=A\[Transpose]\[CircleTimes]Eye[A]


(* ::Input::Initialization:: *)
Clear[RedfieldDissipatorFermionicBath];
RedfieldDissipatorFermionicBath[\[ScriptCapitalE]_,S_,cs_,\[Mu]_,T_,\[Gamma]_,spic_:False]:=Module[{\[Sigma],\[DoubleStruckF],\[CapitalDelta]p,\[CapitalDelta]m,\[CapitalGamma]p,\[CapitalGamma]m,d=Length@\[ScriptCapitalE],\[CapitalPhi]p,\[CapitalPhi]m,\[ScriptCapitalD],U,\[DoubleStruckCapitalI] = NEye[Length@\[ScriptCapitalE]],cp,cm,b},
\[Sigma] = Table[out[S[[n]],S[[n]]],{n,Length@S}];
\[DoubleStruckF][x_]:=(1-Tanh[(x-\[Mu])/(2T)])/2(*1/(\[ExponentialE]^((x-\[Mu])/T)+1)*);

\[CapitalDelta]p[\[Omega]_]:=1/(2\[Pi]) Re@PolyGamma[1/2+(I (\[Omega]-\[Mu]))/(2\[Pi] T)];
\[CapitalDelta]m[\[Omega]_]:=-(1/(2\[Pi]))Re@PolyGamma[1/2+(I (-\[Omega]-\[Mu]))/(2\[Pi] T)];
\[CapitalGamma]p[\[Omega]_]:=\[Gamma]/2 \[DoubleStruckF][\[Omega]] +  I \[Gamma] \[CapitalDelta]p[\[Omega]];
\[CapitalGamma]m[\[Omega]_]:=\[Gamma]/2 (1-\[DoubleStruckF][\[Omega]]) + I \[Gamma] \[CapitalDelta]m[\[Omega]];

\[CapitalPhi]p= Sum[\[CapitalGamma]p[\[ScriptCapitalE][[n]]-\[ScriptCapitalE][[m]]] kron[\[Sigma][[m]]\[Transpose],\[Sigma][[n]]],{n,d},{m,d}];
\[CapitalPhi]m= Sum[\[CapitalGamma]m[\[ScriptCapitalE][[m]]-\[ScriptCapitalE][[n]]] kron[\[Sigma][[m]]\[Transpose],\[Sigma][[n]]],{n,d},{m,d}];
If[spic===False,
\[ScriptCapitalD] = Sum[
cp = Unvec[\[CapitalPhi]p . Vec[c\[ConjugateTranspose]]];
cm = Unvec[\[CapitalPhi]m . Vec[c]];
\[DoubleStruckCapitalO]LR[cp,b] - \[DoubleStruckCapitalO]L[b . cp] + \[DoubleStruckCapitalO]LR[cm,b\[ConjugateTranspose]]-\[DoubleStruckCapitalO]L[b\[ConjugateTranspose] . cm],{c,cs},{b,cs}];
,
\[ScriptCapitalD]=Sum[\[DoubleStruckCapitalO]R[b] . \[CapitalPhi]p . \[DoubleStruckCapitalO]L[c\[ConjugateTranspose]]-\[DoubleStruckCapitalO]L[b] . \[CapitalPhi]p . \[DoubleStruckCapitalO]L[c\[ConjugateTranspose]] + \[DoubleStruckCapitalO]R[b\[ConjugateTranspose]] . \[CapitalPhi]m . \[DoubleStruckCapitalO]L[c]-\[DoubleStruckCapitalO]L[b\[ConjugateTranspose]] . \[CapitalPhi]m . \[DoubleStruckCapitalO]L[c] ,{c,cs},{b,cs}];
];
SuperopHC[\[ScriptCapitalD]]
];


(* ::Input::Initialization:: *)
Clear[RedfieldDissipatorFermionicBathCurrentKernel]
RedfieldDissipatorFermionicBathCurrentKernel[type_,\[ScriptCapitalE]_,S_,cs_,\[Mu]_,T_,\[Gamma]_,spic_:False]:=Module[{\[Sigma],\[DoubleStruckF],\[CapitalDelta]p,\[CapitalDelta]m,\[CapitalGamma]p,\[CapitalGamma]m,\[CapitalPhi]p,\[CapitalPhi]m,d=Length@\[ScriptCapitalE],\[ScriptCapitalK],\[DoubleStruckCapitalI] = NEye[Length@\[ScriptCapitalE]],cp,cm,b},
\[Sigma] = Table[out[S[[n]],S[[n]]],{n,Length@S}];
\[DoubleStruckF][x_]:=(1-Tanh[(x-\[Mu])/(2T)])/2(*1/(\[ExponentialE]^((x-\[Mu])/T)+1)*);
\[CapitalDelta]p[\[Omega]_]:=1/(2\[Pi]) Re@PolyGamma[1/2+(I (\[Omega]-\[Mu]))/(2\[Pi] T)];
\[CapitalDelta]m[\[Omega]_]:=-(1/(2\[Pi]))Re@PolyGamma[1/2+(I (-\[Omega]-\[Mu]))/(2\[Pi] T)];

If[type==="particle",
\[CapitalGamma]p[\[Omega]_]:=\[Gamma]/2 \[DoubleStruckF][\[Omega]] +  I \[Gamma] \[CapitalDelta]p[\[Omega]];
\[CapitalGamma]m[\[Omega]_]:=\[Gamma]/2 (1-\[DoubleStruckF][\[Omega]]) + I \[Gamma] \[CapitalDelta]m[\[Omega]];
,
\[CapitalGamma]p[\[Omega]_]:=\[Gamma]/2 \[DoubleStruckF][\[Omega]] \[Omega]+  I \[Gamma] \[CapitalDelta]p[\[Omega]] \[Omega];
\[CapitalGamma]m[\[Omega]_]:=\[Gamma]/2 (1-\[DoubleStruckF][\[Omega]])\[Omega] + I \[Gamma] \[CapitalDelta]m[\[Omega]]\[Omega];
];

\[CapitalPhi]p= Sum[\[CapitalGamma]p[\[ScriptCapitalE][[n]]-\[ScriptCapitalE][[m]]] kron[\[Sigma][[m]]\[Transpose],\[Sigma][[n]]],{n,d},{m,d}];
\[CapitalPhi]m= Sum[\[CapitalGamma]m[\[ScriptCapitalE][[m]]-\[ScriptCapitalE][[n]]] kron[\[Sigma][[m]]\[Transpose],\[Sigma][[n]]],{n,d},{m,d}];

If[spic===False,
\[ScriptCapitalK] = 
-Sum[
cp = Unvec[\[CapitalPhi]p . Vec[c\[ConjugateTranspose]]];
cm = Unvec[\[CapitalPhi]m . Vec[c]];
\[DoubleStruckCapitalO]L[b\[ConjugateTranspose]] . \[DoubleStruckCapitalO]L[cm] - \[DoubleStruckCapitalO]L[b . cp]
,{c,cs},{b,cs}];
,
\[ScriptCapitalK]=-Sum[\[DoubleStruckCapitalO]L[b\[ConjugateTranspose]] . \[CapitalPhi]m . \[DoubleStruckCapitalO]L[c]- \[DoubleStruckCapitalO]L[b] . \[CapitalPhi]p . \[DoubleStruckCapitalO]L[c\[ConjugateTranspose]],{c,cs},{b,cs}]
];
SuperopHC[\[ScriptCapitalK]]

];


(* ::Input::Initialization:: *)
(* Assumes a spectral density J = \[Gamma] \[Omega]^\[Alpha] e^(-\[Omega]/Subscript[\[Omega], cut])*)
(*Clear[principalValueBosonicBath]
principalValueBosonicBath[\[CapitalOmega]\[CapitalOmega]_,J_,T_,\[Epsilon]_:10^-7]:=Module[{\[Omega],\[CapitalOmega],\[DoubleStruckN]},
\[DoubleStruckN][\[Omega]_]:=1/(\[ExponentialE]^(\[Omega]/T)-1);
\[CapitalOmega]=If[Abs[\[CapitalOmega]\[CapitalOmega]]>10^-12,\[CapitalOmega]\[CapitalOmega],10^-6];
1/(2\[Pi])If[\[CapitalOmega]>=0,
NIntegrate[J[\[Omega]] \[DoubleStruckN][\[Omega]]/(\[Omega]+\[CapitalOmega]),{\[Omega],0,\[Infinity]}]-(NIntegrate[J[\[Omega]] (\[DoubleStruckN][\[Omega]]+1)/(\[Omega]-\[CapitalOmega]),{\[Omega],0,\[CapitalOmega]-\[Epsilon]}]+NIntegrate[J[\[Omega]] (\[DoubleStruckN][\[Omega]]+1)/(\[Omega]-\[CapitalOmega]),{\[Omega],\[CapitalOmega]+\[Epsilon],\[Infinity]}]),
(NIntegrate[J[\[Omega]] \[DoubleStruckN][\[Omega]]/(\[Omega]+\[CapitalOmega]),{\[Omega],0,Abs[\[CapitalOmega]]-\[Epsilon]}]+NIntegrate[J[\[Omega]] \[DoubleStruckN][\[Omega]]/(\[Omega]+\[CapitalOmega]),{\[Omega],Abs[\[CapitalOmega]]+\[Epsilon],\[Infinity]}])-NIntegrate[J[\[Omega]] (\[DoubleStruckN][\[Omega]]+1)/(\[Omega]-\[CapitalOmega]),{\[Omega],0,\[Infinity]}]
]

]*)


(* ::Input::Initialization:: *)
Clear[RedfieldDissipatorBosonicBath];
RedfieldDissipatorBosonicBath[\[ScriptCapitalE]_,S_,L_,T_,\[Gamma]_,spic_:False]:=Module[{\[Sigma],n,m,\[DoubleStruckN],\[CapitalGamma],d=Length@\[ScriptCapitalE],\[CapitalPhi],\[ScriptCapitalD],U,\[DoubleStruckCapitalI] = NEye[Length@\[ScriptCapitalE]],R,J},
\[Sigma] = Table[out[S[[n]],S[[n]]],{n,Length@S}];
\[DoubleStruckN][\[Omega]_]:=1/(E^(\[Omega]/T)-1);
J[\[Omega]_]:=
If[NumericQ[\[Gamma]],
\[Gamma] \[Omega] ,
\[Gamma][\[Omega]]];

\[CapitalGamma][\[Omega]_]:=Which[
\[Omega]>0,(J[\[Omega]](1+\[DoubleStruckN][\[Omega]]))/2(*+0\[ImaginaryI]  principalValueBosonicBath[\[Omega],J,T]*),
\[Omega]<0,(J[-\[Omega]] \[DoubleStruckN][-\[Omega]])/2(*+0\[ImaginaryI]  principalValueBosonicBath[\[Omega],J,T]*),
True,If[NumericQ[\[Gamma]],(\[Gamma] T)/2,J[0]]];

\[CapitalPhi]= Sum[\[CapitalGamma][\[ScriptCapitalE][[m]]-\[ScriptCapitalE][[n]]] \[DoubleStruckCapitalO]LR[\[Sigma][[n]],\[Sigma][[m]]],{n,d},{m,d}];

\[ScriptCapitalD]=If[spic===False,
R=Unvec[\[CapitalPhi] . Vec@L];
\[DoubleStruckCapitalO]LR[R,L]-\[DoubleStruckCapitalO]L[L . R],
\[DoubleStruckCapitalO]R[L] . \[CapitalPhi] . \[DoubleStruckCapitalO]L[L]-\[DoubleStruckCapitalO]L[L] . \[CapitalPhi] . \[DoubleStruckCapitalO]L[L]
];
SuperopHC[\[ScriptCapitalD]]

];


(* ::Input::Initialization:: *)
Clear[GlobalMasterEquationDissipator];
GlobalMasterEquationDissipator[\[ScriptCapitalE]_,S_,L_,T_,\[Gamma]_]:=Module[{Ls,\[Omega]s,\[CapitalGamma],j,\[DoubleStruckN],J},
{\[Omega]s,Ls} = EigenoperatorDecomposition[\[ScriptCapitalE],S,L];
\[DoubleStruckN][\[Omega]_]:=1/(E^(\[Omega]/T)-1);
J[\[Omega]_]:=
If[NumericQ[\[Gamma]],
\[Gamma] \[Omega],
\[Gamma][\[Omega]]];

\[CapitalGamma][\[Omega]_]:=Which[
\[Omega]>0,J[\[Omega]](1+\[DoubleStruckN][\[Omega]])(*+0\[ImaginaryI]  principalValueBosonicBath[\[Omega],J,T]*),
\[Omega]<0,J[-\[Omega]] \[DoubleStruckN][-\[Omega]](*+0\[ImaginaryI]  principalValueBosonicBath[\[Omega],J,T]*),
True,If[NumericQ[\[Gamma]],\[Gamma] T,J[0]]];

Sum[\[CapitalGamma][\[Omega]s[[j]]] LindbladToVec[Ls[[j]]],{j,Length@Ls}]

]


(* ::Input::Initialization:: *)
Clear[mK2GHz,\[Mu]V2GHz];
mK2GHz=(0.001*1.38 10^-23)/(6.6 10^-34*10^9)
\[Mu]V2GHz=0.242;
GHz2pA=(10^9*1.6 10^-19)/10^-12


(* ::Input::Initialization:: *)
Clear[DQDRedfield];
DQDRedfield[{vg1_,vg2_},Vsd_,g_,U_,{TL_,TR_,Tm_},{\[Gamma]L_,\[Gamma]R_,\[Gamma]m_}]:=Module[{Vg1 ,Vg2,\[Mu]L ,\[Mu]R ,H,\[ScriptCapitalE],S,\[ScriptCapitalL],\[ScriptCapitalD]L,\[ScriptCapitalD]R,\[ScriptCapitalD]m,\[ScriptCapitalL]I,cL,cR,cm},
\[Mu]L = -Vsd/2;
\[Mu]R = Vsd/2;
Vg1 = vg1-U/2;
Vg2 = vg2-U/2;

LoadFermionicOperators[2];
H = Vg1 cd[1] . c[1]+Vg2 cd[2] . c[2]+ g (cd[1] . c[2]+cd[2] . c[1])+U cd[1] . c[1] . cd[2] . c[2];
{\[ScriptCapitalE],S}=Eigensystem[H];

cL = c[1];
cR = c[2];
cm = cd[1] . c[1]-cd[2] . c[2];
(*cm = cd[1].c[2]+cd[2].c[1];*)
\[ScriptCapitalD]L = RedfieldDissipatorFermionicBath[\[ScriptCapitalE],S,{cL},\[Mu]L,TL,\[Gamma]L,False];
\[ScriptCapitalD]R = RedfieldDissipatorFermionicBath[\[ScriptCapitalE],S,{cR},\[Mu]R,TR,\[Gamma]R,False];

\[ScriptCapitalD]m = If[\[Gamma]m<10^-12,
0 \[ScriptCapitalD]L,
 RedfieldDissipatorBosonicBath[\[ScriptCapitalE],S,cm,Tm,\[Gamma]m]

];
\[ScriptCapitalL] =UnitaryToVec[H] + \[ScriptCapitalD]L+\[ScriptCapitalD]R +\[ScriptCapitalD]m;
\[ScriptCapitalL]I = RedfieldDissipatorFermionicBathCurrentKernel["particle",\[ScriptCapitalE],S,{cL},\[Mu]L,TL,\[Gamma]L,False];
{\[ScriptCapitalL],\[ScriptCapitalL]I}
]


(* ::Input::Initialization:: *)
Clear[DQD3Levels];
DQD3Levels[{vg1_,vg2_},Vsd_,g_,U_,{TL_,TR_},{\[Gamma]L_,\[Gamma]R_}]:=Module[{fL,fR,geff,W,\[Mu]L,\[Mu]R,Vg1,Vg2,\[Nu]},
\[Mu]L = -Vsd/2;
\[Mu]R = Vsd/2;
Vg1 = vg1-U/2;
Vg2 = vg2-U/2;
fL = \[DoubleStruckF][(Vg1-\[Mu]L)/TL];
fR = \[DoubleStruckF][(Vg2-\[Mu]R)/TR];
geff = (4g^2 (\[Gamma]L+\[Gamma]R))/((\[Gamma]L+\[Gamma]R)^2+4(Vg1-Vg2)^2);
W = ({
 {0, \[Gamma]L (1-fL), \[Gamma]R (1-fR)},
 {\[Gamma]L fL, 0, geff},
 {\[Gamma]R fR, geff, 0}
});
\[Nu] = ({
 {0, 0, 1},
 {0, 0, 0},
 {-1, 0, 0}
});
{W,\[Nu]}
]


(* ::Input::Initialization:: *)
Clear[DQD4Levels];
DQD4Levels[{vg1_,vg2_},Vsd_,g_,U_,{TL_,TR_},{\[Gamma]L_,\[Gamma]R_}]:=Module[{fL,fR,fLp,fRp,geff,W,\[Mu]L,\[Mu]R,Vg1,Vg2,\[Nu]},
\[Mu]L = -Vsd/2;
\[Mu]R = Vsd/2;
Vg1 = vg1-U/2;
Vg2 = vg2-U/2;
fL = \[DoubleStruckF][(Vg1-\[Mu]L)/TL];
fR = \[DoubleStruckF][(Vg2-\[Mu]R)/TR];
fLp = \[DoubleStruckF][(Vg1+U-\[Mu]L)/TL];
fRp = \[DoubleStruckF][(Vg2+U-\[Mu]R)/TR];

geff = (4g^2 (\[Gamma]L+\[Gamma]R))/((\[Gamma]L+\[Gamma]R)^2+4(Vg1-Vg2)^2);

W = ({
 {0, \[Gamma]L (1-fL), \[Gamma]R (1-fR), 0},
 {\[Gamma]L fL, 0, geff, \[Gamma]R(1-fRp)},
 {\[Gamma]R fR, geff, 0, \[Gamma]L (1-fLp)},
 {0, \[Gamma]R fRp, \[Gamma]L fLp, 0}
});
\[Nu] = ({
 {0, 0, 1, 0},
 {0, 0, 0, 1},
 {-1, 0, 0, 0},
 {0, -1, 0, 0}
});
{W,\[Nu]}
]


(* ::Input::Initialization:: *)
(* Wrapper for different ways of solving for the Drazin inverse *)
Clear[DrazinSolver,DrazinApplySolverMethod2,DrazinApplySolverMethod3];
DrazinSolver[\[ScriptCapitalL]_,y_,\[Rho]v_,method_:1]:=Module[{\[ScriptCapitalL]big},
Which[
method===1,
DrazinInverse[\[ScriptCapitalL]] . y,
method===2,
DrazinApplySolverMethod2[\[ScriptCapitalL],y,\[Rho]v],
method===3,
DrazinApplySolverMethod3[\[ScriptCapitalL],\[Rho]v,y]]
];

DrazinApplySolverMethod2[\[ScriptCapitalL]_,y_,\[Rho]v_]:=Module[{z},
z = LinearSolve[\[ScriptCapitalL], y-\[Rho]v UnTr[y]];
z - \[Rho]v UnTr[z]
]

DrazinApplySolverMethod3[\[ScriptCapitalL]_,y_,\[Rho]v_]:=Module[{z,\[ScriptCapitalL]big},
\[ScriptCapitalL]big =Join[\[ScriptCapitalL],{Vec@Eye[Sqrt[Length@\[ScriptCapitalL]]]}];
LinearSolve[\[ScriptCapitalL]big, Join[y-UnTr[y] \[Rho]v ,{0}]]
]



(* ::Input::Initialization:: *)
fcsJumpterms = {"jump","Jumps","PD","Photo Detection"};
fcsDiffterms = {"diffusion","homodyne","diffusive","diff"};

Clear[JumpOp];
JumpOp[c_,type_:"jump"]:=
Which[
matchString[fcsJumpterms,type],kron[c\[Conjugate],c],
matchString[fcsDiffterms,type]||True,kron[Eye[Length@c],c]+kron[c\[Conjugate],Eye[Length@c]]
]

Clear[fcsGetL];
fcsGetL[LL_,type_]:=Module[{L,d},
L=If[Length@Dimensions[LL]==2,{JumpOp[LL,type]},JumpOp[#,type]&/@LL]; (* List of operators *);
d = Length@L;
{L,d}
]

Clear[fcsGetNu];
fcsGetNu[\[Nu]\[Nu]_,d_]:=Module[{\[Nu],R},
\[Nu] = Which[
Dimensions[\[Nu]\[Nu]]==={d},{\[Nu]\[Nu]},
Dimensions[\[Nu]\[Nu]]==={},{\[Nu]\[Nu] ConstantArray[1,d]},
True,\[Nu]\[Nu]];
R = Length@\[Nu];
{\[Nu],R}
];

Clear[fcsGetK];
fcsGetK[\[Mu]_,L_,\[Rho]_,type_]:=Module[{\[Rho]v,Jk,K},
\[Rho]v = Vec[\[Rho]];
Jk = Table[UnTr[lop . \[Rho]v],{lop,L}];

K=Which[
matchString[fcsJumpterms,type],\[Mu] . DiagonalMatrix[Jk] . (\[Mu]\[Transpose])\[Conjugate],
matchString[fcsDiffterms,type]||True,\[Mu] . (\[Mu]\[Transpose])\[Conjugate]
]//Chop;
{K,Jk}
]


(* ::Input::Initialization:: *)
Clear[JumpOpList];
JumpOpList[cops_,rates_,type_:"jump"]:=Table[rates[[i]] JumpOp[cops[[i]],type],{i,Length@cops}];


(* ::Input::Initialization:: *)
Clear[FCSAverage];
FCSAverage[\[Rho]_,\[ScriptCapitalL]_,LL_,\[Nu]\[Nu]_:1,type_:"jump"]:=Module[{L,\[Nu],\[Rho]v,d,res,R},

{L,d} = fcsGetL[LL,type];
{\[Nu],R} = fcsGetNu[\[Nu]\[Nu],d];

\[Rho]v = Vec[\[Rho]];
res=Table[Total@Table[\[Nu][[\[Alpha],i]] UnTr[L[[i]] . \[Rho]v],{i,d}],{\[Alpha],Length@\[Nu]}]//Chop;
If[Length@res==1,res[[1]],res]
]


(* ::Input::Initialization:: *)
Clear[FCSK];
FCSK[\[Rho]_,\[ScriptCapitalL]_,LL_,\[Nu]\[Nu]_:1,type_:"jump"]:=fcsGetK[\[Nu]\[Nu],LL,\[Rho],type][[1]];


(* ::Input::Initialization:: *)
Clear[FCSNoise];
FCSNoise[\[Rho]_,\[ScriptCapitalL]_,LL_,\[Nu]\[Nu]_:1,type_:"PD",method_:1]:=Module[{L,\[Nu],\[Rho]v,d,Jk,M,R,\[ScriptCapitalL]big,\[ScriptCapitalL]\[Alpha],J\[Alpha],ws,\[ScriptCapitalD],K},

{L,d} = fcsGetL[LL,type];
{\[Nu],R} = fcsGetNu[\[Nu]\[Nu],d];
\[Rho]v = Vec[\[Rho]];
{K,Jk} = fcsGetK[\[Nu],L,\[Rho],type];

\[ScriptCapitalL]\[Alpha] = \[Nu] . L;
J\[Alpha] = UnTr[# . \[Rho]v]&/@\[ScriptCapitalL]\[Alpha]//Chop;
(* Older version *)
(*\[ScriptCapitalL]big =Join[\[ScriptCapitalL],{Vec@Eye[Sqrt[Length@\[ScriptCapitalL]]]}];*)
(*ws = Table[LinearSolve[\[ScriptCapitalL]big, Join[\[ScriptCapitalL]\[Alpha]\[LeftDoubleBracket]i\[RightDoubleBracket].\[Rho]v-J\[Alpha]\[LeftDoubleBracket]i\[RightDoubleBracket] \[Rho]v ,{0}]],{i,R}];*)
ws = Table[DrazinSolver[\[ScriptCapitalL],\[ScriptCapitalL]\[Alpha][[i]] . \[Rho]v,\[Rho]v],{i,R}];
\[ScriptCapitalD] = -Table[UnTr[\[ScriptCapitalL]\[Alpha][[i]] . ws[[j]]],{i,R},{j,R}];
\[ScriptCapitalD]=\[ScriptCapitalD] + \[ScriptCapitalD]\[Transpose] + K//Chop;
If[R===1,\[ScriptCapitalD][[1,1]],\[ScriptCapitalD]]
]

(* Legacy name *)
Clear[FCSDiffusionMatrix];
FCSDiffusionMatrix[\[Rho]_,\[ScriptCapitalL]_,LL_,\[Nu]\[Nu]_:1,type_:"PD"]:= FCSNoise[\[Rho],\[ScriptCapitalL],LL,\[Nu]\[Nu],type]


(* ::Input::Initialization:: *)
Clear[FCSPowerSpectrum]
FCSPowerSpectrum[\[Omega]\[Omega]s_,\[Rho]_,\[ScriptCapitalL]_,LL_,\[Nu]\[Nu]_:1,type_:"PD"]:=Module[{L,\[Nu],\[Rho]v,d,Jk,K,R,\[ScriptCapitalL]big,\[ScriptCapitalL]\[Alpha],J\[Alpha],ws,\[ScriptCapitalD],\[Lambda],Q,x,y,\[CapitalUpsilon],\[ScriptCapitalS],v1,v2,\[DoubleStruckCapitalI],\[Omega]s,S},

{L,d} = fcsGetL[LL,type];
{\[Nu],R} = fcsGetNu[\[Nu]\[Nu],d];
\[Rho]v = Vec[\[Rho]];
{K,Jk} = fcsGetK[\[Nu],L,\[Rho],type];
\[Omega]s = Flatten@{\[Omega]\[Omega]s};

\[ScriptCapitalL]\[Alpha] = \[Nu] . L;
(*J\[Alpha] = UnTr[#.\[Rho]v]&/@\[ScriptCapitalL]\[Alpha]//Chop;*)

\[DoubleStruckCapitalI] = Eye[Length@\[ScriptCapitalL]];
S=Table[
v1=Table[LinearSolve[\[ScriptCapitalL] - I \[Omega] \[DoubleStruckCapitalI], \[ScriptCapitalL]\[Alpha][[i]] . \[Rho]v],{i,R}];
v2=Table[LinearSolve[\[ScriptCapitalL] + I \[Omega] \[DoubleStruckCapitalI], \[ScriptCapitalL]\[Alpha][[i]] . \[Rho]v],{i,R}];
\[ScriptCapitalS]=K - Table[UnTr[\[ScriptCapitalL]\[Alpha][[\[Beta]]] . v1[[\[Alpha]]]] + UnTr[\[ScriptCapitalL]\[Alpha][[\[Alpha]]] . v2[[\[Beta]]]],{\[Alpha],R},{\[Beta],R}];
{\[Omega],If[R===1,\[ScriptCapitalS][[1,1]],\[ScriptCapitalS]]}
,{\[Omega],\[Omega]s}]//Chop;

If[Length@\[Omega]s==1,S[[1,2]],S]
]


(* ::Input::Initialization:: *)
Clear[FCSEigenPowerSpectrum]
FCSEigenPowerSpectrum[\[Rho]_,\[ScriptCapitalL]_,LL_,\[Nu]\[Nu]_:1,type_:"PD"]:=Module[{L,\[Nu],\[Rho]v,d,Jk,K,R,\[ScriptCapitalL]big,\[ScriptCapitalL]\[Alpha],J\[Alpha],ws,\[ScriptCapitalD],\[Lambda],Q,x,y,\[CapitalUpsilon],\[ScriptCapitalS]},

{L,d} = fcsGetL[LL,type];
{\[Nu],R} = fcsGetNu[\[Nu]\[Nu],d];
\[Rho]v = Vec[\[Rho]];
{K,Jk} = fcsGetK[\[Nu],L,\[Rho],type];

\[ScriptCapitalL]\[Alpha] = \[Nu] . L;
J\[Alpha] = UnTr[# . \[Rho]v]&/@\[ScriptCapitalL]\[Alpha]//Chop;
{\[Lambda],Q} = Eigsys[\[ScriptCapitalL]];
\[Lambda] = Drop[\[Lambda],-1];
x = (Q\[Transpose])[[1;;-2]];
y=Inverse[Q][[1;;-2]];
(*Defined so that \[ScriptCapitalL] = Sum[\[Lambda]\[LeftDoubleBracket]i\[RightDoubleBracket] out[x\[LeftDoubleBracket]i\[RightDoubleBracket],y\[LeftDoubleBracket]i\[RightDoubleBracket]\[Conjugate]],{i,Length[\[ScriptCapitalL]]-1}] *)

\[CapitalUpsilon] = Table[UnTr[\[ScriptCapitalL]\[Alpha][[\[Alpha]]] . out[x[[j]],y[[j]]\[Conjugate]] . \[ScriptCapitalL]\[Alpha][[\[Beta]]] . \[Rho]v],{\[Alpha],R},{\[Beta],R},{j,Length[\[Lambda]]}];

If[R===1,
Function[K[[1,1]] - Chop@Total@Table[1/(\[Lambda][[j]]-I #) \[CapitalUpsilon][[1,1,j]]+1/(\[Lambda][[j]]+I #) \[CapitalUpsilon][[1,1,j]],{j,Length[\[Lambda]]}] ],
Function[K -Table[Chop@Total@Table[1/(\[Lambda][[j]]-I #) \[CapitalUpsilon][[\[Beta],\[Alpha],j]]+1/(\[Lambda][[j]]+I #) \[CapitalUpsilon][[\[Alpha],\[Beta],j]],{j,Length[\[Lambda]]}] ,{\[Alpha],R},{\[Beta],R}]]
]//Chop

]


(* ::Input::Initialization:: *)
Clear[FCSCoherence];
FCSCoherence[\[ScriptCapitalS]_,\[Omega]_]:=((Abs[\[ScriptCapitalS][\[Omega]][[1,2]]]^2)/(\[ScriptCapitalS][\[Omega]][[1,1]] \[ScriptCapitalS][\[Omega]][[2,2]])) 


(* ::Input::Initialization:: *)
Clear[FCSCorr];
FCSCorr[tts_,\[Rho]_,\[ScriptCapitalL]_,A_,B_,\[ScriptCapitalC]_]:=Module[{ts,res,R},
ts = Flatten@{tts};
R = \[ScriptCapitalC] . \[Rho] . A//Vec;

If[Length@ts==1,
Tr[B . Unvec@MatrixExp[\[ScriptCapitalL] ts[[1]],R]],
Table[{t,Tr[B . Unvec@MatrixExp[\[ScriptCapitalL] t,R]]},{t,ts}]
](*//Chop*)
];


(* ::Input::Initialization:: *)
Clear[FCSg2];
FCSg2[tts_,\[Rho]_,\[ScriptCapitalL]_,c_]:= If[Length@Flatten@{tts}==1,

FCSCorr[Flatten@{tts},\[Rho],\[ScriptCapitalL],c\[ConjugateTranspose],c\[ConjugateTranspose] . c,c]/FCSAverage[\[Rho],\[ScriptCapitalL],{c}]^2,
{#[[1]],#[[2]]/FCSAverage[\[Rho],\[ScriptCapitalL],{c}]^2}&/@FCSCorr[Flatten@{tts},\[Rho],\[ScriptCapitalL],c\[ConjugateTranspose],c\[ConjugateTranspose] . c,c]//Chop
];


(* ::Input::Initialization:: *)
Clear[FCSEigenCorr];
FCSEigenCorr[\[Rho]_,\[ScriptCapitalL]_,A_,B_,\[ScriptCapitalC]_]:=Module[{res,R,\[Lambda],Q,x,y,\[CapitalUpsilon]},
R = \[ScriptCapitalC] . \[Rho] . A//Vec;

{\[Lambda],Q} = Eigsys[\[ScriptCapitalL]];
x = (Q\[Transpose]);
y=Inverse[Q];
(*Defined so that \[ScriptCapitalL] = Sum[\[Lambda]\[LeftDoubleBracket]i\[RightDoubleBracket] out[x\[LeftDoubleBracket]i\[RightDoubleBracket],y\[LeftDoubleBracket]i\[RightDoubleBracket]\[Conjugate]],{i,Length[\[ScriptCapitalL]]}] *)

\[CapitalUpsilon] = Table[Tr[B . Unvec[out[x[[j]],y[[j]]\[Conjugate]] . R]],{j,Length[\[Lambda]]}];
Function[(*Chop@*)Total@Table[Exp[\[Lambda][[j]] #] \[CapitalUpsilon][[j]],{j,Length@\[Lambda]}]]
];


(* ::Input::Initialization:: *)
Clear[FCSEigeng2]
FCSEigeng2[\[Rho]_,\[ScriptCapitalL]_,c_]:=Function[t,FCSEigenCorr[\[Rho],\[ScriptCapitalL],c\[ConjugateTranspose],c\[ConjugateTranspose] . c,c][t]/FCSAverage[\[Rho],\[ScriptCapitalL],{c}]^2];


(* ::Input::Initialization:: *)
Clear[FCSTwoPointFunction]
FCSTwoPointFunction[tts_,\[Rho]_,\[ScriptCapitalL]_,LL_,\[Nu]\[Nu]_:1,type_:"PD"]:=Module[{L,\[Nu],\[Rho]v,d,R,\[ScriptCapitalL]big,\[ScriptCapitalL]\[Alpha],J\[Alpha],ws,\[ScriptCapitalD],\[Lambda],Q,x,y,\[CapitalUpsilon],\[ScriptCapitalS],F,ts},
ts = Flatten@{tts};
{L,d} = fcsGetL[LL,type];
{\[Nu],R} = fcsGetNu[\[Nu]\[Nu],d];
\[Rho]v = Vec[\[Rho]];

\[ScriptCapitalL]\[Alpha] = \[Nu] . L;
J\[Alpha] = UnTr[# . \[Rho]v]&/@\[ScriptCapitalL]\[Alpha]//Chop;

F=If[R===1,
Chop@Table[{t,UnTr[\[ScriptCapitalL]\[Alpha][[1]] . MatrixExp[\[ScriptCapitalL] t,\[ScriptCapitalL]\[Alpha][[1]] . \[Rho]v]]-J\[Alpha][[1]]^2},{t,ts}],
Chop@Table[{t,Table[UnTr[\[ScriptCapitalL]\[Alpha][[\[Beta]]] . MatrixExp[\[ScriptCapitalL] t,\[ScriptCapitalL]\[Alpha][[\[Alpha]]] . \[Rho]v]]-J\[Alpha][[\[Alpha]]]J\[Alpha][[\[Beta]]],{\[Alpha],R},{\[Beta],R}]},{t,ts}]
];
If[Length@ts==1,F[[1,2]],F]
]


(* ::Input::Initialization:: *)
Clear[FCSEigenTwoPointFunction]
FCSEigenTwoPointFunction[\[Rho]_,\[ScriptCapitalL]_,LL_,\[Nu]\[Nu]_:1,type_:"PD"]:=Module[{L,\[Nu],\[Rho]v,d,R,\[ScriptCapitalL]big,\[ScriptCapitalL]\[Alpha],ws,\[ScriptCapitalD],\[Lambda],Q,x,y,\[CapitalUpsilon],\[ScriptCapitalS]},

{L,d} = fcsGetL[LL,type];
{\[Nu],R} = fcsGetNu[\[Nu]\[Nu],d];
\[Rho]v = Vec[\[Rho]];

\[ScriptCapitalL]\[Alpha] = \[Nu] . L;

{\[Lambda],Q} = Eigsys[\[ScriptCapitalL]];
\[Lambda] = Drop[\[Lambda],-1];
x = (Q\[Transpose])[[1;;-2]];
y=Inverse[Q][[1;;-2]];
(*Defined so that \[ScriptCapitalL] = Sum[\[Lambda]\[LeftDoubleBracket]i\[RightDoubleBracket] out[x\[LeftDoubleBracket]i\[RightDoubleBracket],y\[LeftDoubleBracket]i\[RightDoubleBracket]\[Conjugate]],{i,Length[\[ScriptCapitalL]]-1}] *)

\[CapitalUpsilon] = Table[UnTr[\[ScriptCapitalL]\[Alpha][[\[Beta]]] . out[x[[j]],y[[j]]\[Conjugate]] . \[ScriptCapitalL]\[Alpha][[\[Alpha]]] . \[Rho]v],{\[Alpha],R},{\[Beta],R},{j,Length[\[Lambda]]}];

If[R===1,
Function[ Chop@Total@Table[Exp[\[Lambda][[j]] #] \[CapitalUpsilon][[1,1,j]],{j,Length[\[Lambda]]}] ],
Function[Table[Chop@Total@Table[Exp[\[Lambda][[j]] #]\[CapitalUpsilon][[\[Beta],\[Alpha],j]],{j,Length[\[Lambda]]}] ,{\[Alpha],R},{\[Beta],R}]]
]
]


(* ::Input::Initialization:: *)
Clear[FCSProbability]
FCSProbability[t_,\[Rho]_,\[ScriptCapitalL]_,LL_,\[Nu]\[Nu]_:1,npts_:1000,tol_:10^-8]:=Module[{cops,L,\[Chi]s,\[Delta]\[Chi],\[ScriptCapitalL]s,\[Rho]v,Ms,n,\[Nu],d,R,\[Chi],nmax,prob,P},
{L,d} = fcsGetL[LL,"jump"];
{\[Nu],R} = fcsGetNu[\[Nu]\[Nu],d];
\[Nu] = First@\[Nu];

\[Chi]s = linspace[-\[Pi],\[Pi],npts];
\[Delta]\[Chi] = \[Chi]s[[2]]-\[Chi]s[[1]];
\[ScriptCapitalL]s = Table[\[ScriptCapitalL] +Sum[(E^(I \[Chi] \[Nu][[i]]) -1) L[[i]],{i,d}] ,{\[Chi],\[Chi]s}];

\[Rho]v = Vec[\[Rho]];
Ms = Chop@Table[Tr[MatrixExp[\[ScriptCapitalL]s[[i]] t,\[Rho]v]],{i,Length@\[ScriptCapitalL]s}];

prob[nns_]:=Table[{n,1/(2\[Pi]) Trapz[E^(-I n \[Chi]s) Ms,\[Delta]\[Chi]]},{n,nns}]//Chop;

nmax = 10;
P = prob[Range[-nmax,nmax]];
While[P[[1,2]]+P[[-1,2]] > tol,
P=Join[prob[Range[-nmax-10,-nmax-1]],P,prob[Range[nmax+1,nmax+10]]];
nmax = nmax+10;
];
P
]


(* ::Input::Initialization:: *)
Clear[FCSProbabilityDiffusion];
FCSProbabilityDiffusion[t_,\[Rho]_,\[ScriptCapitalL]_,L_,cutoff_:10,npts_:1000]:=Module[{\[Chi]s,\[Delta]\[Chi],\[ScriptCapitalL]s,\[Rho]v,Ms,prob,\[DoubleStruckCapitalL]},

\[Chi]s = linspace[-cutoff,cutoff,npts];
\[Delta]\[Chi] = \[Chi]s[[2]]-\[Chi]s[[1]];

\[ScriptCapitalL]s = Table[\[ScriptCapitalL] + I \[Chi] JumpOp[L,"homodyne"]-\[Chi]^2/2 NEye[Length@\[ScriptCapitalL]] ,{\[Chi],\[Chi]s}];
\[Rho]v = Vec[\[Rho]];
Ms = Chop@Table[Tr[MatrixExp[\[DoubleStruckCapitalL] t,\[Rho]v]],{\[DoubleStruckCapitalL],\[ScriptCapitalL]s}];

prob[n_]:=1/(2\[Pi]) Trapz[E^(-I n \[Chi]s) Ms,\[Delta]\[Chi]]//Chop;
prob
]


(* ::Input::Initialization:: *)
Clear[TiltedLiouvillian];

TiltedLiouvillian[H_,Ls_,\[Gamma]s_,\[Nu]s_]:=Module[{L,d,\[Nu],R,\[ScriptCapitalL]\[Chi],j,k},
Clear[\[Chi]];
{L,d} = fcsGetL[Ls,"jump"];
{\[Nu],R} = fcsGetNu[\[Nu]s,d];
\[ScriptCapitalL]\[Chi] = Liouvillian[H,Ls,\[Gamma]s] +If[R==1,
Sum[(E^(I \[Chi] \[Nu][[1,k]])-1) L[[k]],{k,d}],
Sum[(E^(I Subscript[\[Chi], j] \[Nu][[j,k]])-1) L[[k]],{j,R},{k,d}]
]

]

TiltedLiouvillian[H_,Ls_,\[Nu]s_]:=TiltedLiouvillian[H,Ls,ConstantArray[1,Length@Ls],\[Nu]s]
(*TiltedLiouvillian[H_,Ls_,\[Nu]s_]:=Module[{L,d,\[Nu],R,\[ScriptCapitalL]\[Chi],j,k},
Clear[\[Chi]];
{L,d} = fcsGetL[Ls,"jump"];
{\[Nu],R} = fcsGetNu[\[Nu]s,d];
\[ScriptCapitalL]\[Chi] = Liouvillian[H,L] +If[R==1,
Sum[(\[ExponentialE]^(\[ImaginaryI] \[Chi] \[Nu][[1,k]])-1) L[[k]],{k,d}],
Sum[(\[ExponentialE]^(\[ImaginaryI] Subscript[\[Chi], j] \[Nu][[j,k]])-1) L[[k]],{j,R},{k,d}]
]

]*)



(* ::Input::Initialization:: *)
(* For plotting the quantum jumps *)
Clear[JumpHighlight];
JumpHighlight[jumpList_,times_:None,named_:True,thickness_:0.015,yi_:0,yf_:1]:=Module[{shift,ts,types,typ,jL,i,j,tab,names},
ts = If[times===None,Range[1,jumpList[[-1,1]]],times];
types = DeleteDuplicates[jumpList[[All,2]]];
shift = (ts[[-1]]-ts[[1]])0.02;
names = Which[
named===True,types,
ListQ[named],named,
True,False];
Table[
typ = types[[i]];
jL = Select[jumpList,#[[2]]==typ&];
tab={
(Rest@COLORLIST)[[i]],Thickness[thickness],Opacity[0.4],
Table[Line[{
{ts[[j[[1]]]],yi},
{ts[[j[[1]]]],yf}}],{j,jL}]
};

If[Not[names===False] ,AppendTo[tab,Table[Text[Style[names[[i]],(Rest@COLORLIST)[[i]],Bold,Opacity[1]],{shift+ts[[j[[1]]]],(*(yf-yi)0.7*)Rescale[0.7,{0,1},{yi,yf}]}],{j,jL}]]];
tab
,{i,Length@types}]
]


(* ::Input::Initialization:: *)
(* "FromTo" refer to the jump channels. Defaul "All" picks WTD between any kind of jump *)
(* "FromTo = {i,j}" selects the WTD for jumps from i \[Rule] j, without being blind to any intermediate jumps. 
 i.e. i \[Rule] k \[Rule] j would not count *)
(* "From To = {i,j,{k1,k2,...}}" selects the WTD for jumps from i \[Rule] j, assuming one is blind to jumps in 
  channels {k1,k2,...} *)

Clear[WTDfromJumps];
WTDfromJumps[jumpList_,times_:None,FromTo_:All]:=Module[{\[CapitalDelta]t,exclude,jL2},
\[CapitalDelta]t = Which[
ArrayQ[times],times[[2]]-times[[1]],
NumberQ[times],times,
True,1
];

jL2 = Which[
FromTo===All,
Differences[jumpList[[All,1]]],

Length[FromTo]===2,
Differences[#[[All,1]]]&/@Select[Partition[jumpList,2,1],#[[1,2]]==FromTo[[1]] && #[[2,2]]==FromTo[[2]]&]//Flatten,

Length[FromTo]===3,
(exclude = Select[jumpList,Not@MemberQ[FromTo[[3]],#[[2]]]&];
Differences[#[[All,1]]]&/@Select[Partition[exclude,2,1],#[[1,2]]==FromTo[[1]] && #[[2,2]]==FromTo[[2]]&]//Flatten
)
];

jL2 \[CapitalDelta]t

]


(* ::Input::Initialization:: *)
(* Let k = 1,2,3,... denote the jump channels. *)
(* A current is defined by a set of weights Subscript[\[Nu], k] for each channel. *)
(* Let Subscript[dN, k] = 1 when a jump in channel k occurs *)
(* This function computes the integrated current N(t) = \!\(
\*SubscriptBox[\(\[Sum]\), \(\(\ \)\(k\)\)]\ \(
\*SubsuperscriptBox[\(\[Integral]\), \(0\), \(t\)]dt'\ 
\*SubscriptBox[\(\[Nu]\), \(\(k\)\(\ \)\)]
\*SubscriptBox[\(dN\), \(k\)]\((t')\)\)\) *)

(* Input \[Nu] must be a list of weights with the same length as the number of channels in jumpList *)

(* \[Nu] = {1,1,...} yields the dynamical activity. *)
(* \[Nu] = {1,-1,0,0,...} might yield some particle current (depending on the dissipators) *)
Clear[IntegratedCurrentfromJumps];
IntegratedCurrentfromJumps[\[Nu]_,jumpList_,step_:100,times_:None]:=Module[{JLtyped,max,\[CapitalDelta]t,newTimes,intCurrent},
\[CapitalDelta]t = Which[
ArrayQ[times],times[[2]]-times[[1]],
NumberQ[times],times,
True,1
];
JLtyped = #[[All,1]]&/@GatherBy[jumpList,Last];
max = Max[jumpList[[All,1]]];

newTimes =\[CapitalDelta]t Most@Range[0,max,step];
intCurrent=Total@Table[
\[Nu][[k]]Accumulate@BinCounts[JLtyped[[k]],{0,max,step}]
,{k,Length@\[Nu]}];
Transpose[{newTimes,intCurrent}]
]


(* ::Input::Initialization:: *)
Clear[QuantumJumpUnravelling];
QuantumJumpUnravelling[H_,cops_,\[Psi]0_,ts_,seed_:0,onlyJumps_:False]:=Module[{c,r,\[CapitalDelta]t,npts,ncops = Length@cops,He,\[Psi],\[ScriptCapitalU],states,jump,jumpList,dyna,n,ss},
If[Not[seed===0],SeedRandom[seed]];
\[CapitalDelta]t = ts[[2]]-ts[[1]];
npts=Length[ts]-1;
r = RandomReal[{0,1},npts];
He = H - I/2 Sum[c\[ConjugateTranspose] . c,{c,cops}]//Normal;
\[ScriptCapitalU] = Eye[Length@He]-I He \[CapitalDelta]t-(He . He \[CapitalDelta]t^2)/2+1/6 I He . He . He \[CapitalDelta]t^3+(He . He . He . He \[CapitalDelta]t^4)/24; 
\[Psi] = N@\[Psi]0;
jumpList = {};
states = {};
n=1;
While[n<npts,
(ss=NestWhileList[\[ScriptCapitalU] . #&,\[Psi],Norm[#]^2>r[[n]]&,1,npts-n+1];
If[onlyJumps===False,AppendTo[states,Normalize/@ss]];
\[Psi] = ss[[-1]];
n = n + Length@ss;
jump=If[ncops==1,1,RandomChoice[Table[Re[\[Psi]\[Conjugate] . c\[ConjugateTranspose] . c . \[Psi]],{c,cops}]->Range[1,ncops]]];
If[n<=npts,AppendTo[jumpList,{n-1, jump}]];
\[Psi] = cops[[jump]] . ss[[-1]];
\[Psi] = \[Psi]/Norm[\[Psi]];
{states})];
(*jumpList*)

If[onlyJumps===False,{Flatten[states,1],jumpList},jumpList]

]


(* ::Input::Initialization:: *)
Clear[QuantumJumpUnravellingMixedStates];
QuantumJumpUnravellingMixedStates[H_,cops_,sops_,\[Rho]0_,ts_,seed_:0,onlyJumps_:False]:=Module[{r,\[CapitalDelta]t,npts,ncops = Length@cops,He,\[Rho],\[ScriptCapitalV],states,jump,jumpList,dyna,n,ss,\[ScriptCapitalL],\[ScriptCapitalJ],\[ScriptCapitalL]0},
If[seed!=0,SeedRandom[seed]];
\[CapitalDelta]t = ts[[2]]-ts[[1]];
npts=Length[ts]-1;
r = RandomReal[{0,1},npts];

\[ScriptCapitalL] = Liouvillian[H,Join[cops,sops]];
\[ScriptCapitalJ] = Table[JumpOp[c],{c,cops}];
\[ScriptCapitalL]0 = \[ScriptCapitalL]-Total@\[ScriptCapitalJ];
\[ScriptCapitalV] =NEye[\[ScriptCapitalL]0]+ \[ScriptCapitalL]0 \[CapitalDelta]t+(\[ScriptCapitalL]0 . \[ScriptCapitalL]0 \[CapitalDelta]t^2)/2+1/6  \[ScriptCapitalL]0 . \[ScriptCapitalL]0 . \[ScriptCapitalL]0 \[CapitalDelta]t^3+(\[ScriptCapitalL]0 . \[ScriptCapitalL]0 . \[ScriptCapitalL]0 . \[ScriptCapitalL]0 \[CapitalDelta]t^4)/24; 
\[Rho] = N@Normal@Vec@\[Rho]0;
jumpList = {};
states = {};
n=1;

While[n<npts,
ss=NestWhileList[\[ScriptCapitalV] . #&,\[Rho],UnTr[#]>r[[n]]&,1,npts-n+1];
If[onlyJumps===False,AppendTo[states,#/UnTr[#]&/@ss]];
\[Rho] = ss[[-1]];
n = n + Length@ss;
jump=If[ncops==1,1,RandomChoice[Table[Re@UnTr[j . \[Rho]],{j,\[ScriptCapitalJ]}]->Range[1,ncops]]];
If[n<=npts,AppendTo[jumpList,{n-1, jump}]];
\[Rho] = \[ScriptCapitalJ][[jump]] . ss[[-1]];
\[Rho] = \[Rho]/UnTr[\[Rho]];

{states}];

If[onlyJumps===False,{Unvec/@Flatten[states,1],jumpList},jumpList]

]


(* ::Input::Initialization:: *)
Clear[QuantumJumpGillespie];
QuantumJumpGillespie[H_,M_,\[Psi]0_,ts_,njumps_,seed_:0,onlyJumps_:True]:=Module[{v,He,\[ScriptCapitalJ],Qs,\[Psi],\[Tau],Ps,norm,V,tr,T,weights,k,cr,tab},
If[seed!=0,SeedRandom[seed]];
\[ScriptCapitalJ] = Sum[c\[ConjugateTranspose] . c,{c,M}];
He = H - I/2 \[ScriptCapitalJ];

tr = Range[1,Length@ts];
cr = Range[1,Length@M];
V = Table[MatrixExp[-I He t],{t,ts}];
Qs = Table[ v\[ConjugateTranspose] . \[ScriptCapitalJ] . v,{v,V}];
norm = Norm[Qs[[-1]]];

\[Psi] = Normal@\[Psi]0;
\[Tau]= 0;
tab=Table[
Ps = Table[\[Psi]\[Conjugate] . Q . \[Psi],{Q,Qs}]//Chop;
T = SillySample[tr,Ps];
\[Tau] = \[Tau] + ts[[T]];
\[Psi] = V[[T]] . \[Psi];
weights = Table[\[Psi]\[Conjugate] . c\[ConjugateTranspose] . c . \[Psi],{c,M}]//Chop;
k=RandomChoice[weights->cr];
\[Psi] = M[[k]] . \[Psi];
\[Psi] = \[Psi]/Norm[\[Psi]];
{\[Tau],k,\[Psi]},{n,njumps}];

If[onlyJumps===True,tab[[All,{1,2}]],tab]

]


(* ::Input::Initialization:: *)
(* Assumes it is a renewal process *)
Clear[QuantumJumpGillespieRenewal];
QuantumJumpGillespieRenewal[H_,cops_,\[Psi]0_,ts_,njumps_]:=Module[{He,\[ScriptCapitalJ],Qs,V,\[Psi],\[Tau],Ps,norm,Vs,tr,\[Delta]\[Tau]r,weights,jump,cr,tab,\[Delta]\[Tau]rs},

\[ScriptCapitalJ] = Sum[c\[ConjugateTranspose] . c,{c,cops}];
He = H - I/2 \[ScriptCapitalJ];

tr = Range[1,Length@ts];
cr = Range[1,Length@cops];
Vs = Table[MatrixExp[-I He t],{t,ts}];
Qs = Table[ V\[ConjugateTranspose] . \[ScriptCapitalJ] . V,{V,Vs}];
norm = Norm[Qs[[-1]]];

Do[
\[Psi] = cops[[c]] . RandomReal[{0,1},Length@\[Psi]0];
\[Psi] = \[Psi]/Norm[\[Psi]];
Ps[c] = Table[\[Psi]\[Conjugate] . Q . \[Psi],{Q,Qs}]//Chop;
\[Delta]\[Tau]rs[c] = SillySample[tr,Ps[c],njumps];
,{c,cr}];

\[Tau]= 0;
jump = 1;
\[Psi] = cops[[jump]] . RandomReal[{0,1},Length@\[Psi]0];
\[Psi] = \[Psi]/Norm[\[Psi]];
tab=Table[
(*\[Delta]\[Tau]r = SillySample[Ps[jump],tr];*)
\[Delta]\[Tau]r = \[Delta]\[Tau]rs[jump][[n]];
\[Tau] = \[Tau] + ts[[\[Delta]\[Tau]r]];
\[Psi] = Vs[[\[Delta]\[Tau]r]] . \[Psi];
weights = Table[\[Psi]\[Conjugate] . c\[ConjugateTranspose] . c . \[Psi],{c,cops}]//Chop;

jump=RandomChoice[weights->cr];
\[Psi] = cops[[jump]] . \[Psi];
\[Psi] = \[Psi]/Norm[\[Psi]];
{\[Tau],jump},{n,njumps}];

(*{tab,norm,He}*)
tab

]


(* ::Input::Initialization:: *)
(* UNTESTED *)
Clear[QuantumJumpGillespieMixedStates];
QuantumJumpGillespieMixedStates[H_,cops_,sops_,\[Rho]0_,\[CapitalDelta]t_,tf_,njumps_,seed_:0,onlyJumps_:True]:=Module[{v,He,\[ScriptCapitalJ],Qs,\[Psi],\[Tau],Ps,norm,V,tr,T,weights,k,cr,tab,ts,\[ScriptCapitalL],\[ScriptCapitalL]0,y,\[Rho],\[ScriptCapitalJ]s},
If[seed!=0,SeedRandom[seed]];

cr = Range[1,Length@cops];
\[ScriptCapitalL] = Liouvillian[H,Join[cops,sops]];
\[ScriptCapitalJ]s = Table[JumpOp[c],{c,cops}];
\[ScriptCapitalJ] = Sum[JumpOp[c],{c,cops}];
\[ScriptCapitalL]0 = \[ScriptCapitalL]-\[ScriptCapitalJ];

ts = Range[0,tf,\[CapitalDelta]t];
tr = Range[1,Length@ts];
v = MatrixExp[\[ScriptCapitalL]0 \[CapitalDelta]t];
y = NEye[\[ScriptCapitalL]0];
V = Prepend[Table[y = v . y,{Length@ts-1}],NEye[\[ScriptCapitalL]0]];
Qs = Table[\[ScriptCapitalJ] . v,{v,V}];

norm = Norm[Qs[[-1]]];

\[Rho] = Vec@Normal@\[Rho]0;
\[Tau]= 0;
tab=Table[
Ps = Table[UnTr[Q . \[Rho]],{Q,Qs}]//Chop;
T = SillySample[tr,Ps];
\[Tau] = \[Tau] + ts[[T]];
\[Rho] = V[[T]] . \[Rho];
weights = Table[UnTr[j . \[Rho]],{j,\[ScriptCapitalJ]s}]//Chop;
k=RandomChoice[weights->cr];
\[Rho] = \[ScriptCapitalJ]s[[k]] . \[Rho];
\[Rho] = \[Rho]/UnTr[\[Rho]];
{\[Tau],k,\[Rho]},{n,njumps}];

{norm,If[onlyJumps===True,tab[[All,{1,2}]],tab]}

]


(* ::Input::Initialization:: *)
Clear[QuantumDiffusion]
QuantumDiffusion[y0_,H_,ccops_,dt_,tf_,ssops_:None,seed_:0,func_:None,quiet_:False]:=Module[{n,sops,nsteps,S,\[Rho],\[Psi],dW,M,xave,dY,tab,\[DoubleStruckCapitalI],M0,x,c2,xs,c2s,dc,tr,cops,\[CapitalUpsilon],f,ff},
(* cops are monitored. sops are not *)
If[seed!=0,SeedRandom[seed]];
cops = If[Length@Dimensions[ccops]===2,{ccops},ccops];
dc = Length@cops;

sops = If[ssops===None,
{ConstantArray[0,{Length@H,Length@H}]},
If[Length@Dimensions[sops]===2,
{ssops},
ssops]];

nsteps = Round[tf/dt];
S= Association[];
If[func===None,f[\[Psi]_]:=1,f[\[Psi]_]:=func[\[Psi]]];

S["dt"]=dt;
S["tf"]=tf;
S["nsteps"]=nsteps;
\[DoubleStruckCapitalI] = NEye[Length@H];
M0 = \[DoubleStruckCapitalI] - (I H + 1/2 Sum[c\[ConjugateTranspose] . c,{c,cops}] + 1/2 Sum[c\[ConjugateTranspose] . c,{c,sops}])dt;
dW = RandomVariate[NormalDistribution[0,Sqrt[dt]],{nsteps,dc}];
xs = Table[c + c\[ConjugateTranspose],{c,cops}];
c2s = Table[c1 . c2,{c1,cops},{c2,cops}];
tr = Sum[c . c,{c,cops}];

If[quiet==False,

If[MatrixQ[y0]||Not[sops===None],
(\[Rho] = If[MatrixQ[y0],y0,out[y0,y0]];
tab=table[
ff=f[\[Rho]];
xave = Table[Tr[x . \[Rho]],{x,xs}];
dY = xave dt + dW[[n]]; 

\[CapitalUpsilon] = dY . cops;
M = M0 + \[CapitalUpsilon] + 1/2 (\[CapitalUpsilon] . \[CapitalUpsilon]-dt tr);
\[Rho] = M . \[Rho] . M\[ConjugateTranspose] + dt Sum[c . \[Rho] . c\[ConjugateTranspose],{c,sops}];
\[Rho] = \[Rho]/Tr[\[Rho]];
{\[Rho],dY,xave,ff},{n,nsteps}];
),
(\[Psi] = y0;
tab=table[
ff=f[\[Psi]];
xave = Table[\[Psi]\[Conjugate] . x . \[Psi],{x,xs}];
dY = xave dt + dW[[n]]; 

\[CapitalUpsilon] = dY . cops;
M = M0 + \[CapitalUpsilon] + 1/2 (\[CapitalUpsilon] . \[CapitalUpsilon]-dt tr);
\[Psi] = M . \[Psi]//Normalize;
{\[Psi],dY,xave,ff},{n,nsteps}]
)],

If[MatrixQ[y0]||Not[sops===None],
(\[Rho] = If[MatrixQ[y0],y0,out[y0,y0]];
tab=Table[
ff=f[\[Rho]];
xave = Table[Tr[x . \[Rho]],{x,xs}];
dY = xave dt + dW[[n]]; 

\[CapitalUpsilon] = dY . cops;
M = M0 + \[CapitalUpsilon] + 1/2 (\[CapitalUpsilon] . \[CapitalUpsilon]-dt tr);
\[Rho] = M . \[Rho] . M\[ConjugateTranspose] + dt Sum[c . \[Rho] . c\[ConjugateTranspose],{c,sops}];
\[Rho] = \[Rho]/Tr[\[Rho]];
{\[Rho],dY,xave,ff},{n,nsteps}];
),
(\[Psi] = y0;
tab=Table[
ff=f[\[Psi]];
xave = Table[\[Psi]\[Conjugate] . x . \[Psi],{x,xs}];
dY = xave dt + dW[[n]]; 

\[CapitalUpsilon] = dY . cops;
M = M0 + \[CapitalUpsilon] + 1/2 (\[CapitalUpsilon] . \[CapitalUpsilon]-dt tr);
\[Psi] = M . \[Psi]//Normalize;
{\[Psi],dY,xave,ff},{n,nsteps}]
)]];

S["state"]=tab[[All,1]]//Chop;
S["I"]=If[Length@Dimensions@ccops==3,tab[[All,2]],Flatten[tab[[All,2]]]]/dt//Chop;
S["xave"]=If[Length@Dimensions@ccops==3,tab[[All,3]],Flatten[tab[[All,3]]]]//Chop;
S["f"]=If[Length@Dimensions@ccops==3,tab[[All,4]],Flatten[tab[[All,4]]]]//Chop;
S
]


(* ::Input::Initialization:: *)
Clear[QuantumDiffusionBasic];
QuantumDiffusionBasic[\[Rho]0_,\[ScriptCapitalL]_,c_,dt_,tf_]:=Module[{\[Rho],x,ts,nsteps,\[ScriptCapitalX],cd,dW,xave,dI,\[ScriptCapitalJ]},
x = c + c\[ConjugateTranspose];
ts = Range[dt,tf,dt];
nsteps = Length@ts;
dW = RandomVariate[NormalDistribution[0,Sqrt[dt]],nsteps];
\[ScriptCapitalX] = (Vec@x)\[ConjugateTranspose];
cd = c\[ConjugateTranspose];
\[Rho] = Vec@\[Rho]0;
\[ScriptCapitalJ] = JumpOp[c,"diffusion"];
Table[
xave = \[ScriptCapitalX] . \[Rho];
\[Rho] = \[Rho]+ dt \[ScriptCapitalL] . \[Rho] + dW[[n]] (\[ScriptCapitalJ] . \[Rho]-\[Rho] xave);
{Unvec@\[Rho],{ts[[n]],xave},{ts[[n]],xave+dW[[n]]/dt}},
{n,2,Length@ts}
]\[Transpose]
]


(* ::Input::Initialization:: *)
Clear[QuantumDiffusionFilteredGaussianMeasurements];
QuantumDiffusionFilteredGaussianMeasurements[\[Rho]0_,\[ScriptCapitalL]_,Y_,\[Lambda]_,dt_,tf_,func_:None,\[Gamma]_:\[Infinity]]:=Module[{f,\[ScriptCapitalV],\[Rho],nsteps,dW,\[Zeta],\[ScriptCapitalD],\[ScriptCapitalC],\[Lambda]dt,\[Chi],\[DoubleStruckCapitalD],yvals,S,\[ScriptCapitalE],z,d,j,\[ScriptCapitalY],\[ScriptCapitalF],yave},
\[ScriptCapitalV] = MatrixExp[\[ScriptCapitalL] dt];
\[Rho] = Vec@\[Rho]0;
nsteps = Round[tf/dt];
dW = RandomVariate[NormalDistribution[0,Sqrt[dt]],nsteps];
\[Zeta] = ConstantArray[0,nsteps];
\[ScriptCapitalD] = ConstantArray[0,nsteps];
\[ScriptCapitalY] = ConstantArray[0,nsteps];
\[ScriptCapitalF] = ConstantArray[0,nsteps];
\[ScriptCapitalC] = ((2\[Lambda] dt)/\[Pi])^(1/2);
\[Lambda]dt = \[Lambda] dt;

If[\[Gamma] ===\[Infinity],\[DoubleStruckCapitalD][\[Zeta]_,j_]:=\[Zeta][[j]],
(
\[Chi] = Reverse@Chop@Table[\[Gamma] dt E^(-k \[Gamma] dt),{k,0,nsteps}];
\[DoubleStruckCapitalD][\[Zeta]_,j_]:=\[Chi][[nsteps-j+1;;nsteps]] . \[Zeta][[1;;j]];
)];

Which[
func===None,f[\[Rho]_]:=1,
func===All,f[\[Rho]_]:=\[Rho],
True,f[\[Rho]_]:=func[\[Rho]]
];

{yvals,S} = Eigsys[Y];
\[ScriptCapitalE][z_,\[Rho]_]:=With[{\[CapitalLambda]=DiagonalMatrix@Table[E^(-\[Lambda]dt (z-y)^2),{y,yvals}]},
\[ScriptCapitalC] S . \[CapitalLambda] . S\[ConjugateTranspose] . Unvec[\[Rho]] . S . \[CapitalLambda] . S\[ConjugateTranspose]//Vec];

Do[
\[Rho] = \[ScriptCapitalV] . \[Rho];
yave = Tr[Unvec[\[Rho]] . Y];
z =yave  + 1/(2Sqrt[\[Lambda]]) dW[[j]]/dt//Chop;
d = \[DoubleStruckCapitalD][\[Zeta],j];
\[Rho] = \[ScriptCapitalE][z,\[Rho]];
\[Rho] = \[Rho]/UnTr[\[Rho]];

\[Zeta][[j]]=z;
\[ScriptCapitalD][[j]]=d;
\[ScriptCapitalY][[j]]=yave;
\[ScriptCapitalF][[j]]=f[Unvec@\[Rho]];
,{j,nsteps}
];
If[func===None,
{\[Zeta],\[ScriptCapitalD],\[ScriptCapitalY]},
{\[Zeta],\[ScriptCapitalD],\[ScriptCapitalY],\[ScriptCapitalF]}
]
]


(* ::Input::Initialization:: *)
Clear[KerrPsi];
KerrPsi[nmax_,\[CapitalDelta]_,G_,U_,\[Kappa]_,\[Epsilon]_,\[Kappa]2_,normalize_:True]:=Module[{\[Alpha],n,tol=10^-14.,\[Psi]},
\[Psi]=Which[
Abs[G]<tol&&Abs[\[Epsilon]]<tol,Normal@Eye[nmax][[1]],
Abs[G]<tol&&Abs[\[Epsilon]]>tol,Prepend[Chop@RecurrenceTable[{
((U-I \[Kappa]2) n -(2\[CapitalDelta] + I \[Kappa]) )Sqrt[n+1]\[Alpha][n+1]+2Sqrt[2]\[Epsilon] \[Alpha][n]==0,
\[Alpha][0]==1
},\[Alpha]
,{n,1,nmax-1}],1],
Abs[G]>tol,Prepend[Chop@RecurrenceTable[{
((U-I \[Kappa]2) n -(2\[CapitalDelta] + I \[Kappa]) )Sqrt[n+1]\[Alpha][n+1]+2 G Sqrt[n]\[Alpha][n-1]+2Sqrt[2]\[Epsilon] \[Alpha][n]==0,
\[Alpha][0]==1,\[Alpha][-1]==0
},\[Alpha]
,{n,1,nmax-1}],1]
];
If[normalize===True,Normalize@\[Psi],\[Psi]]
]


(* ::Input::Initialization:: *)
(* \[LeftAngleBracket]a\[RightAngleBracket] *)
Clear[KerrA];
KerrA[nmax_,\[CapitalDelta]_,G_,U_,\[Kappa]_,\[Epsilon]_,\[Kappa]2_]:=Module[{\[Psi]},
\[Psi] = KerrPsi[nmax,\[CapitalDelta],G,U,\[Kappa],\[Epsilon],\[Kappa]2];
1/Sqrt[2] \[Psi][[1;;-2]]\[Conjugate] . (Sqrt[Range[1,nmax-1]]\[Psi][[2;;-1]])//Chop
]


(* ::Input::Initialization:: *)
(* \[LeftAngleBracket]a\[ConjugateTranspose]a\[RightAngleBracket] *)
Clear[KerrAda];
KerrAda[nmax_,\[CapitalDelta]_,G_,U_,\[Kappa]_,\[Epsilon]_,\[Kappa]2_]:=Module[{\[Psi]},
\[Psi] = KerrPsi[nmax,\[CapitalDelta],G,U,\[Kappa],\[Epsilon],\[Kappa]2];
1/2 \[Psi]\[Conjugate] . (Range[0,nmax-1] \[Psi])//Chop
]


(* ::Input::Initialization:: *)
(* Auxiliary matrix necessary to compute \[Rho] *)
Clear[KerrB];
KerrB[nmax_]:= N@Table[1/2^((k+j)/2) Sqrt[Binomial[k+j,j]],{k,0,nmax-1},{j,0,nmax-1}];


(* ::Input::Initialization:: *)
(* \[Rho] steady-state *)
Clear[KerrRho];
KerrRho[B_,\[CapitalDelta]_,G_,U_,\[Kappa]_,\[Epsilon]_,\[Kappa]2_]:=Module[{nmax=Length@B,\[Psi],S,A},
\[Psi] = KerrPsi[2nmax,\[CapitalDelta],G,U,\[Kappa],\[Epsilon],\[Kappa]2];
(*\[Alpha] = Join[\[Psi],ConstantArray[0,nmax]];*)
A = Table[\[Psi][[k+j-1]],{k,1,nmax},{j,1,nmax}];
S = A B;
S . S\[ConjugateTranspose]
]


(* ::Input::Initialization:: *)
(* Computes \!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Theta]\)]\[Psi]\) where \[Theta] can be any of the parameters \[CapitalDelta],G,U,\[Kappa],\[Epsilon],\[Kappa]2 and \[Psi] === Subscript[\[Psi], +] is the CQA pure state *)
Clear[KerrPsiPrime]
KerrPsiPrime[para_,nmax_,\[CapitalDelta]_,G_,U_,\[Kappa]_,\[Epsilon]_,\[Kappa]2_]:=Module[{\[ScriptCapitalD],tol=10^-14.,n,\[Alpha],\[Psi]t,\[Phi]t,\[Psi]0,\[Phi]0,\[Phi],\[CapitalPsi],\[CapitalPhi],A,Ap,S,Sp,\[Psi],tmp,\[Psi]tt},
\[Psi]t = KerrPsi[nmax,\[CapitalDelta],G,U,\[Kappa],\[Epsilon],\[Kappa]2,False]; (*unnormalized solution; starting at 0*)
\[Psi]tt = \[Psi]t[[2;;-1]] (* Starting at Subscript[\[Psi], 1] *);
\[Psi]0 = 1/Sqrt[1+\[Psi]tt\[Conjugate] . \[Psi]tt];
\[Psi] = Normalize@\[Psi]t;

(* Here n = 0,1,2,... *);
Clear[\[ScriptCapitalD]];
Which[
para==="\[CapitalDelta]",
Do[\[ScriptCapitalD][n]=-2 Sqrt[n+1] \[Psi]t[[n+2]](*\[Psi][n+1]*),{n,0,nmax-2}],
para==="G",
Do[\[ScriptCapitalD][n]=If[n===0,0,2Sqrt[n]\[Psi]t[[n]]](*\[Psi][n-1]*),{n,0,nmax}],
para==="U",
Do[\[ScriptCapitalD][n]= n Sqrt[n+1] \[Psi]t[[n+2]](*\[Psi][n+1]*),{n,0,nmax-2}],
para==="\[Kappa]",
Do[\[ScriptCapitalD][n]=-I Sqrt[n+1] \[Psi]t[[n+2]](*\[Psi][n+1]*),{n,0,nmax-2}],
para==="\[Epsilon]",
Do[\[ScriptCapitalD][n]=2Sqrt[2]\[Psi]t[[n+1]](*\[Psi][n]*),{n,0,nmax-1}],
para==="\[Kappa]2",
Do[\[ScriptCapitalD][n]=-I n Sqrt[n+1] \[Psi]t[[n+2]](*\[Psi][n+1]*),{0,nmax-2}]
];

(* Starting at Subscript[Overscript[\[Phi], ~], 1] *);
\[Phi]t = Which[
Abs[G]<tol&&Abs[\[Epsilon]]<tol,0 Normal@Eye[nmax-1][[1]],
Abs[G]<tol&&Abs[\[Epsilon]]>tol,Chop@RecurrenceTable[{
((U-I \[Kappa]2) n -(2\[CapitalDelta] + I \[Kappa]) )Sqrt[n+1]\[Alpha][n+1]+2Sqrt[2]\[Epsilon] \[Alpha][n]==-\[ScriptCapitalD][n],
\[Alpha][0]==0
},\[Alpha]
,{n,1,nmax-1}],
Abs[G]>tol,Chop@RecurrenceTable[{
((U-I \[Kappa]2) n -(2\[CapitalDelta] + I \[Kappa]) )Sqrt[n+1]\[Alpha][n+1]+2 G Sqrt[n]\[Alpha][n-1]+2Sqrt[2]\[Epsilon] \[Alpha][n]==-\[ScriptCapitalD][n],
\[Alpha][0]==0,\[Alpha][-1]==0
},\[Alpha]
,{n,1,nmax-1}]
];

\[Phi]0 = -(\[Psi]0^3/2)(\[Phi]t\[Conjugate] . \[Psi]tt+\[Psi]tt\[Conjugate] . \[Phi]t);
\[Phi] =Prepend[ \[Phi]t \[Psi]0 + \[Psi]tt \[Phi]0,\[Phi]0];

{\[Psi],\[Phi]}
]


(* ::Input::Initialization:: *)
(* Computes \!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Theta]\)]\[Rho]\) where \[Theta] can be any of the parameters \[CapitalDelta],G,U,\[Kappa],\[Epsilon],\[Kappa]2 *)
Clear[KerrRhoPrime]
KerrRhoPrime[para_,B_,\[CapitalDelta]_,G_,U_,\[Kappa]_,\[Epsilon]_,\[Kappa]2_]:=Module[{nmax=Length@B,\[Psi],\[Phi],A,Ap,S,Sp},
{\[Psi],\[Phi]} = KerrPsiPrime[para,2nmax,\[CapitalDelta],G,U,\[Kappa],\[Epsilon],\[Kappa]2];

A = Table[\[Psi][[k+j-1]],{k,1,nmax},{j,1,nmax}];
S = A B;

Ap = Table[\[Phi][[k+j-1]],{k,1,nmax},{j,1,nmax}];
Sp = Ap B;

{S,S . S\[ConjugateTranspose],Sp . S\[ConjugateTranspose]+S . Sp\[ConjugateTranspose]}

]


(* ::Input::Initialization:: *)
(* Fisher information contained in the coherent quantum absorber *)
Clear[KerrCQAFisherInformation]
KerrCQAFisherInformation[para_,nmax_,\[CapitalDelta]_,G_,U_,\[Kappa]_,\[Epsilon]_,\[Kappa]2_]:=Module[{\[Psi],\[Phi]},
{\[Psi],\[Phi]} = KerrPsiPrime[para,nmax,\[CapitalDelta],G,U,\[Kappa],\[Epsilon],\[Kappa]2];
4 (\[Phi]\[Conjugate] . \[Phi] + (\[Phi]\[Conjugate] . \[Psi])^2)//Chop
]


(* ::Input::Initialization:: *)
(* Fisher information in the steady-state \[Rho] of the CQA *)
Clear[KerrFisherInformation]
KerrFisherInformation[para_,B_,\[CapitalDelta]_,G_,U_,\[Kappa]_,\[Epsilon]_,\[Kappa]2_]:=Module[{nmax=Length@B,S,\[Rho],d\[Rho]},
{S,\[Rho],d\[Rho]} = KerrRhoPrime[para,B,\[CapitalDelta],G,U,\[Kappa],\[Epsilon],\[Kappa]2];
QuantumFisherInformation[\[Rho],d\[Rho]]
]


(* ::Input::Initialization:: *)
(* Symmetric logarithmic derivative of the steady-state \[Rho] of the CQA *)
Clear[KerrSLD]
KerrSLD[para_,B_,\[CapitalDelta]_,G_,U_,\[Kappa]_,\[Epsilon]_,\[Kappa]2_]:=Module[{nmax=Length@B,S,\[Rho],d\[Rho],\[CapitalLambda]},
{S,\[Rho],d\[Rho]} = KerrRhoPrime[para,B,\[CapitalDelta],G,U,\[Kappa],\[Epsilon],\[Kappa]2];
\[CapitalLambda]=SymmetricLogarithmicDerivative[\[Rho],d\[Rho]];
{\[CapitalLambda],Tr[\[CapitalLambda] . \[CapitalLambda] . \[Rho]]//Chop}
]


(* ::Input::Initialization:: *)
RandomHMM[dh_,da_]:=Module[{x,\[Sigma]1,\[Sigma]0,P,Ms,norm,Q,pss,u},

Do[
P[x,\[Sigma]1][\[Sigma]0] = RandomReal[{0,1}],
{x,da},{\[Sigma]1,dh},{\[Sigma]0,dh}];

Do[
norm = Total@Flatten@Table[P[x,\[Sigma]1][\[Sigma]0],{x,da},{\[Sigma]1,dh}];
Do[P[x,\[Sigma]1][\[Sigma]0]=P[x,\[Sigma]1][\[Sigma]0]/norm,{x,da},{\[Sigma]1,dh}]
,{\[Sigma]0,dh}
];

Ms = Table[Table[P[x,\[Sigma]1][\[Sigma]0],{\[Sigma]1,dh},{\[Sigma]0,dh}],{x,da}];
Q = Table[Sum[P[x,\[Sigma]1][\[Sigma]0],{x,da}],{\[Sigma]1,dh},{\[Sigma]0,dh}];
u = ConstantArray[1,Length@Q];
pss = AnalyticalSteadyState[Q-Eye[Q],u];

{P,Ms,Q,pss,u}
]


(* ::Input::Initialization:: *)
(* Assumes Subscript[\[Nu], k] = \[PlusMinus] 1 *)
Clear[ChargeResolvedJumpDynamics];
ChargeResolvedJumpDynamics[ts_,a_,b_,rho0_,H_,Ls_,\[Nu]s_]:=Module[{dt,r,d,He,L,\[DoubleStruckCapitalI],M,Ns,nl,\[DoubleStruckCapitalZ],\[Rho],zpos,\[ScriptCapitalI],band,\[ScriptCapitalV],Ip,max\[Nu],t,d2,comp,pos,\[Rho]0,\[Rho]2,\[ScriptCapitalV]p,stepprint,\[ScriptCapitalL]0,P,G,f},

r = Length@Ls;
d = Length@First@Ls;
d2 = d^2;
\[DoubleStruckCapitalI] = Eye[d];

max\[Nu] = Max@Abs@\[Nu]s;
He = H - I/2 Sum[L\[ConjugateTranspose] . L,{L,Ls}] ;
\[ScriptCapitalL]0 = kron[\[DoubleStruckCapitalI],-I He]+kron[I He\[Conjugate],\[DoubleStruckCapitalI]];

Ns = Range[a,b,1];
nl = Length@Ns;

\[DoubleStruckCapitalZ] = Vec@ConstantArray[0,{d,d}];
\[Rho]0 = Table[\[DoubleStruckCapitalZ],{i,nl}];
zpos = Position[Ns,0][[1,1]];
\[Rho]0[[zpos]] = Normal@Vec@rho0;
\[Rho]0 = Flatten@\[Rho]0;

\[ScriptCapitalI] = Eye[nl];
band[\[Nu]_,L_]:=DiagonalMatrix[ConstantArray[1,L-Abs@\[Nu]],\[Nu]];
\[ScriptCapitalV] = kron[\[ScriptCapitalI],\[ScriptCapitalL]0]+Sum[kron[band[-\[Nu]s[[k]],nl],JumpOp[Ls[[k]]]],{k,r}]//SparseArray;
dt = If[Length@ts===0,ts,First@Differences@ts];
\[ScriptCapitalV]p = MatrixExp[\[ScriptCapitalV] dt];
\[Rho] = \[Rho]0;

P=Table[
\[Rho] = \[ScriptCapitalV]p . \[Rho];
{Ns,Chop@Table[UnTr[Partition[\[Rho],d2][[i]]],{i,1,nl}]}\[Transpose]
,{Flatten@{ts}}];
If[Length@ts===0,P[[1]],
(
PrependTo[P,{Ns,Chop@Table[UnTr[Partition[\[Rho]0,d2][[i]]],{i,1,nl}]}\[Transpose]];
G=Table[ Total@P[[i,All,2]],{i,Length@P}];
f= - Table[(G[[i+1]]-G[[i-1]])/(2dt),{i,2,Length@G-1}];
{P,{Prepend[ts,0],G}\[Transpose],{Drop[ts,-1],f}\[Transpose]}
)]
]


(* ::Input::Initialization:: *)
(* H can also be the Liouvillian *)
Clear[ChargeResolvedDiffusiveDynamics];
ChargeResolvedDiffusiveDynamics[ts_,a_,b_,\[CapitalDelta]n_,rho0_,H_,Ls_,\[Nu]s_:1]:=Module[{r,Kd,\[ScriptCapitalK],Ns,nl,d,zpos,\[Rho]0,\[Rho],\[DoubleStruckCapitalZ],t,\[ScriptCapitalI],\[ScriptCapitalV],\[ScriptCapitalV]p,\[ScriptCapitalL] ,P,G,f,dt},
r = Length@Ls;
d = Length@First@Ls;

\[ScriptCapitalL] = If[Length@H===d,Liouvillian[H,Ls],H](* nasty trick to include the possibility that H is actually the vectorized Liouvillian, not the Hamiltonian *);

Kd = If[\[Nu]s===1,r,Total[\[Nu]s^2] ];

\[ScriptCapitalK] = If[\[Nu]s===1,
Sum[JumpOp[L,"diffusion"],{L,Ls}],
Sum[\[Nu]s[[i]]JumpOp[Ls[[i]],"diffusion"],{i,r}]
];

Ns = N@Chop@Range[a,b,\[CapitalDelta]n];
nl = Length@Ns;
zpos = Position[Ns,0.][[1,1]];

\[DoubleStruckCapitalZ] = Vec@ConstantArray[0,{d,d}];
\[Rho]0 = Table[\[DoubleStruckCapitalZ],{i,nl}];
\[Rho]0[[zpos]] = 1/\[CapitalDelta]n Normal@Vec@rho0;

(* Big matrix *)
\[ScriptCapitalV] = kron[Eye[nl],\[ScriptCapitalL]] - kron[FirstDerivative[nl,\[CapitalDelta]n],\[ScriptCapitalK]] + Kd/2 kron[SecondDerivative[nl,\[CapitalDelta]n],Eye[\[ScriptCapitalL]]];
\[ScriptCapitalI] = NEye[\[ScriptCapitalV]];
dt = If[Length@ts===0,ts,First@Differences@ts];

(* Euler propagator *)
(*\[ScriptCapitalV]p = \[ScriptCapitalI] + \[ScriptCapitalI].\[ScriptCapitalV] dt;*)

(* RK4 propagator *)
\[ScriptCapitalV]p = \[ScriptCapitalI] + \[ScriptCapitalV] dt + \[ScriptCapitalV] . \[ScriptCapitalV] dt^2/2 + \[ScriptCapitalV] . \[ScriptCapitalV] . \[ScriptCapitalV] dt^3/6+\[ScriptCapitalV] . \[ScriptCapitalV] . \[ScriptCapitalV] . \[ScriptCapitalV] dt^4/24;
\[Rho] = Flatten@\[Rho]0;
P=Table[
\[Rho] = \[ScriptCapitalV]p . \[Rho];
{ Ns,Chop@Table[UnTr[Partition[\[Rho],d^2][[i]]],{i,1,nl}]}\[Transpose]
,{Flatten@{ts}}
];

PrependTo[P,{ Ns,Chop@Table[UnTr[Partition[Flatten@\[Rho]0,d^2][[i]]],{i,1,nl}]}\[Transpose]];
G=\[CapitalDelta]n Table[ Total@P[[i,All,2]],{i,Length@P}];
f= - Table[(G[[i+1]]-G[[i-1]])/(2dt),{i,2,Length@G-1}];
{P,{Prepend[ts,0],G}\[Transpose],{Drop[ts,-1],f}\[Transpose]}
]


(* ::Input::Initialization:: *)
(* Scaled Hermite polynomials *)
Clear[QFPMEHermiteHe];
QFPMEHermiteHe[n_,x_,\[Sigma]_]:=(\[Sigma]/2)^(n/2) HermiteH[n,x/Sqrt[2\[Sigma]]];

(* Reconstruct the full joint state from M list*)
Clear[QFPME\[Rho]D];
QFPME\[Rho]D[Ms_,\[Lambda]_,\[Gamma]_]:=Module[{\[Sigma] = \[Gamma]/(8\[Lambda])},Sum[Ms[[n+1]]  QFPMEHermiteHe[n,#,\[Sigma]]/Sqrt[\[Sigma]^n n!] E^(-#^2/(2\[Sigma]))/Sqrt[2\[Pi] \[Sigma]] ,{n,0,Length[Ms]-1}]&]

(* Probablity distribution for detector *)
Clear[QFPMEPD];
QFPMEPD[Ms_,\[Lambda]_,\[Gamma]_]:=Module[{\[Sigma] = \[Gamma]/(8\[Lambda])},Sum[Tr[Ms[[n+1]] ] QFPMEHermiteHe[n,#,\[Sigma]]/Sqrt[\[Sigma]^n n!] E^(-#^2/(2\[Sigma]))/Sqrt[2\[Pi] \[Sigma]] ,{n,0,Length[Ms]-1}]&]


(* ::Input::Initialization:: *)
Clear[QFPMElongvec,QFPMEunlongvec];
QFPMElongvec[x_]:=Flatten[Vec/@x];(* Converts Ms list to long vector *)
QFPMEunlongvec[x_,S_]:=Unvec/@Partition[x,S^2];(* Converts from long vector to list Ms *)


(* ::Input::Initialization:: *)
(* Full joing state using FFT reconstruction *)(* Unfinished!!! *)
Clear[QFPME\[Rho]DFFT];
QFPME\[Rho]DFFT[Ms_,\[Lambda]_,\[Gamma]_,dmin_,dmax_,Nd_]:=Module[{\[Sigma] = \[Gamma]/(8.\[Lambda]),f,dlist,\[CapitalDelta]d,\[CapitalDelta]t,tlist,flist,tmin},
\[CapitalDelta]d=N@((dmax-dmin)/(Nd-1));
dlist=Table[dmin+(j-1)\[CapitalDelta]d,{j,1,Nd}];
\[CapitalDelta]t=(2\[Pi])/((Nd-1)\[CapitalDelta]d);
tmin=-(((Nd-2)\[CapitalDelta]t)/2); (* Chosen symmetrically *)
tlist=Table[tmin+(n-1)\[CapitalDelta]t,{n,1,Nd}]; 

f[t_]= Exp[-((t^2 \[Sigma])/2)]Sum[Ms[[m+1]] ((I t)^m \[Sigma]^(m/2))/Sqrt[m!],{m,0,Length@Ms-1}];
flist=(f@tlist[[;;-2]])*Table[Exp[- I (n-1)\[CapitalDelta]t dmin],{n,1,Nd-1}];
Transpose@{dlist[[;;-2]],Re[(\[CapitalDelta]t/(2\[Pi]))(Nd-1)Exp[- I tmin dmin]Table[Exp[- I (j-1)\[CapitalDelta]d tmin],{j,1,Nd-1}]*Fourier[flist,FourierParameters->{-1,-1}]]}
]


(* ::Input::Initialization:: *)
(* Probablity distribution for detector using FFT reconstruction *)
Clear[QFPMEPDFFT];
QFPMEPDFFT[Ms_,\[Lambda]_,\[Gamma]_,dmin_,dmax_,Nd_]:=Module[{\[Sigma] = \[Gamma]/(8.\[Lambda]),cs,f,dlist,\[CapitalDelta]d,\[CapitalDelta]t,tlist,flist,tmin},
\[CapitalDelta]d=N@((dmax-dmin)/(Nd-1));
dlist=Table[dmin+(j-1)\[CapitalDelta]d,{j,1,Nd}];
\[CapitalDelta]t=(2\[Pi])/((Nd-1)\[CapitalDelta]d);
tmin=-(((Nd-2)\[CapitalDelta]t)/2); (* Chosen symmetrically *)
tlist=Table[tmin+(n-1)\[CapitalDelta]t,{n,1,Nd}]; 

cs=Tr/@Ms;
f[t_]= Exp[-((t^2 \[Sigma])/2)]Sum[cs[[m+1]] ((I t)^m \[Sigma]^(m/2))/Sqrt[m!],{m,0,Length@cs-1}];
flist=(f@tlist[[;;-2]])*Table[Exp[- I (n-1)\[CapitalDelta]t dmin],{n,1,Nd-1}];
Transpose@{dlist[[;;-2]],Re[(\[CapitalDelta]t/(2\[Pi]))(Nd-1)Exp[- I tmin dmin]Table[Exp[- I (j-1)\[CapitalDelta]d tmin],{j,1,Nd-1}]*Fourier[flist,FourierParameters->{-1,-1}]]}
]


(* ::Input::Initialization:: *)
Clear[QFPMEAlphaCoefficients];
QFPMEAlphaCoefficients[NN_,fs_,\[Sigma]_,intmax_:\[Infinity]]:=

Table[
NIntegrate[ (QFPMEHermiteHe[n,d,\[Sigma]] QFPMEHermiteHe[m,d,\[Sigma]])/(Sqrt[\[Sigma]^m m!] Sqrt[\[Sigma]^n n!]) E^(-(d^2/(2\[Sigma])))/Sqrt[2\[Pi] \[Sigma]] fs[[p]][d],{d,-intmax,intmax}],{n,0,NN-1},{m,0,NN-1},{p,1,Length@fs}]//Chop

Clear[QFPMEAlphaCoefficientsHeaviside]
QFPMEAlphaCoefficientsHeaviside[NN_]:=N@Table[Which[
n==m,1/2,
EvenQ[n+m],0,
OddQ[n+m],(-1)^((n+m-1)/2) (Factorial2[m]Factorial2[n-1])/(Sqrt[2\[Pi] n! m!](m-n))
],{n,0,NN-1},{m,0,NN-1}]

Clear[QFPMEAlphaCoefficientsLinear];
QFPMEAlphaCoefficientsLinear[NN_,\[Sigma]_]:=N@Sqrt[\[Sigma]]*Table[Sqrt[n+1]KroneckerDelta[n,m-1]+Sqrt[n]KroneckerDelta[n,m+1],{n,0,NN-1},{m,0,NN-1}]


(* ::Input::Initialization:: *)
(* Calculate full matrix, no feedback *)
Clear[QFPMENoFeedbackMatrix];
QFPMENoFeedbackMatrix[\[ScriptCapitalL]0_,A_,\[Lambda]_,\[Gamma]_,NN_]:=Module[{\[Sigma] = \[Gamma]/(8\[Lambda]),\[ScriptCapitalI]N,\[ScriptCapitalI]d,d,F,G,\[ScriptCapitalA],\[ScriptCapitalV]},
d = Length@\[ScriptCapitalL]0;
\[ScriptCapitalI]d = NEye[d];
\[ScriptCapitalI]N= NEye[NN];
F = DiagonalMatrix[Range[0.,NN-1]];
G = DiagonalMatrix[Sqrt[Range[1.,NN-1]],-1];
\[ScriptCapitalA] = (NEye[A]\[CircleTimes]A + A\[Transpose]\[CircleTimes] NEye[A]);

\[ScriptCapitalV] = \[ScriptCapitalI]N \[CircleTimes] \[ScriptCapitalL]0  + \[Lambda] \[ScriptCapitalI]N \[CircleTimes] LindbladToVec[A] - \[Gamma] F\[CircleTimes] \[ScriptCapitalI]d + \[Gamma]/(2Sqrt[\[Sigma]]) G\[CircleTimes] \[ScriptCapitalA] 
]


(* ::Input::Initialization:: *)
(* Calculate matrix for just feedback *)
Clear[QFPMEONLYFeedbackMatrix];
QFPMEONLYFeedbackMatrix[\[ScriptCapitalL]\[ScriptCapitalL]p_,\[Alpha]\[Alpha]_]:=Module[{\[Alpha],\[ScriptCapitalL]p,dp,\[ScriptCapitalV]},
\[Alpha] = If[Length@Dimensions@\[Alpha]\[Alpha]===3,\[Alpha]\[Alpha],{\[Alpha]\[Alpha]}];
\[ScriptCapitalL]p = If[Length@Dimensions@\[ScriptCapitalL]\[ScriptCapitalL]p===3,\[ScriptCapitalL]\[ScriptCapitalL]p,{\[ScriptCapitalL]\[ScriptCapitalL]p}];
dp = Length@\[Alpha];

\[ScriptCapitalV] =  Sum[\[Alpha][[p]] \[CircleTimes] \[ScriptCapitalL]p[[p]],{p,dp}] 
]


(* ::Input::Initialization:: *)
(* Calculate full matrix, possibly including feedback *)
Clear[QFPMEFeedbackMatrix];
QFPMEFeedbackMatrix[\[ScriptCapitalL]0_,\[ScriptCapitalL]\[ScriptCapitalL]p_,\[Alpha]\[Alpha]_,A_,\[Lambda]_,\[Gamma]_]:=Module[{\[Sigma] = \[Gamma]/(8\[Lambda]),\[Alpha],\[ScriptCapitalL]p,dp,NN,\[ScriptCapitalI]N,\[ScriptCapitalI]d,d,F,G,\[ScriptCapitalA],\[ScriptCapitalV]},
\[Alpha] = If[Length@Dimensions@\[Alpha]\[Alpha]===3,\[Alpha]\[Alpha],{\[Alpha]\[Alpha]}];
\[ScriptCapitalL]p = If[Length@Dimensions@\[ScriptCapitalL]\[ScriptCapitalL]p===3,\[ScriptCapitalL]\[ScriptCapitalL]p,{\[ScriptCapitalL]\[ScriptCapitalL]p}];
NN = Length@First@\[Alpha];
dp = Length@\[Alpha];
d = Length@\[ScriptCapitalL]0;
\[ScriptCapitalI]d = NEye[d];
\[ScriptCapitalI]N= NEye[NN];
F = DiagonalMatrix[Range[0.,NN-1]];
G = DiagonalMatrix[Sqrt[Range[1.,NN-1]],-1];
\[ScriptCapitalA] = (NEye[A]\[CircleTimes]A + A\[Transpose]\[CircleTimes] NEye[A]);

\[ScriptCapitalV] = \[ScriptCapitalI]N \[CircleTimes] \[ScriptCapitalL]0 + Sum[\[Alpha][[p]] \[CircleTimes] \[ScriptCapitalL]p[[p]],{p,dp}] + \[Lambda] \[ScriptCapitalI]N \[CircleTimes] LindbladToVec[A] - \[Gamma] F\[CircleTimes] \[ScriptCapitalI]d + \[Gamma]/(2Sqrt[\[Sigma]]) G\[CircleTimes] \[ScriptCapitalA] 
]


(* ::Input::Initialization:: *)
(* Calculate steady state (Assuming no feedback) *)
Clear[QFPMEPDSteadyState]
QFPMEPDSteadyState[\[ScriptCapitalL]0_,A_,\[Lambda]_,\[Gamma]_,Nmax_:30]:=Module[{\[Sigma] = \[Gamma]/(8\[Lambda]),\[ScriptCapitalL],M,\[DoubleStruckCapitalI]},
\[ScriptCapitalL] = \[ScriptCapitalL]0 + \[Lambda] LindbladToVec[A];
M[0] = SteadyState[\[ScriptCapitalL]];
\[DoubleStruckCapitalI] = NEye[\[ScriptCapitalL]];
Do[M[n] = Unvec@LinearSolve[\[ScriptCapitalL]-\[Gamma] n \[DoubleStruckCapitalI] ,-(\[Gamma]/2) Sqrt[n/\[Sigma]]Vec[A . M[n-1]+M[n-1] . A]] ,{n,1,Nmax-1}];
Table[M[n],{n,0,Nmax-1}]//Chop
]


(* ::Input::Initialization:: *)
Clear[QFPMEFeedbackSteadyState];
QFPMEFeedbackSteadyState[\[ScriptCapitalL]0_,\[ScriptCapitalL]\[ScriptCapitalL]p_,\[Alpha]\[Alpha]_,A_,\[Lambda]_,\[Gamma]_]:=Module[{\[Sigma] = \[Gamma]/(8\[Lambda]),\[Alpha],\[ScriptCapitalL]p,dp,NN,\[ScriptCapitalI]N,\[ScriptCapitalI]d,d,F,G,\[ScriptCapitalA],\[ScriptCapitalV],ii,sol,Ms},
\[Alpha] = If[Length@Dimensions@\[Alpha]\[Alpha]===3,\[Alpha]\[Alpha],{\[Alpha]\[Alpha]}];
\[ScriptCapitalL]p = If[Length@Dimensions@\[ScriptCapitalL]\[ScriptCapitalL]p===3,\[ScriptCapitalL]\[ScriptCapitalL]p,{\[ScriptCapitalL]\[ScriptCapitalL]p}];
NN = Length@First@\[Alpha];
dp = Length@\[Alpha];
d = Length@\[ScriptCapitalL]0;
\[ScriptCapitalI]d = NEye[d];
\[ScriptCapitalI]N= NEye[NN];
F = DiagonalMatrix[Range[0.,NN-1]];
G = DiagonalMatrix[Sqrt[Range[1.,NN-1]],-1];
\[ScriptCapitalA] = (NEye[A]\[CircleTimes]A + A\[Transpose]\[CircleTimes] NEye[A]);

\[ScriptCapitalV] = \[ScriptCapitalI]N \[CircleTimes] \[ScriptCapitalL]0 + Sum[\[Alpha][[p]] \[CircleTimes] \[ScriptCapitalL]p[[p]],{p,dp}] + \[Lambda] \[ScriptCapitalI]N \[CircleTimes] LindbladToVec[A] - \[Gamma] F\[CircleTimes] \[ScriptCapitalI]d + \[Gamma]/(2Sqrt[\[Sigma]]) G\[CircleTimes] \[ScriptCapitalA];
sol=First@Eigenvectors[\[ScriptCapitalV],-1];
Ms = Unvec/@Partition[sol,d];
1/Tr[Ms[[1]]]*Ms

(*ii = Join[Vec@Eye[A],ConstantArray[0,{(NN-1)d }]];
sol=AnalyticalSteadyState[\[ScriptCapitalV],ii]//Chop;
*)
]


(* ::Input::Initialization:: *)
(* Determining Steady state for case of feedback *)
Clear[QFPMEFeedbackSteadyStatePerturbation]
QFPMEFeedbackSteadyStatePerturbation[\[ScriptCapitalL]0_,\[ScriptCapitalL]\[ScriptCapitalL]p_,\[Alpha]\[Alpha]_,A_,\[Lambda]_,\[Gamma]_,\[Epsilon]_]:=Module[{\[Sigma] = \[Gamma]/(8\[Lambda]),\[Alpha],\[ScriptCapitalL]p,dp,NN,\[ScriptCapitalI]N,\[ScriptCapitalI]d,d,F,G,\[ScriptCapitalA],Qfb,MM0,MM1,MM2,NN0,NN1,L,\[ScriptCapitalL],\[DoubleStruckCapitalI] ,corr1,corr2,Nmax},
L=Length@A;(* System size *)
Nmax=Length@\[Alpha]\[Alpha];(* Number of terms in expansion *)
\[ScriptCapitalL] = \[ScriptCapitalL]0 + \[Lambda] LindbladToVec[A]; 
\[DoubleStruckCapitalI] = NEye[\[ScriptCapitalL]];

MM0=QFPMEPDSteadyState[\[ScriptCapitalL]0,A,\[Lambda],\[Gamma],Nmax];(* Solution if there is no feedback using forward substitution *)
Qfb=QFPMEONLYFeedbackMatrix[\[ScriptCapitalL]\[ScriptCapitalL]p,\[Alpha]\[Alpha]];(* Feedback part of dynamical matrix*)

(* First order correction *)
NN0=QFPMEunlongvec[-Qfb . QFPMElongvec[MM0],L];(* Term on the right in Eq. 11*)

MM1[0] = Unvec[LinearSolve[\[ScriptCapitalL],Vec[NN0[[1]]]]];
Do[MM1[n] = Unvec@LinearSolve[\[ScriptCapitalL]-\[Gamma] n \[DoubleStruckCapitalI] ,-(\[Gamma]/2) Sqrt[n/\[Sigma]]Vec[A . MM1[n-1]+MM1[n-1] . A]+Vec[NN0[[n+1]]]] ,{n,1,Nmax-1}];
corr1=Table[MM1[n],{n,0,Nmax-1}];

(* Second order correction *)
NN1=QFPMEunlongvec[- Qfb . QFPMElongvec[corr1],L];(* Term on the right in Eq. 11*)
MM2[0] = Unvec[LinearSolve[\[ScriptCapitalL],Vec[NN1[[1]]]]];
Do[MM2[n] = Unvec@LinearSolve[\[ScriptCapitalL]-\[Gamma] n \[DoubleStruckCapitalI] ,-(\[Gamma]/2) Sqrt[n/\[Sigma]]Vec[A . MM2[n-1]+MM2[n-1] . A]+Vec[NN1[[n+1]]]] ,{n,1,Nmax-1}];
corr2=Table[MM2[n],{n,0,Nmax-1}];


MM0+ \[Epsilon] corr1+\[Epsilon]^2 corr2 (* Perturbatively corrected state of system *)

]


(* ::Input::Initialization:: *)
(* Determining Steady state for case of feedback *)
Clear[QFPMEFeedbackSteadyStatePerturbation];
QFPMEFeedbackSteadyStatePerturbation[\[ScriptCapitalL]0_,\[ScriptCapitalL]\[ScriptCapitalL]p_,\[Alpha]\[Alpha]_,A_,\[Lambda]_,\[Gamma]_,\[Epsilon]_,Ncorr_:2]:=Module[{\[Sigma] = \[Gamma]/(8\[Lambda]),\[Alpha],\[ScriptCapitalL]p,dp,NN,Qfb,L,\[ScriptCapitalL],\[DoubleStruckCapitalI] ,Nmax,Msol,Nvec,R,ll},
L=Length@A;(* System size *)
Nmax=Length@\[Alpha]\[Alpha];(* Number of terms in expansion *)
\[ScriptCapitalL] = \[ScriptCapitalL]0 + \[Lambda] LindbladToVec[A]; 
\[DoubleStruckCapitalI] = NEye[\[ScriptCapitalL]];
Qfb=QFPMEONLYFeedbackMatrix[\[ScriptCapitalL]\[ScriptCapitalL]p,\[Alpha]\[Alpha]];(* Feedback part of dynamical matrix*)
R=QFPMEunlongvec[-Qfb . QFPMElongvec[#],L]&;

Msol=Table[ConstantArray[0,{L,L}],{jj,1,Ncorr+1},{ii,1,Nmax}];
Nvec=Table[ConstantArray[0,{L,L}],{jj,1,Ncorr},{ii,1,Nmax}];

Msol[[1]]=QFPMEPDSteadyState[\[ScriptCapitalL]0,A,\[Lambda],\[Gamma],Nmax];(* Solution if there is no feedback using forward substitution *)

For[ll=1,ll<=Ncorr,ll++,
(* ll^th order correction *)
Nvec[[ll]]=QFPMEunlongvec[-Qfb . QFPMElongvec[Msol[[ll]]],L];(* Term on the right in Eq. 11*)

Msol[[ll+1,1]] = Unvec[LinearSolve[\[ScriptCapitalL],Vec[Nvec[[ll,1]]]]];
Do[Msol[[ll+1,n+1]]  = Unvec@LinearSolve[\[ScriptCapitalL]-\[Gamma] n \[DoubleStruckCapitalI] ,-(\[Gamma]/2) Sqrt[n/\[Sigma]]Vec[A . Msol[[ll+1,n]]+Msol[[ll+1,n]] . A]+Vec[Nvec[[ll,n+1]]]] ,{n,1,Nmax-1}];

];

Sum[\[Epsilon]^(kk-1) Msol[[kk]],{kk,1,Ncorr+1}](* Perturbatively corrected state of system *)

]


(* ::Input::Initialization:: *)
(*
Simulation of Belavkin equation

Inputs:
 - Gs (list of matrices which build up Hamiltonian )
- fs (list of Hamiltonian control functions in time and filtered measurement outcome )
- A (Measured observable )
- \[Rho]i (Initial state of system as vectorised density matrix)
- Nt (Number of timesteps)
- T (Total operation time)
- \[Lambda] (measurement strength)
- \[Gamma] (measurement bandwidth)
- seed (optional input for fixing set of random numbers)
- ssops (optional list of unmonitored disapators )

Outputs: {list of conditional expectation values for each timestep, list of measurement outcomes for each timestep, list of density matrices for each timestep}

*)
Clear[QFPMEBelavkin];
QFPMEBelavkin[Gs_,fs_,A_,\[Rho]i_,Nt_?IntegerQ,T_?NumericQ,\[Lambda]_?NumericQ,\[Gamma]_?NumericQ,seed_:0,ssops_:None]:=Module[{dt=T/(Nt-1),dG=Length@fs,DA,L=Length@A,r,Aclist,Dlist,\[Rho]t,\[Rho]v,\[Rho]c,Ac,H,\[ScriptCapitalL],sops},

(* Unmonitored dissapators *)
sops = If[ssops===None,
{ConstantArray[0,{L,L}]},
If[Length@Dimensions[sops]===2,
{ssops},
ssops]];

DA=LindbladToVec[A];(* Dephasing from measuring A *)
SeedRandom[seed];(* Make results repeatable *)
r = RandomVariate[NormalDistribution[0.,Sqrt@dt],Nt];(* List of random numbers. Mean zero. Variance dt *)
Aclist=ConstantArray[0,Nt];(* Expected value on conditional state *)
Dlist=ConstantArray[0,Nt];(* Filtered measurement outcomes *)
\[Rho]t=ConstantArray[ConstantArray[0,L^2],Nt];(* State of system at each timestep. Keep in vector format *)

H[t_,d_]=Sum[fs[[j]][t,d]Gs[[j]],{j,1,dG}];(* Hamiltonian as a function of time and the filtered measurement outcome *)

\[ScriptCapitalL][t_,d_]=Liouvillian[H[t,d],sops];(* Liovillian of system *)

(* Update loop *)
\[Rho]t[[1]]=\[Rho]i; (* set initial state in list *)
\[Rho]v=\[Rho]i;
\[Rho]c=Unvec@\[Rho]v;
Ac=expect[A,\[Rho]c];(* Expected value on conditional state *)
Aclist[[1]]=Ac;(* Add to list *)
Dlist[[1]]=Ac;(* Should this have an extra +\[Gamma]/Sqrt[4 \[Lambda]]r\[LeftDoubleBracket]1\[RightDoubleBracket] ??  *)
For[i=1,i<Nt,i++,
\[Rho]t[[i+1]]=\[Rho]v+(\[ScriptCapitalL][(i-1)*dt,Dlist[[i]]]+ \[Lambda] DA) . \[Rho]v dt+ Sqrt[\[Lambda]]r[[i]]Vec[\[DoubleStruckCapitalC][A-Ac IdentityMatrix[L],\[Rho]c,-1]];
(* iteratively updating the state *)
\[Rho]v=\[Rho]t[[i+1]];(* state for next iteration *)
\[Rho]c=Unvec@\[Rho]v;
Ac=expect[A,\[Rho]c];(* Expected value on conditional state *)
Aclist[[i+1]]=Ac;(* Add to list *)
Dlist[[i+1]]=Dlist[[i]]+\[Gamma] dt (Ac-Dlist[[i]])+\[Gamma]/Sqrt[4 \[Lambda]] r[[i]](* This outcome filtered *)
];
{Aclist,Dlist,\[Rho]t}

]


(* ::Input::Initialization:: *)
(* Conditional expectation value *)
Clear[QFPMEExpectCon]
QFPMEExpectCon[B_,Ms_,\[Lambda]_,\[Gamma]_,dmin_,dmax_,Nd_]:=Module[{tab1,tab2},
tab1=QFPMEPDFFT[(B . #)&/@Ms,\[Lambda],\[Gamma],dmin,dmax,Nd];
tab2=QFPMEPDFFT[Ms,\[Lambda],\[Gamma],dmin,dmax,Nd];
Table[{tab1[[ii,1]],tab1[[ii,2]]/tab2[[ii,2]]},{ii,1,Length@tab1}]
]


(* ::Input::Initialization:: *)
Clear[JumpSteadyState];
JumpSteadyState[\[Rho]ss_,Js_]:=Module[{\[ScriptCapitalJ],pi},
\[ScriptCapitalJ] = Sum[J,{J,Js}];
pi=\[ScriptCapitalJ] . Vec[\[Rho]ss]//Unvec;
pi/Tr[pi]
]


(* ::Input::Initialization:: *)
Clear[JumpSteadyState2];
JumpSteadyState2[\[ScriptCapitalL]_,Js_]:=Module[{\[ScriptCapitalM],\[ScriptCapitalJ],J,\[ScriptCapitalL]0},
\[ScriptCapitalJ] = Sum[J,{J,Js}];
\[ScriptCapitalL]0 = \[ScriptCapitalL]-\[ScriptCapitalJ];
\[ScriptCapitalM] = -\[ScriptCapitalJ] . Inverse[\[ScriptCapitalL]0];
SteadyState[\[ScriptCapitalM]-Eye[\[ScriptCapitalM]]]
]


(* ::Input::Initialization:: *)
Clear[NoTimeTagMatrices];
NoTimeTagMatrices[H_,cops_,sops_:0]:=Module[{Ls,Ls2,\[ScriptCapitalL],\[ScriptCapitalJ]s,\[ScriptCapitalL]0,\[ScriptCapitalL]0inv,\[ScriptCapitalM]},
Ls = If[Length@Dimensions@cops===3,cops,{cops}];
Ls2 = If[sops===0,
Ls,
If[Length@Dimensions@sops===3,Join[Ls,sops],Prepend[Ls,sops]]];

\[ScriptCapitalL] = Liouvillian[H,Ls2];
\[ScriptCapitalJ]s = Table[JumpOp[c],{c,Ls}];
\[ScriptCapitalL]0 = \[ScriptCapitalL]-Total@\[ScriptCapitalJ]s;
\[ScriptCapitalL]0inv = Inverse[\[ScriptCapitalL]0];
\[ScriptCapitalM] = Table[-J . \[ScriptCapitalL]0inv,{J,\[ScriptCapitalJ]s}]

]


(* ::Input::Initialization:: *)
Clear[NoTimeTagJumpSteadyState];
NoTimeTagJumpSteadyState[\[ScriptCapitalM]_]:=SteadyState[Total@\[ScriptCapitalM]-Eye@First@\[ScriptCapitalM]]


(* ::Input::Initialization:: *)
Clear[NoTimeTagDynamics];
NoTimeTagDynamics[\[ScriptCapitalM]_,\[Rho]0_,nsteps_]:=Module[{\[Rho],r = Length@\[ScriptCapitalM],\[ScriptCapitalA],p,x},
\[ScriptCapitalA] = Range[1,r] (* alphabet *);
\[Rho] = Vec@\[Rho]0;
Table[
p = Table[UnTr[\[ScriptCapitalM][[x]] . \[Rho]],{x,Most@\[ScriptCapitalA]}];
AppendTo[p,1-Total@p];
x = RandomChoice[Chop@p->\[ScriptCapitalA]];
\[Rho] = \[ScriptCapitalM][[x]] . \[Rho];
\[Rho] = \[Rho]/UnTr[\[Rho]];
{x,p,Unvec[\[Rho]]},{nsteps}
]//Transpose//Chop
]


(* ::Input::Initialization:: *)
(* Outputs Subscript[M, Subscript[x, n]]...Subscript[M, Subscript[x, 1]] *)
Clear[NoTimeTagStringProduct];
NoTimeTagStringProduct[X_,\[ScriptCapitalM]_]:=Module[{x=Flatten@{X},r},
r = \[ScriptCapitalM][[x[[1]]]];
Do[r = \[ScriptCapitalM][[x[[j]]]] . r,{j,2,Length@x}];
r//Chop];

(* Outputs Subscript[M, Subscript[x, n]]...Subscript[M, Subscript[x, 1]]\[Rho] *)
NoTimeTagStringProduct[X_,\[ScriptCapitalM]_,\[Rho]_,normalize_:True]:=Module[{x = Flatten@{X},r=Vec@\[Rho]},
Do[r=\[ScriptCapitalM][[x[[i]]]] . r,{i,1,Length@x}];
If[normalize===True,Unvec[r]/Tr[Unvec[r]],Unvec[r]]//Chop
];


(* ::Input::Initialization:: *)
(* Outputs tr(Subscript[M, Subscript[x, n]]...Subscript[M, Subscript[x, 1]]\[Rho]) *)
Clear[NoTimeTagStringProbability];
NoTimeTagStringProbability[x_,\[ScriptCapitalM]_,\[Rho]_]:=Tr@NoTimeTagStringProduct[x,\[ScriptCapitalM],\[Rho]]


(* ::Input::Initialization:: *)
(* Outputs P(x|y,\[Rho]) *)
Clear[NoTimeTagStringConditionalProbability];
NoTimeTagStringConditionalProbability[x_,y_,\[ScriptCapitalM]_,\[Rho]_]:=Tr@NoTimeTagStringProduct[Join[Flatten@{x},Flatten@{y}],\[ScriptCapitalM],\[Rho]]/Tr@NoTimeTagStringProduct[Flatten@{y},\[ScriptCapitalM],\[Rho]]

(* Outputs Subscript[P, k](x|y,\[Rho]) where there is a gap k between x and y*)
NoTimeTagStringConditionalProbability[X_,Y_,\[ScriptCapitalM]_,\[Rho]_,k_]:=Module[{Mx,My,M,x=Flatten@{X},y=Flatten@{Y}},
My =  NoTimeTagStringProduct[y,\[ScriptCapitalM]];
M = Total@\[ScriptCapitalM];
Which[
k==0,
NoTimeTagStringConditionalProbability[x,y,\[ScriptCapitalM],\[Rho]],
k>0,
(Mx = NoTimeTagStringProduct[x,\[ScriptCapitalM]];
UnTr[Mx . MatrixPower[M,k] . My . Vec[\[Rho]]]/UnTr[My . Vec[\[Rho]]]//Chop),
k<0 (* overlap *),
(
Mx = NoTimeTagStringProduct[Drop[x,-k],\[ScriptCapitalM]];
KroneckerDelta[x[[1;;-k]],y[[k;;-1]]] UnTr[Mx . My . Vec[\[Rho]]]/UnTr[My . Vec[\[Rho]]])
]//Chop
]



(* ::Input::Initialization:: *)
(* Works with both analytics and numerics *)
Clear[QuantumJumpFisherInfoRenewalChannels];
QuantumJumpFisherInfoRenewalChannels[H_,L_,\[Gamma]_,dH_,d\[Gamma]_]:=Module[{\[Mu],\[Nu],\[ScriptCapitalL],\[Rho]ss,f,p,He,Hedag,dHe,dHedag,\[ScriptCapitalL]0,\[ScriptCapitalL]0i,d\[ScriptCapitalL]0,d\[ScriptCapitalL]0i,pkq,dpkq,nops=Length@L,\[DoubleStruckCapitalI] = Eye[H],k,q,Fch},
\[Mu] = Table[Normalize@SelectFirst[L[[k]]\[Transpose],Total@Abs@#!=0&],{k,nops}];
\[Nu] = Table[Normalize@SelectFirst[L[[k]],Total@Abs@#!=0&],{k,nops}]\[Conjugate];
\[ScriptCapitalL] = Liouvillian[H,L,\[Gamma]];
\[Rho]ss =SteadyState[\[ScriptCapitalL]];
f = Table[\[Gamma][[k]]Tr[L[[k]] . \[Rho]ss . L[[k]]\[ConjugateTranspose]],{k,nops}];
p = f/Total[f];
He = H - I/2 Sum[\[Gamma][[k]]L[[k]]\[ConjugateTranspose] . L[[k]],{k,nops}];

Hedag= H + I/2 Sum[\[Gamma][[k]]L[[k]]\[ConjugateTranspose] . L[[k]],{k,nops}];
dHe = dH - I/2 Sum[d\[Gamma][[k]]L[[k]]\[ConjugateTranspose] . L[[k]],{k,nops}];
dHedag = dH + I/2 Sum[d\[Gamma][[k]]L[[k]]\[ConjugateTranspose] . L[[k]],{k,nops}];

\[ScriptCapitalL]0 = \[ScriptCapitalL] - Sum[\[Gamma][[k]] JumpOp[L[[k]]],{k,nops}];
d\[ScriptCapitalL]0 = -I (kron[\[DoubleStruckCapitalI],dHe]-kron[dHedag\[Transpose],\[DoubleStruckCapitalI]]);
\[ScriptCapitalL]0i = Inverse[\[ScriptCapitalL]0];
d\[ScriptCapitalL]0i = - \[ScriptCapitalL]0i . d\[ScriptCapitalL]0 . \[ScriptCapitalL]0i;

pkq = Table[-\[Gamma][[k]] \[Nu][[k]]\[Conjugate] . Unvec[\[ScriptCapitalL]0i . Vec[out[\[Mu][[q]],\[Mu][[q]]]]] . \[Nu][[k]],{k,nops},{q,nops}];

dpkq = Table[-d\[Gamma][[k]]/\[Gamma][[k]] pkq[[k,q]] + \[Gamma][[k]] \[Nu][[k]]\[Conjugate] . Unvec[d\[ScriptCapitalL]0i . Vec[out[\[Mu][[q]],\[Mu][[q]]]]] . \[Nu][[k]],{k,nops},{q,nops}];
Fch = Sum[If[Not[pkq[[k,q]]===0],p[[q]] dpkq[[k,q]]^2/pkq[[k,q]],0],{k,nops},{q,nops}]//Chop
]


(* ::Input::Initialization:: *)
(* Only works with numerics. *)
(* In this case one must also supply a small parameter \[Delta] to compute the derivative. *)

Clear[QuantumJumpFisherInfoRenewalFull];
QuantumJumpFisherInfoRenewalFull[H_,L_,\[Gamma]_,dH_,d\[Gamma]_,tf_:100,dt_:0.01,\[Delta]_:10^-4]:=Module[{nops=Length@L,\[DoubleStruckCapitalI] = Eye[H],\[Mu],\[Nu],\[ScriptCapitalL],\[Rho]ss,f,p,He,k,q,F,nsteps,Hp,Hm,\[Gamma]p,\[Gamma]m,Hep,Hem,M,B,exp,expp,expm,inttable,W,dexp,dW,sum},
\[Mu] = Table[Normalize@SelectFirst[L[[k]]\[Transpose],Total@Abs@#!=0&],{k,nops}];
\[Nu] = Table[Normalize@SelectFirst[L[[k]],Total@Abs@#!=0&],{k,nops}]\[Conjugate];
\[ScriptCapitalL] = Liouvillian[H,L,\[Gamma]];
\[Rho]ss =SteadyState[\[ScriptCapitalL]];
f = Table[\[Gamma][[k]]Tr[L[[k]] . \[Rho]ss . L[[k]]\[ConjugateTranspose]],{k,nops}];
p = f/Total[f];
Hp = H + \[Delta] dH;
Hm = H - \[Delta] dH;
\[Gamma]p = \[Gamma]+\[Delta] d\[Gamma];
\[Gamma]m = \[Gamma]-\[Delta] d\[Gamma];

He = H - I/2 Sum[\[Gamma][[k]]L[[k]]\[ConjugateTranspose] . L[[k]],{k,nops}];
Hep = Hp - I/2 Sum[\[Gamma]p[[k]]L[[k]]\[ConjugateTranspose] . L[[k]],{k,nops}];
Hem = Hm - I/2 Sum[\[Gamma]m[[k]]L[[k]]\[ConjugateTranspose] . L[[k]],{k,nops}];

(* Intentionally avoiding W(t=0) since this can be zero *);
nsteps =Ceiling[tf/dt];
M = MatrixExp[-I He dt];
B = \[DoubleStruckCapitalI];
exp = Table[B=M . B,{nsteps}](* \[ExponentialE]^(-\[ImaginaryI] Subscript[H, e](\[Theta])\[Tau])*);
M = MatrixExp[-I Hep dt];
B = \[DoubleStruckCapitalI];
expp = Table[B=M . B,{nsteps}](* \[ExponentialE]^(-\[ImaginaryI] Subscript[H, e](\[Theta]+d\[Theta])\[Tau])*);
M = MatrixExp[-I Hem dt];
B = \[DoubleStruckCapitalI];
expm = Table[B=M . B,{nsteps}](* \[ExponentialE]^(-\[ImaginaryI] Subscript[H, e](\[Theta]-d\[Theta])\[Tau])*);
dexp = (expp-expm)/(2\[Delta]);
inttable = Table[
W = Table[\[Gamma][[k]] Abs[\[Nu][[k]]\[Conjugate] . exp[[t]] . \[Mu][[q]]]^2,{t,nsteps}];
dW =(\[Gamma]p[[k]]-\[Gamma]m[[k]])/(2\[Delta] \[Gamma][[k]]) W + Table[\[Gamma][[k]] (\[Nu][[k]]\[Conjugate] . dexp[[t]] . \[Mu][[q]])(\[Mu][[q]]\[Conjugate] . exp[[t]]\[ConjugateTranspose] . \[Nu][[k]]),{t,nsteps}]+Table[\[Gamma][[k]] (\[Nu][[k]]\[Conjugate] . exp[[t]] . \[Mu][[q]])(\[Mu][[q]]\[Conjugate] . dexp[[t]]\[ConjugateTranspose] . \[Nu][[k]]),{t,nsteps}];

dW^2/W
,{k,nops},{q,nops}];

sum = Sum[p[[q]] inttable[[k,q]],{k,nops},{q,nops}]//Chop;
F= Trapz[sum,dt]
]


(* ::Input::Initialization:: *)
Clear[MonitoringOperator];
MonitoringOperator[\[ScriptCapitalM]_,d\[ScriptCapitalM]_,\[Rho]0_,nsteps_,fulloutput_:False]:=Module[{\[Rho],r = Length@\[ScriptCapitalM],\[ScriptCapitalA],p,x,\[Xi]},
\[ScriptCapitalA] = Range[1,r] (* alphabet *);
\[Rho] = Vec@\[Rho]0;
\[Xi] = 0 \[Rho];
If[fulloutput===True,
Table[
p = Table[UnTr[\[ScriptCapitalM][[x]] . \[Rho]],{x,Most@\[ScriptCapitalA]}];
AppendTo[p,1-Total@p];
x = RandomChoice[Chop@p->\[ScriptCapitalA]];
\[Xi] = (d\[ScriptCapitalM][[x]] . \[Rho] + \[ScriptCapitalM][[x]] . \[Xi])/p[[x]];
\[Rho] = \[ScriptCapitalM][[x]] . \[Rho]/p[[x]];
{x,(*p,*)Unvec[\[Rho]],Unvec@\[Xi],UnTr[\[Xi]]^2},{nsteps}
],

Table[
p = Table[UnTr[\[ScriptCapitalM][[x]] . \[Rho]],{x,Most@\[ScriptCapitalA]}];
AppendTo[p,1-Total@p];
x = RandomChoice[Chop@p->\[ScriptCapitalA]];
\[Xi] = (d\[ScriptCapitalM][[x]] . \[Rho] + \[ScriptCapitalM][[x]] . \[Xi])/p[[x]];
\[Rho] = \[ScriptCapitalM][[x]] . \[Rho]/p[[x]];
{x,UnTr[\[Xi]]^2},{nsteps}
]
]//Transpose//Chop
]


(* ::Input::Initialization:: *)
Clear[MonitoringOperatorQuantumJumpNEnsemble];
MonitoringOperatorQuantumJumpNEnsemble[\[Psi]0_,H_,dH_,L_,dL_,\[Tau]s_,njumps_,ntrajs_:1,seed_:0,onlyJumps_:True]:=Module[{A,\[ScriptCapitalA],\[DoubleStruckCapitalA],nk,nts,He,Q,\[Psi],\[Tau],tab,P,Xp,X,nA,x,j,i,dA,dHe,\[Phi],\[Xi],f,\[Delta],dV,n},

If[seed!=0,SeedRandom[seed]];

nk = Length@L;
nts = Length@\[Tau]s;
\[ScriptCapitalA] = Distribute[{Range[1,nk],\[Tau]s},List];
\[DoubleStruckCapitalA] = Range[1,Length@\[ScriptCapitalA]];
nA = Length@\[DoubleStruckCapitalA];

He = H - I/2 Sum[c\[ConjugateTranspose] . c,{c,L}];
dHe = dH - I/2 Sum[dL[[i]]\[ConjugateTranspose] . L[[i]]+L[[i]]\[ConjugateTranspose] . dL[[i]],{i,Length@L}];

\[Delta] = 10^-6;
Do[
x = \[ScriptCapitalA][[j]];
A[j] = L[[x[[1]]]] . MatrixExp[-I He x[[2]]];
Q[j] = A[j]\[ConjugateTranspose] . A[j];
dV = (MatrixExp[-I (He + \[Delta] dHe)x[[2]]]-MatrixExp[-I (He-\[Delta] dHe)x[[2]]])/(2\[Delta])(* \!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Theta]\)]
\*SuperscriptBox[\(e\), \(\(-i\)\ 
\*SubscriptBox[\(H\), \(e\)]t\)]\) *);
dA[j] = dL[[x[[1]]]] . MatrixExp[-I He x[[2]]] + L[[x[[1]]]] . dV(*BCHderiv[-\[ImaginaryI] He x[[2]],-\[ImaginaryI] dHe x[[2]]]*);
,{j,\[DoubleStruckCapitalA]}] ;

PrintTemporary[Norm[Q[\[DoubleStruckCapitalA][[-1]]]]];

table[
\[Psi] = Normal@\[Psi]0;
\[Tau]= 0;
tab = {};
\[Xi] = ConstantArray[0,{Length@\[Psi]0,Length@\[Psi]0}];
Do[(*\[Tau]< tf,*)
P = Table[\[Psi]\[Conjugate] . Q[i] . \[Psi],{i,\[DoubleStruckCapitalA]}]//Chop;
j=SillySample[\[DoubleStruckCapitalA],P];
X = \[ScriptCapitalA][[j]];

\[Tau] = \[Tau] + X[[2]];
\[Phi] = dA[j] . \[Psi]/Sqrt[P[[j]]];
\[Psi] = A[j] . \[Psi]/Sqrt[P[[j]]];
\[Xi] = out[\[Phi],\[Psi]]+out[\[Psi],\[Phi]] + A[j] . \[Xi] . A[j]\[ConjugateTranspose]/P[[j]];
f = Tr[\[Xi]]^2;
AppendTo[tab,{X,\[Tau],\[Psi],\[Xi],f}];
,{njumps}
];
Chop@If[onlyJumps===True,tab[[All,{1,2,5}]]\[Transpose],tab\[Transpose]]
,{n,ntrajs}]


]
(*MonitoringOperatorQuantumJumpGillespie[\[Psi]0,H,dH,L,0L,\[Tau]s,250,1,0,True];*)


(* ::Input::Initialization:: *)
Clear[QueueSolve];
QueueSolve[T_,S_]:=Module[{ncustomers = Length@T,Wq,\[ScriptCapitalI],A,L,\[Theta],NA,Pop,PopQueue},

Wq = ConstantArray[0,ncustomers];
\[ScriptCapitalI] = ConstantArray[0,ncustomers];
Wq[[1]]=0.;
\[ScriptCapitalI][[1]]=0.;
Do[
\[Theta] = Wq[[n]]+S[[n]]-T[[n]];
Wq[[n+1]]= Max[0.,\[Theta]];
\[ScriptCapitalI][[n+1]] =Max[0.,-\[Theta]];
,{n,1,ncustomers-1}
];

A = Accumulate[Prepend[T,0]]//Most(* Absolute times when each customers arrives *); 
L = Accumulate[\[ScriptCapitalI] + S] (* Absolute time when each customers leaves *);
{Wq,\[ScriptCapitalI],A,L}
]

(* Inputs the probability distributions *)
QueueSolve[T_,S_,ncustomers_]:=Module[{TT,SS},
TT = If[Head[T]===List,T,RandomVariate[T,ncustomers]];
SS = If[Head[S]===List,S,RandomVariate[S,ncustomers]];
QueueSolve[TT,SS]
]


(* ::Input::Initialization:: *)
Clear[QueuePopulation];
(* Only outputs at the arrival/departure times *)
QueuePopulation[A_,L_]:=Module[{ncustomers = Length@A,NA,NL,PopAtArrivals,PopAtDepartures,Pop,PopQueue},
NA = Table[Total@UnitStep[l-A],{l,L}] (* Number of customers that have arrived at time of n-th departure *);
PopAtDepartures = {L,NA - Range[1,ncustomers]}\[Transpose];

NL = Table[Total@UnitStep[a-L],{a,A}](* Number of customers that have departed at the time of the n-th arrival *);
PopAtArrivals = {A,Range[1,ncustomers]-NL}\[Transpose];

Pop = SortBy[Join[PopAtArrivals,PopAtDepartures],First];
PopQueue = Table[{p[[1]],Max[0,p[[2]]-1]},{p,Pop}];
{NA,NL,Pop,PopQueue}
]

(* Population of customers in the queue at given times ts *)
QueuePopulation[ts_,A_,L_]:=Module[{d = Length@A,NA,NL,PopQueue,Pop},
NA=Table[Total@UnitStep[t-A],{t,ts}];
NL=Table[Total@UnitStep[t-L],{t,ts}];
Pop = {ts,NA-NL}\[Transpose];
(*Pop = Table[Max[0,NA[[t]]-NL[[t]]],{t,Length@ts}];*)
PopQueue =Table[{p[[1]],Max[0,p[[2]]-1]},{p,Pop}] ;
{NA,NL,Pop,PopQueue}
]


(* ::Input::Initialization:: *)
QueuedCollisionModelDiscrete[T_,S_,\[Rho]S0_,\[Rho]A_,USA_,\[ScriptCapitalE]A_,\[ScriptCapitalE]S_,func_]:=Module[{nanc = Length@T,Wq,\[ScriptCapitalI],A,L,\[Rho]S,\[Rho]SA,n,U},
{Wq,\[ScriptCapitalI],A,L} = QueueSolve[T,S];
\[Rho]S = \[Rho]S0;
Prepend[Table[
U = USA[S[[n]]];
\[Rho]SA = U . kron[\[ScriptCapitalE]S[\[ScriptCapitalI][[n]],\[Rho]S],\[ScriptCapitalE]A[Wq[[n]],\[Rho]A]] . U\[ConjugateTranspose];
\[Rho]S = TwoQubitPTr[\[Rho]SA,2];
func[{\[Rho]S,\[Rho]SA}]
,{n,1,nanc-1}],func[{\[Rho]S0,kron[\[Rho]S0,\[Rho]A]}]]
]


(* ::Input::Initialization:: *)
Clear[GfuncFEvaluate];
GfuncFEvaluate[dS_,\[Rho]A_,USA_,\[ScriptCapitalE]A_,\[ScriptCapitalE]S_,{Sn_,Wnq_,\[ScriptCapitalI]n_}]:=Table[Vec@TwoQubitPTr[USA[Sn] . kron[\[ScriptCapitalE]S[\[ScriptCapitalI]n,Unvec@Basis[dS^2,i]],\[ScriptCapitalE]A[Wnq,\[Rho]A]] . USA[Sn]\[ConjugateTranspose],2],{i,dS^2}]\[Transpose]


(* ::Input::Initialization:: *)
Clear[GfuncDeterministic]
GfuncDeterministic[xgrid_,\[Lambda]_,\[Tau]S_,dS_,\[Rho]A_,USA_,\[ScriptCapitalE]A_,\[ScriptCapitalE]S_]:=Module[{g0,g,g2,tab,\[ScriptCapitalF],\[ScriptCapitalF]2,y},
g0=Quiet@Table[y = \[Tau]S-x+Max[0,xp];
If[y>0,\[Lambda] Exp[-\[Lambda] y],0],{x,xgrid},{xp,xgrid}];
g=Chop@Table[g0[[All,i]]/Total@g0[[All,i]],{i,Length@g0}]\[Transpose];
g2 = SparseArray[kron[g,NEye[dS^2]]];
\[ScriptCapitalF] = Table[GfuncFEvaluate[dS,\[Rho]A,USA,\[ScriptCapitalE]A,\[ScriptCapitalE]S,{\[Tau]S,Max[0,xgrid[[j]]],Max[0,-xgrid[[j]]]}],{j,Length@xgrid}];
\[ScriptCapitalF]2 = BlockDiagonalMatrix[\[ScriptCapitalF]]//SparseArray;
g2 . \[ScriptCapitalF]2

];


(* ::Input::Initialization:: *)
Clear[gfuncDeterministic]
gfuncDeterministic[xgrid_,\[Lambda]_,\[Tau]S_,dS_,\[Rho]A_,USA_,\[ScriptCapitalE]A_,\[ScriptCapitalE]S_]:=Module[{g0,g,g2,tab,\[ScriptCapitalF],\[ScriptCapitalF]2,y},
g0=Quiet@Table[y = \[Tau]S-x+Max[0,xp];
If[y>0,\[Lambda] Exp[-\[Lambda] y],0],{x,xgrid},{xp,xgrid}];
g=Chop@Table[g0[[All,i]]/Total@g0[[All,i]],{i,Length@g0}]\[Transpose]
];

Clear[LindleySolve];
LindleySolve[xgrid_,g_]:=Module[{uv,pv},
uv = ConstantArray[1,Length@xgrid];
pv=AnalyticalSteadyState[g-NEye[g],uv]
]


(* ::Input::Initialization:: *)
Clear[XResolvedEvolve];
XResolvedEvolve[xgrid_,\[ScriptCapitalG]_,\[Rho]S0_,nsteps_,fullvec_:False]:=Module[{dS=Length@\[Rho]S0,b,\[Rho]v0,\[Rho]v,\[Rho]vlist},
b = Basis[Length@xgrid,Position[xgrid,0.][[1,1]]];
\[Rho]v0 = kron[b,Vec@\[Rho]S0];
\[Rho]vlist=NestList[\[ScriptCapitalG] . #&,\[Rho]v0,nsteps];
If[fullvec===False,
Table[Unvec@Chop@Total@Partition[\[Rho]v,dS^2],{\[Rho]v,\[Rho]vlist}],
\[Rho]vlist]
]


(* ::Input::Initialization:: *)
Clear[XResolvedSteadyState];
XResolvedSteadyState[xgrid_,\[ScriptCapitalG]_,dS_]:=Module[{uv,\[Rho]vss},
uv = kron[ConstantArray[1,Length@xgrid],Vec@Eye[dS]];
\[Rho]vss=AnalyticalSteadyState[\[ScriptCapitalG]-NEye[\[ScriptCapitalG]],uv];
Unvec@Chop@Total@Partition[\[Rho]vss,dS^2]
]


(* ::Input::Initialization:: *)
Clear[XResolvedSteadyState2];
XResolvedSteadyState2[xgrid_,\[ScriptCapitalG]_,dS_]:=Module[{uv,\[Rho]vss},
uv = kron[ConstantArray[1,Length@xgrid],Vec@Eye[dS]];
\[Rho]vss=Eigenvectors[\[ScriptCapitalG],1][[1]];
\[Rho]vss=\[Rho]vss/uv . \[Rho]vss//Chop;
Unvec@Chop@Total@Partition[\[Rho]vss,dS^2]
]


(* ::Input::Initialization:: *)
Clear[feedbackSteadyState];
feedbackSteadyState[M_,nops_]:=Module[{\[ScriptCapitalM],d2 = Length[M[1,1]],d,vec,\[ScriptCapitalM]2,sol,\[Rho]s},
\[ScriptCapitalM] = ArrayFlatten[Table[M[i,j],{i,nops},{j,nops}]];
d = Sqrt[d2];
vec = Join@@Table[Normal@Vec@Eye[d],{nops}];
\[ScriptCapitalM]2 = Join[\[ScriptCapitalM]-Eye[\[ScriptCapitalM]],{vec}];
sol = LinearSolve[\[ScriptCapitalM]2,Eye[nops d2+1][[-1]]];
\[Rho]s = Unvec/@PartitionIn[sol,nops]//Chop
]


(* ::Input::Initialization:: *)
Clear[feedbackProbs];
feedbackProbs[\[Rho]s_]:=Table[Tr[\[Rho]],{\[Rho],\[Rho]s}];


(* ::Input::Initialization:: *)
Clear[feedbackWaitingTimeDist];
feedbackWaitingTimeDist[\[Rho]s_,J_,\[ScriptCapitalL]0_,nops_]:= Table[Chop@UnTr@Sum[J[x] . MatrixExp[\[ScriptCapitalL]0[y]\[Tau]] . Vec[\[Rho]s[[y]]],{y,nops}],{x,nops}]


(* ::Input::Initialization:: *)
Clear[feedbackAverageTime];
feedbackAverageTime[\[Rho]s_,J_,\[ScriptCapitalL]0_,nops_]:=Module[{ps,condTimes,aveTime},
ps = Table[Tr[\[Rho]],{\[Rho],\[Rho]s}];
condTimes = Chop@Table[1/ps[[x]] Sum[UnTr[J[x] . Inverse[\[ScriptCapitalL]0[y] . \[ScriptCapitalL]0[y]] . Vec@\[Rho]s[[y]]],{y,nops}],{x,nops}];
aveTime = condTimes . ps;
{condTimes,aveTime}
]


(* ::Input::Initialization:: *)
Clear[JumpFeedbackSteadyState];
JumpFeedbackSteadyState[Ls_,Hs_]:=Module[{r,L,\[DoubleStruckCapitalI] = Eye[Ls[[1]]],\[ScriptCapitalL],B,diag,u,ps,p2,\[Rho]s,d},
r=Length@Ls;
d=Length@First@Hs;
B = -(1/2)Sum[kron[\[DoubleStruckCapitalI],L\[ConjugateTranspose] . L]+kron[(L\[ConjugateTranspose] . L)\[Transpose],\[DoubleStruckCapitalI]],{L,Ls}];
diag = Table[UnitaryToVec[Hs[[y]]]+B,{y,r}];
\[ScriptCapitalL] = BlockDiagonalMatrix@diag + ArrayFlatten@Table[JumpOp[Ls[[y]]],{y,r},{z,r}]//cf;
u=flat1@ConstantArray[Normal@Vec@Eye@d,r];
ps=AnalyticalSteadyState[\[ScriptCapitalL],u];
p2 = Partition[ps,d^2];
\[Rho]s = cf@Table[Unvec[p],{p,p2}]
]


(* ::Input::Initialization:: *)
Clear[AdditiveNoiseLangevinSimulate]
AdditiveNoiseLangevinSimulate[f_,B_,x0_,tf_,dt_]:=Module[{x,t,b,ts,proc,sim},
b[t_,x_]:=B; 
proc = ItoProcess[{f[t,x],b[t,x]},{x,x0},t];
ts = Range[0.,tf,dt];
sim = RandomFunction[proc,{0.,tf,dt}];
{proc,{ts,First@sim["ValueList"]}\[Transpose]}
]


(* ::Input::Initialization:: *)
Clear[nodiag];
nodiag[A_]:=A - DiagonalMatrix@Diagonal@A;


(* ::Input::Initialization:: *)
Clear[toBB];
toBB[W_]:=nodiag@W-DiagonalMatrix[Total@nodiag@W]


(* ::Input::Initialization:: *)
Clear[mecops];
mecops[W_]:=If[Length@Dimensions@W===2,
Flatten[Table[Sqrt[W[[x,y]]] Proj[Length@W,x,y],{x,Length@W},{y,Length@W}],1],
Flatten[Table[Sqrt[W[[l,x,y]]]Proj[Length[W[[l]]],x,y],{l,1,Length@W},{x,Length@First@W},{y,Length@First@W}],2]
];


(* ::Input::Initialization:: *)
Clear[MasterEquationSteadyState];
MasterEquationSteadyState[WW_]:=Module[{\[ScriptCapitalW],W=Total@If[Length@Dimensions@WW==2,{WW},WW]},
AnalyticalSteadyState[toBB[W],ConstantArray[1,Length@W]]
]


(* ::Input::Initialization:: *)
Clear[MarginalizeProb]
MarginalizeProb[p_,list_,locdimlist_]:=Diagonal@PTr[DiagonalMatrix[p],list,locdimlist];
MarginalizeProb[p_,list_,locdim_?NumberQ]:=Diagonal@PTr[DiagonalMatrix[p],list,ConstantArray[locdim,Log[locdim,Length[p]]]]


(* ::Input::Initialization:: *)
Clear[MarkovSimulate];
MarkovSimulate[QQ_,nmax_,i0_]:=Module[{Q},
Q=#/Total[QQ,1]&/@QQ;
(*Q=#/Total[QQ,1]&/@QQ;*)
First[Normal@RandomFunction[DiscreteMarkovProcess[i0,Q\[Transpose]],{0,nmax-1}]][[All,2]]
]

MarkovSimulate[Q_,nmax_]:=MarkovSimulate[Q,nmax,Basis[Length@Q,1]]


(* ::Input::Initialization:: *)
Clear[MasterEquationSimulate];
MasterEquationSimulate[W_,tf_,i0_,dt_:Automatic]:=Module[{\[ScriptCapitalW],pros,data},
\[ScriptCapitalW] = W - DiagonalMatrix@Diagonal@W; (* remove diagonals in case they are wrong *);
\[ScriptCapitalW]=\[ScriptCapitalW] - DiagonalMatrix@Total@\[ScriptCapitalW]; (* replace with appropriate rates *);
pros = ContinuousMarkovProcess[Basis[Length@W,i0],\[ScriptCapitalW]\[ConjugateTranspose]];
data=If[dt===Automatic,
First@Normal@RandomFunction[pros,{0,tf}],
First@Normal@RandomFunction[pros,{0,tf,dt}]
];
{pros,data}
]


(* ::Input::Initialization:: *)
Clear[BirthAndDeathMatrix];
BirthAndDeathMatrix[pup_?VectorQ,pdw_?VectorQ]:=Module[{W,d=Length@pup+1},
W = DiagonalMatrix[pup,-1] + DiagonalMatrix[pdw,1] - DiagonalMatrix[Append[pup,0]]-DiagonalMatrix[Prepend[pdw,0]]
]

BirthAndDeathMatrix[d_,pup_,pdw_]:=PauliEquation[ConstantArray[pup,{d-1}],ConstantArray[pdw,{d-1}]]


(* ::Input::Initialization:: *)
Clear[EmbedIntoLiouvillian];
EmbedIntoLiouvillian[W_]:=Liouvillian[0 W,mecops@W]


(* ::Input::Initialization:: *)
Clear[MasterEquationNuMatrices];
MasterEquationNuMatrices[W_,\[Nu]_]:=Module[{Ws,nbaths,nCOs},
Ws = If[Length@Dimensions@W==2,{W},W];
nbaths=Length@Ws;
nCOs = If[nbaths==1,
Which[
Length@Dimensions@\[Nu]===2,1,
Length@Dimensions@\[Nu]===3,Length@\[Nu],
True,Print["Error. Since W is rank 2, \[Nu] can be either a single matrix (1 CO), or a list of matrices (many COs)"]
],
Which[
Length@Dimensions@\[Nu]===2,1,
Length@Dimensions@\[Nu]===3,1,
Length@Dimensions@\[Nu]===4,Length@\[Nu]
]];
(*{nCOs,nbaths,*)
Which[
nbaths==1,
If[nCOs == 1, {{nodiag@\[Nu]}},Table[{nodiag@v},{v,\[Nu]}]],
nbaths>1,
Which[
Length@Dimensions@\[Nu]===2,
{Table[nodiag@\[Nu],{Length@Ws}]},
Length@Dimensions@\[Nu]===3,
{Table[nodiag@v,{v,\[Nu]}]},
Length@Dimensions@\[Nu]===4,
Table[If[Length@v===1,Table[nodiag[v[[1]]],{k,nbaths}],v],{v,\[Nu]}],
True,Print["WTF are you doing buddy?"]]]
]


(* ::Input::Initialization:: *)
Clear[MasterEquationCurrent];
MasterEquationCurrent[pss_,W_,\[Nu]_]:=Module[{u = ConstantArray[1,Length@pss], \[Nu]s,nbaths,nCOs,res,Wt,Ws},
Ws = If[Length@Dimensions@W==2,{W},W];
\[Nu]s = MasterEquationNuMatrices[W,\[Nu]];
nCOs = Dimensions[\[Nu]s][[1]];
nbaths=Dimensions[\[Nu]s][[2]];
Wt = Table[Total@Table[Ws[[l]] \[Nu]s[[\[Alpha],l]],{l,nbaths}],{\[Alpha],nCOs}];
res = Table[u . Wt[[\[Alpha]]] . pss,{\[Alpha],nCOs}];
If[Length@res===1,res[[1]],res]
]
MasterEquationCurrent[W_,\[Nu]_]:=Module[{pss = MasterEquationSteadyState[W]},MasterEquationCurrent[pss,W,\[Nu]]]


(* ::Input::Initialization:: *)
Clear[MasterEquationNoise];
MasterEquationNoise[pss_,W_,\[Nu]_]:=Module[{u = ConstantArray[1,Length@pss], \[Nu]s,nbaths,nCOs,res,Wt,Wtt,L,Ws},
Ws = If[Length@Dimensions@W==2,{W},W];
\[Nu]s = MasterEquationNuMatrices[W,\[Nu]];
nCOs = Dimensions[\[Nu]s][[1]];
nbaths=Dimensions[\[Nu]s][[2]];
Wt = Table[Total@Table[Ws[[l]] \[Nu]s[[\[Alpha],l]],{l,nbaths}],{\[Alpha],nCOs}];
Wtt=Table[Total@Table[Ws[[l]] \[Nu]s[[\[Alpha],l]] \[Nu]s[[\[Beta],l]] ,{l,nbaths}],{\[Alpha],nCOs},{\[Beta],nCOs}];
L = DrazinInverse[Total@Ws-DiagonalMatrix@Total@Total@Ws];
res = Table[u . Wtt[[\[Alpha],\[Beta]]] . pss - u . Wt[[\[Alpha]]] . L . Wt[[\[Beta]]] . pss-u . Wt[[\[Beta]]] . L . Wt[[\[Alpha]]] . pss,{\[Alpha],nCOs},{\[Beta],nCOs}];
If[nCOs===1,res[[1,1]],res]
]
MasterEquationNoise[W_,\[Nu]_]:=Module[{pss = MasterEquationSteadyState[W]},MasterEquationNoise[pss,W,\[Nu]]]


(* ::Input::Initialization:: *)
Clear[MasterEquationDrazinApply]
MasterEquationDrazinApply[\[DoubleStruckCapitalW]_,pss_,y_]:=Module[{z,u = ConstantArray[1,Length@pss]},
z = LinearSolve[\[DoubleStruckCapitalW], y-pss (u . y)]//Quiet;
z - pss (u . z)
]
Clear[MasterEquationNoiseWithApply];
MasterEquationNoiseWithApply[pss_,W_,\[Nu]_]:=Module[{u = ConstantArray[1,Length@pss], \[Nu]s,nbaths,nCOs,res,Wt,Wtt,\[DoubleStruckCapitalW],Ws},
Ws = If[Length@Dimensions@W==2,{W},W];
\[Nu]s = MasterEquationNuMatrices[W,\[Nu]];
nCOs = Dimensions[\[Nu]s][[1]];
nbaths=Dimensions[\[Nu]s][[2]];
Wt = Table[Total@Table[Ws[[l]] \[Nu]s[[\[Alpha],l]],{l,nbaths}],{\[Alpha],nCOs}];
Wtt=Table[Total@Table[Ws[[l]] \[Nu]s[[\[Alpha],l]] \[Nu]s[[\[Beta],l]] ,{l,nbaths}],{\[Alpha],nCOs},{\[Beta],nCOs}];
\[DoubleStruckCapitalW]=Total@Ws-DiagonalMatrix@Total@Total@Ws;

res = Table[u . Wtt[[\[Alpha],\[Beta]]] . pss - u . Wt[[\[Alpha]]] . MasterEquationDrazinApply[\[DoubleStruckCapitalW],pss,Wt[[\[Beta]]] . pss]-u . Wt[[\[Beta]]] . MasterEquationDrazinApply[\[DoubleStruckCapitalW],pss,Wt[[\[Alpha]]] . pss],{\[Alpha],nCOs},{\[Beta],nCOs}];
If[nCOs===1,res[[1,1]],res]
]
MasterEquationNoise[W_,\[Nu]_]:=Module[{pss = MasterEquationSteadyState[W]},MasterEquationNoise[pss,W,\[Nu]]]


(* ::Input::Initialization:: *)
Clear[MasterEquationCurrentCorrelationFunction];
MasterEquationCurrentCorrelationFunction[pss_,W_,\[Nu]_,t_]:=Module[{u = ConstantArray[1,Length@pss], \[Nu]s,nbaths,nCOs,res,Wt,Wtt,L,Ws,K,\[DoubleStruckCapitalW],F,Mt},
Ws = If[Length@Dimensions@W==2,{W},W];
\[Nu]s = MasterEquationNuMatrices[W,\[Nu]];
nCOs = Dimensions[\[Nu]s][[1]];
nbaths=Dimensions[\[Nu]s][[2]];
Wt = Table[Total@Table[Ws[[l]] \[Nu]s[[\[Alpha],l]],{l,nbaths}],{\[Alpha],nCOs}];
Wtt=Table[Total@Table[Ws[[l]] \[Nu]s[[\[Alpha],l]] \[Nu]s[[\[Beta],l]] ,{l,nbaths}],{\[Alpha],nCOs},{\[Beta],nCOs}];
\[DoubleStruckCapitalW] = Total@Ws-DiagonalMatrix@Total@Total@Ws;

K = Table[u . Wtt[[\[Alpha],\[Beta]]] . pss ,{\[Alpha],nCOs},{\[Beta],nCOs}];
Mt = MatrixExp[\[DoubleStruckCapitalW] t];
F = Table[1/2 ( u . Wt[[\[Alpha]]] . Mt . Wt[[\[Beta]]] . pss+u . Wt[[\[Beta]]] . Mt . Wt[[\[Alpha]]] . pss)-(u . Wt[[\[Alpha]]] . pss)(u . Wt[[\[Beta]]] . pss),{\[Alpha],nCOs},{\[Beta],nCOs}];
If[nCOs===1,{K[[1,1]],F[[1,1]]},{K,F}]
]


(* ::Input::Initialization:: *)
Clear[MasterEquationPowerSpectrum]
MasterEquationPowerSpectrum[pss_,W_,\[Nu]_,\[Omega]_]:=Module[{u = ConstantArray[1,Length@pss], \[Nu]s,nbaths,nCOs,S,Wt,Wtt,L,Ws,K,\[DoubleStruckCapitalW],M},
Ws = If[Length@Dimensions@W==2,{W},W];
\[Nu]s = MasterEquationNuMatrices[W,\[Nu]];
nCOs = Dimensions[\[Nu]s][[1]];
nbaths=Dimensions[\[Nu]s][[2]];
Wt = Table[Total@Table[Ws[[l]] \[Nu]s[[\[Alpha],l]],{l,nbaths}],{\[Alpha],nCOs}];
Wtt=Table[Total@Table[Ws[[l]] \[Nu]s[[\[Alpha],l]] \[Nu]s[[\[Beta],l]] ,{l,nbaths}],{\[Alpha],nCOs},{\[Beta],nCOs}];
\[DoubleStruckCapitalW] = Total@Ws-DiagonalMatrix@Total@Total@Ws;
L = \[DoubleStruckCapitalW] . Inverse[\[DoubleStruckCapitalW] . \[DoubleStruckCapitalW] + \[Omega]^2 Eye[\[DoubleStruckCapitalW]]];
S=Table[u . Wtt[[\[Alpha],\[Beta]]] . pss - u . Wt[[\[Alpha]]] . L . Wt[[\[Beta]]] . pss-u . Wt[[\[Beta]]] . L . Wt[[\[Alpha]]] . pss,{\[Alpha],nCOs},{\[Beta],nCOs}];

If[nCOs===1,S[[1,1]],S]
]


(* ::Input::Initialization:: *)
Clear[LatticeTransitionMatrix];
LatticeTransitionMatrix[L_,ww1_,ww2_:None]:=Module[{w1,w2,d,\[DoubleStruckCapitalI],W},

w1=If[ArrayDepth[ww1]===2,ConstantArray[ww1,L],ww1];
d = Length@First@w1;
\[DoubleStruckCapitalI] = Eye[d];
W = Sum[KronEye[w1[[j]],L,j],{j,L}];

If[Not[ww2 ===None],
W = W + Sum[kron[Eye[d^(j-1)],ww2,Eye[d^(L-j-1)]],{j,1,L-1}]
];
W

]


(* ::Input::Initialization:: *)
Clear[KURCURTUR];
KURCURTUR[WW_]:=Module[{\[CapitalGamma],W,\[DoubleStruckCapitalW],p,u,\[ScriptCapitalA],\[ScriptCapitalT],\[CapitalSigma],l},
W = If[Length@Dimensions@WW===2,WW,Total@WW];
\[CapitalGamma] = DiagonalMatrix@Total@W;
p = MasterEquationSteadyState[W];
u = ConstantArray[1,Length@p];

\[ScriptCapitalA] = u . \[CapitalGamma] . p;
\[ScriptCapitalT] = u . Inverse[\[CapitalGamma]] . p;
\[CapitalSigma] =If[Length@Dimensions@WW===2,
1/2 Sum[If[W[[x,y]]===0,0,(W[[x,y]]p[[y]]-W[[y,x]] p[[x]]) Log[(W[[x,y]]p[[y]])/(W[[y,x]]p[[x]])]],{x,Length@p},{y,Length@p}],
1/2 Sum[If[x==y,0,If[WW[[l,x,y]]===0,0,(WW[[l,x,y]]p[[y]]-WW[[l,y,x]] p[[x]]) Log[(WW[[l,x,y]]p[[y]])/(WW[[l,y,x]]p[[x]])]]],{l,Length@WW},{x,Length@p},{y,Length@p}]
];
{\[ScriptCapitalA],\[ScriptCapitalT],\[CapitalSigma]}
]


(* ::Input::Initialization:: *)
Clear[excursionClear];
excursionClear[]:=Clear[uA,uB,Ws,\[ScriptCapitalW],nbaths,d,\[CapitalGamma],\[DoubleStruckCapitalW],p,pA,pB,\[Nu]s,nCOs,\[Xi],\[DoubleStruckCapitalW]\[Xi],M,\[DoubleStruckCapitalW]A,\[DoubleStruckCapitalW]B,\[DoubleStruckCapitalW]AB,\[DoubleStruckCapitalW]BA,\[DoubleStruckCapitalW]A\[Xi],\[DoubleStruckCapitalW]B\[Xi],\[DoubleStruckCapitalW]AB\[Xi],\[DoubleStruckCapitalW]BA\[Xi],Wt,Wtt,WtA,WtAB,WtBA,WtB,WttA,WttAB,WttBA,WttB];


(* ::Input::Initialization:: *)
Clear[excursionBlocks];
excursionBlocks[A_?MatrixQ,dA_]:={
A[[1;;dA,1;;dA]],
A[[dA+1;;-1,dA+1;;-1]], 
A[[1;;dA,dA+1;;-1]],
A[[dA+1;;-1,1;;dA]]}


(* ::Input::Initialization:: *)
(* Loads all non-tilted-related quantities *)
Clear[excursionLoad]
excursionLoad[W_,dA_,xx_:"ss",yy_:"id"]:=Module[{},
excursionClear[];
Ws = If[Length@Dimensions@W==2,{W},W];
\[ScriptCapitalW]=Total[Ws];
nbaths = Length@Ws; 
d = Length[Ws[[1]]]; 
uA = ConstantArray[1,{dA}];
uB = ConstantArray[1,{d-dA}];
\[CapitalGamma]= DiagonalMatrix@Total@\[ScriptCapitalW];
\[DoubleStruckCapitalW] = \[ScriptCapitalW]- \[CapitalGamma];
{\[DoubleStruckCapitalW]A,\[DoubleStruckCapitalW]B,\[DoubleStruckCapitalW]AB,\[DoubleStruckCapitalW]BA} = excursionBlocks[\[DoubleStruckCapitalW],dA];
p = MasterEquationSteadyState[\[ScriptCapitalW]]//Simplify;
pA = p[[1;;dA]];
pB = p[[dA+1;;-1]];

M = -Inverse[\[DoubleStruckCapitalW]B];
x = If[xx==="ss",pA,Basis[dA,xx]];
y = If[yy==="id",uA,Basis[dA,yy]];
\[ScriptCapitalC]=1/y . \[DoubleStruckCapitalW]AB . M . \[DoubleStruckCapitalW]BA . x;
]


(* ::Input::Initialization:: *)
Clear[excursionClearTilted];
excursionClearTilted[]:=Clear[{\[Xi],\[Nu]s,nCOs,\[DoubleStruckCapitalW]\[Xi],\[DoubleStruckCapitalW]A\[Xi],\[DoubleStruckCapitalW]B\[Xi],\[DoubleStruckCapitalW]AB\[Xi],\[DoubleStruckCapitalW]BA\[Xi],Wt,Wtt,WtA,WtB,WtAB,WtBA,WttA,WttB,WttAB,WttBA}];

Clear[excursionLoadTilted];
excursionLoadTilted[\[Nu]_]:=Module[{},
excursionClearTilted[];
(* \[Nu]s is always rank 4: {nCOs,nbaths,d,d} *)
\[Nu]s= Which[
Length@Dimensions@Ws===2,
Which[
Length@Dimensions@\[Nu]===2,{{nodiag@\[Nu]}},
Length@Dimensions@\[Nu]===3,Table[{nodiag@v},{v,\[Nu]}],
True,Print["Error. Since W is rank 2, \[Nu] can be either a single matrix (1 CO), or a list of matrices (many COs)"]
],
Length@Dimensions@Ws===3,
Which[
Length@Dimensions@\[Nu]===2,
{Table[nodiag@\[Nu],{Length@Ws}]},
Length@Dimensions@\[Nu]===3,
{Table[nodiag@v,{v,\[Nu]}]},
Length@Dimensions@\[Nu]===4,
\[Nu],
True,Print["WTF are you doing buddy?"]
]
];
nCOs = Length@\[Nu]s;
\[DoubleStruckCapitalW]\[Xi] = Total@Table[Ws[[l]] Exp[I Sum[\[Nu]s[[\[Alpha],l]] \[Xi][\[Alpha]],{\[Alpha],nCOs}]],{l,nbaths}]-\[CapitalGamma];
{\[DoubleStruckCapitalW]A\[Xi],\[DoubleStruckCapitalW]B\[Xi],\[DoubleStruckCapitalW]AB\[Xi],\[DoubleStruckCapitalW]BA\[Xi]} = excursionBlocks[\[DoubleStruckCapitalW]\[Xi],dA];

Wt=Table[Total@Table[Ws[[l]] \[Nu]s[[\[Alpha],l]] ,{l,nbaths}],{\[Alpha],nCOs}];
Wtt=Table[Total@Table[Ws[[l]] \[Nu]s[[\[Alpha],l]] \[Nu]s[[\[Beta],l]] ,{l,nbaths}],{\[Alpha],nCOs},{\[Beta],nCOs}];
{WtA,WtB,WtAB,WtBA}=Table[excursionBlocks[Wt[[\[Alpha]]],dA],{\[Alpha],nCOs}]\[Transpose];
WttA = Table[excursionBlocks[Wtt[[\[Alpha],\[Beta]]],dA][[1]],{\[Alpha],nCOs},{\[Beta],nCOs}];
WttB = Table[excursionBlocks[Wtt[[\[Alpha],\[Beta]]],dA][[2]],{\[Alpha],nCOs},{\[Beta],nCOs}];
WttAB = Table[excursionBlocks[Wtt[[\[Alpha],\[Beta]]],dA][[3]],{\[Alpha],nCOs},{\[Beta],nCOs}];
WttBA = Table[excursionBlocks[Wtt[[\[Alpha],\[Beta]]],dA][[4]],{\[Alpha],nCOs},{\[Beta],nCOs}];
];


(* ::Input::Initialization:: *)
Clear[excursionCountingFPT]
excursionCountingFPT[]:=Module[{int},
Clear[t];
\[ScriptCapitalC] y . \[DoubleStruckCapitalW]AB . MatrixExp[\[DoubleStruckCapitalW]B t] . \[DoubleStruckCapitalW]BA . x
]


(* ::Input::Initialization:: *)
Clear[excursionTimeMoment]
excursionTimeMoment[n_]:=\[ScriptCapitalC] (n!) y . \[DoubleStruckCapitalW]AB . MatrixPower[M,n+1] . \[DoubleStruckCapitalW]BA . x

Clear[excursionTimeAverage];
excursionTimeAverage[]:=excursionTimeMoment[1];

Clear[excursionTimeVariance];
excursionTimeVariance[]:=excursionTimeMoment[2]-excursionTimeMoment[1]^2;


(* ::Input::Initialization:: *)
Clear[excursionCountingProb]
excursionCountingProb[\[Nu]_]:=Module[{int,res},
excursionLoadTilted[\[Nu]];
int = \[ScriptCapitalC]  y . \[DoubleStruckCapitalW]AB\[Xi] . Inverse[-\[DoubleStruckCapitalW]B\[Xi]] . \[DoubleStruckCapitalW]BA\[Xi] . x;
res=If[nCOs===1,int/.\[Xi][1]->\[Xi],int]//Simplify;
excursionClearTilted[];
res
]


(* ::Input::Initialization:: *)
Clear[excursionActivityDistribution]
excursionActivityDistribution[nmax_]:=Module[{\[CapitalGamma]B,WB,\[Psi],left,right},
\[CapitalGamma]B =- DiagonalMatrix@Diagonal@\[DoubleStruckCapitalW]B;
WB = \[DoubleStruckCapitalW]B+\[CapitalGamma]B;
\[Psi] = WB . Inverse[\[CapitalGamma]B];
left=\[ScriptCapitalC] y . \[DoubleStruckCapitalW]AB . Inverse[\[CapitalGamma]B];
right = \[DoubleStruckCapitalW]BA . x;
Table[{n+2,left . MatrixPower[\[Psi],n] . right},{n,0,nmax}]
]


(* ::Input::Initialization:: *)
Clear[excursionActivity]
excursionActivity[]:=Simplify@excursionAverage[ConstantArray[1,{Length@W[[2]],Length@W[[2]]}]]


(* ::Input::Initialization:: *)
Clear[excursionActivityVariance]
excursionActivityVariance[]:=Module[{\[CapitalGamma]B,WB,\[Psi],ENB},
\[CapitalGamma]B =- DiagonalMatrix@Diagonal@\[DoubleStruckCapitalW]B;
WB = \[DoubleStruckCapitalW]B+\[CapitalGamma]B;
\[Psi] = WB . Inverse[\[CapitalGamma]B];
ENB = excursionActivity[]-2;
\[ScriptCapitalC](2 uB . WB . M . WB . pB) + ENB(1-ENB)
]


(* ::Input::Initialization:: *)
Clear[excursionAverage]
excursionAverage[\[Nu]_]:=Module[{tab,res},
excursionLoadTilted[\[Nu]];
tab=Table[\[ScriptCapitalC] y . (WtAB[[\[Alpha]]] . M . \[DoubleStruckCapitalW]BA + \[DoubleStruckCapitalW]AB . M . WtBA[[\[Alpha]]] + \[DoubleStruckCapitalW]AB . M . WtB[[\[Alpha]]] . M . \[DoubleStruckCapitalW]BA) . x,{\[Alpha],nCOs}];
res=If[nCOs===1,tab[[1]],tab];
excursionClearTilted[];
res
]


(* ::Input::Initialization:: *)
Clear[excursionCovarianceMatrix]
excursionCovarianceMatrix[\[Nu]_]:=Module[{part1,part2,part3,part4,matrix,mom1,mom2,cov,res},
mom1 = Flatten@{excursionAverage[\[Nu]]};
excursionLoadTilted[\[Nu]];
mom2 = Table[
part1 = WtAB[[\[Alpha]]] . M . WtBA[[\[Beta]]] + WtAB[[\[Beta]]] . M . WtBA[[\[Alpha]]];
part2 = \[DoubleStruckCapitalW]AB . M . WtB[[\[Alpha]]] . M . WtB[[\[Beta]]] . M . \[DoubleStruckCapitalW]BA+\[DoubleStruckCapitalW]AB . M . WtB[[\[Beta]]] . M . WtB[[\[Alpha]]] . M . \[DoubleStruckCapitalW]BA+\[DoubleStruckCapitalW]AB . M . WttB[[\[Alpha],\[Beta]]] . M . \[DoubleStruckCapitalW]BA ;
part3 = WttAB[[\[Alpha],\[Beta]]] . M . \[DoubleStruckCapitalW]BA + \[DoubleStruckCapitalW]AB . M . WttBA[[\[Alpha],\[Beta]]];
part4 = WtAB[[\[Alpha]]] . M . WtB[[\[Beta]]] . M . \[DoubleStruckCapitalW]BA+WtAB[[\[Beta]]] . M . WtB[[\[Alpha]]] . M . \[DoubleStruckCapitalW]BA+\[DoubleStruckCapitalW]AB . M . WtB[[\[Alpha]]] . M . WtBA[[\[Beta]]]+\[DoubleStruckCapitalW]AB . M . WtB[[\[Beta]]] . M . WtBA[[\[Alpha]]];

\[ScriptCapitalC] y . (part1+part2+part3+part4) . x
,{\[Alpha],nCOs},{\[Beta],nCOs}
];

cov=mom2 - Outer[Times,mom1,mom1];
res=If[nCOs===1,cov[[1,1]],cov];
excursionClearTilted[];
res
]


(* ::Input::Initialization:: *)
Clear[excursionQT]
excursionQT[\[Nu]_]:=Module[{tab,res},
excursionLoadTilted[\[Nu]];
tab=Table[\[ScriptCapitalC](y . WtAB[[\[Alpha]]] . M . M . \[DoubleStruckCapitalW]BA . x +y . \[DoubleStruckCapitalW]AB . M . M . WtB[[\[Alpha]]] . M . \[DoubleStruckCapitalW]BA . x + y . \[DoubleStruckCapitalW]AB . M . WtB[[\[Alpha]]] . M . M . \[DoubleStruckCapitalW]BA . x + y . \[DoubleStruckCapitalW]AB . M . M . WtBA[[\[Alpha]]] . x),{\[Alpha],nCOs}];
res=If[nCOs===1,tab[[1]],tab];
excursionClearTilted[];
res
]


(* ::Input::Initialization:: *)
(* z,zp are counted from the full dA+dB dimension *)
Clear[excursionSingleTransitionProb];
excursionSingleTransitionProb[z_,zp_,nmax_]:=Module[{\[Beta],\[Gamma]},
If[z<=dA||zp<=dA,Print["zz' not in B"];Abort[]];
\[Beta] = \[ScriptCapitalC] W[[z,zp]] y . \[DoubleStruckCapitalW]AB . M . Proj[dB,z-dA,zp-dA] . M . \[DoubleStruckCapitalW]BA . x;
\[Gamma] = W[[z,zp]] M[[zp-dA,z-dA]];
Join[{1-\[Beta]/(1+\[Gamma])},Table[(\[Beta] \[Gamma]^(n-1))/(1+\[Gamma])^(n+1),{n,1,nmax}]]
]


(* ::Input::Initialization:: *)
(* Same. And zs,zps are vectors *)
(* The method used here, based on projections, is not yet written down in the overleaf *)
Clear[excursionMultiTransitionProb];
excursionMultiTransitionProb[transitions_,ns_]:=Module[{\[Beta],\[Gamma],a,b,zs,zps,as,bs,Ps,P,list,perms,string,res},
{zs,zps}=transitions\[Transpose];
If[Max@zs<=dA||Max@zps<=dA,Print["zz' not in B"];Abort[]];
\[Beta] = \[ScriptCapitalC] Table[Sqrt[W[[zs[[i]],zps[[i]]]]W[[zs[[j]],zps[[j]]]] ]y . \[DoubleStruckCapitalW]AB . M . Proj[dB,zs[[i]]-dA,zps[[j]]-dA] . M . \[DoubleStruckCapitalW]BA . x,{i,Length@zs},{j,Length@zps}]\[Transpose];

\[Gamma] =Table[Sqrt[W[[zs[[i]],zps[[i]]]]W[[zs[[j]],zps[[j]]]] ] M[[zps[[i]]-dA,zs[[j]]-dA]],{i,Length@zs},{j,Length@zps}];
a = Inverse[Eye[\[Gamma]]+\[Gamma]] . \[Beta] . Inverse[Eye[\[Gamma]]+\[Gamma]];
b = \[Gamma] . Inverse[Eye[\[Gamma]]+\[Gamma]];
(*{\[Beta],\[Gamma],a,b}*)
Ps = Table[Proj[Length@transitions,i,i],{i,Length@transitions}];
as = Table[P . a,{P,Ps}];
bs = Table[P . b,{P,Ps}];

res=Table[
If[Total@n===0,1-Tr[\[Beta] . Inverse[Eye[\[Gamma]]+\[Gamma]]],
(
list=Flatten@Table[ConstantArray[i,n[[i]]],{i,Length@n}];
Print[list];
perms = Permutations[list];
Total@Table[
string = Join[{as[[perm[[1]]]]},Table[bs[[perm[[j]]]],{j,2,Length@perm}]];
Tr[Dot@@string],{perm,perms}]
)]
,{n,If[Length@Dimensions@ns===2,ns,{ns}]}];

If[Length@Dimensions@ns===2,res,res[[1]]]

]


(* ::Input::Initialization:: *)
Clear[LyapunovEigen]
LyapunovEigen[W_,F_]:=Module[{\[ScriptCapitalI],\[CapitalLambda],S,Sinv},
{\[CapitalLambda],S}=Quiet@Eigensystem[W];
S = S\[Transpose];
Sinv = Inverse[S];

\[ScriptCapitalI] = 1/Outer[Plus,\[CapitalLambda],\[CapitalLambda]\[Conjugate]] Sinv . F . Sinv\[ConjugateTranspose];
S . \[ScriptCapitalI] . S\[ConjugateTranspose]//Chop
];


(* ::Input::Initialization:: *)
Clear[LyapunovLinearSys];
LyapunovLinearSys[W_,F_]:=Unvec@LinearSolve[Eye[W]\[CircleTimes]W+W\[Conjugate]\[CircleTimes] Eye[W],Vec[F]]


(* ::Input::Initialization:: *)
Clear[LyapunovDynamics];
LyapunovDynamics[W_,F_,\[ScriptCapitalC]0_,tf_,quiet_:False]:=Module[{WW,WWd,eqs,\[ScriptCapitalC],time,FF,\[DoubleStruckCapitalI],\[ScriptCapitalF]},
Clear[t];
WW = Normal[W]//Simplify;
WWd = WW\[ConjugateTranspose]/.Conjugate[t]->t//Simplify;
FF = Simplify@Normal[F];
\[ScriptCapitalF][t_?NumericQ]:=Evaluate@FF; 
\[DoubleStruckCapitalI] = NEye[\[ScriptCapitalC]0];
eqs = {
\[ScriptCapitalC]'[t]==-(WW . \[ScriptCapitalC][t]+\[ScriptCapitalC][t] . WWd)+\[ScriptCapitalF][t],
\[ScriptCapitalC][0]==Normal[\[ScriptCapitalC]0]//Simplify};
(*Print[eqs];*)
If[quiet===False,
(Monitor[
NDSolveValue[eqs,\[ScriptCapitalC],{t,0,tf},
StepMonitor:>(time=t)],
If[NumberQ[time],ProgressIndicator[time/tf],""]]
),(
NDSolveValue[eqs,\[ScriptCapitalC],{t,0,tf}])
]
]


(* ::Input::Initialization:: *)
Clear[BDMatrices]
BDMatrices[h_,\[Gamma]_,f_]:=Module[{L=Length@h,\[CapitalGamma],F0},
\[CapitalGamma] =If[Length@\[Gamma]===Length@h, SparseArray@DiagonalMatrix@\[Gamma],SparseArray[{{1,1}->\[Gamma],{L,L}->\[Gamma]},{L,L}]];
F0 =Which[
Length@f===Length@h, SparseArray@DiagonalMatrix@f ,
Length@f === 2,SparseArray[{{1,1}-> f[[1]],{L,L}-> f[[2]]},{L,L}],
True,f Eye[L]
];
{I h + \[CapitalGamma]/2, \[CapitalGamma] F0}
]

BDMatrices[V_,L_,\[Gamma]_,f_]:=Module[{\[CapitalGamma],A,W,F,g,h,i}, 
BDMatrices[TightBindingHamiltonian[L,V], \[Gamma],f]
];



(* ::Input::Initialization:: *)
Clear[BDCovMat];
BDCovMat[W_,F_]:=LyapunovEigen[W,F]
BDCovMat[h_,\[Gamma]_,{f1_,fL_}]:=LyapunovEigen@@BDMatrices[h,\[Gamma],{f1,fL}];
BDCovMat[V_,L_,\[Gamma]_,{f1_,fL_}]:=LyapunovEigen@@BDMatrices[V,L,\[Gamma],{f1,fL}]


(* ::Input::Initialization:: *)
(*(* Only holds for nearest-neighbor tight-binding models *)
Clear[BDCurrent];
BDCurrent[\[ScriptCapitalC]_]:=(*Im@\[ScriptCapitalC]\[LeftDoubleBracket]2,1\[RightDoubleBracket]*) -\[ImaginaryI] (\[ScriptCapitalC]\[LeftDoubleBracket]2,1\[RightDoubleBracket]-\[ScriptCapitalC]\[LeftDoubleBracket]1,2\[RightDoubleBracket])//Chop;
BDCurrent[W_,F_]:=BDCurrent[LyapunovEigen[W,F]]
BDCurrent[h_,\[Gamma]_,{f1_,fL_}]:=BDCurrent[LyapunovEigen@@BDMatrices[h,\[Gamma],{f1,fL}]];
BDCurrent[V_,L_,\[Gamma]_,{f1_,fL_}]:=BDCurrent[LyapunovEigen@@BDMatrices[V,L,\[Gamma],{f1,fL}]];*)


(* ::Input::Initialization:: *)
Clear[BDCurrent];
BDCurrent[W_,\[ScriptCapitalC]_]:=Module[{H = (W-W\[ConjugateTranspose])/(2I)},Table[I (H[[k,i]] \[ScriptCapitalC][[i,k]]-\[ScriptCapitalC][[k,i]] H[[i,k]]),{i,Length@\[ScriptCapitalC]},{k,Length@\[ScriptCapitalC]}]]


(* ::Input::Initialization:: *)
Clear[BDDictionary];
BDDictionary[lists_,couplings_]:=Module[{numparts = Length@lists,localdims,dict,H0,d,V,e,i,c,H,W,\[CapitalGamma],F,F0},
localdims = Table[Length[e[[2]]],{e,lists}];
d = Total@localdims;
dict = flat1@Table[{e[[1]],Range[1,Length[e[[2]]]][[i]]},{e,lists},{i,Length[e[[2]]]}];
dict = Association@Table[dict[[i]]->i,{i,Length@dict}];
(*dict["couplings"]=couplings;*)
H0 = BlockDiagonalMatrix[Table[e[[2]],{e,lists}]];
V = ConstantArray[0,{d,d}];
Do[V[[dict[c[[1]]],dict[c[[2]]]]] = c[[3]],{c,couplings}];
V = V+V\[ConjugateTranspose];
H = H0 + V;
\[CapitalGamma] = DiagonalMatrix@flat1@Table[If[Length@e==2,ConstantArray[0,Length[e[[2]]]],e[[3]]],{e,lists}];
F0 = DiagonalMatrix@flat1@Table[If[Length@e==2,ConstantArray[0,Length[e[[2]]]],e[[4]]],{e,lists}];
F = \[CapitalGamma] F0;
W = I H + \[CapitalGamma]/2;
{dict,W,F}
];


(* ::Input::Initialization:: *)
Clear[BDDictionaryCurrent]
BDDictionaryCurrent[dict_,W_,\[ScriptCapitalC]_]:=Module[{couplings,c,c2,cq,H,\[ScriptCapitalJ],Jdict,e,f,\[ScriptCapitalJ]up},
H = (W-W\[ConjugateTranspose])/(2I)//Chop;
(*\[ScriptCapitalJ] =Chop@Table[\[ImaginaryI] (H[[k,i]] \[ScriptCapitalC][[i,k]]-\[ScriptCapitalC][[k,i]] H[[i,k]]),{i,Length@\[ScriptCapitalC]},{k,Length@\[ScriptCapitalC]}];*)
\[ScriptCapitalJ] =Chop[I (\[ScriptCapitalC] H\[Transpose]-\[ScriptCapitalC]\[Transpose] H)];
\[ScriptCapitalJ]up = UpperTriangularize@Chop@\[ScriptCapitalJ];
Jdict = Select[Association@Table[{e,f}->\[ScriptCapitalJ]up[[dict[e],dict[f]]],{e,Keys@dict},{f,Keys@dict}],Not[#===0.]&&Not[#===0]&];
{\[ScriptCapitalJ],Jdict}
]


(* ::Input::Initialization:: *)
Clear[DephasingSolve];
DephasingSolve[W_,F_,\[CapitalGamma]_]:=Module[{L = Length@W,vecW,vecRemoveDiag,vecF},
vecW = kron[W\[Conjugate],NEye[L]]+kron[NEye[L],W];
vecRemoveDiag = SparseArray[{i_,i_}/;Last@QuotientRemainder[i,L+1]!=1->1,{L^2,L^2}];
LinearSolve[vecW + \[CapitalGamma] vecRemoveDiag, Vec[F]]//Unvec//Chop
]


(* ::Input::Initialization:: *)
Clear[BDCovMatDephasing];
BDCovMatDephasing[W_,F_,\[CapitalGamma]_]:=DephasingSolve[W,F,\[CapitalGamma]];
BDCovMatDephasing[h_,\[Gamma]_,{f1_,fL_},\[CapitalGamma]_]:=Module[{W,F} ,
{W,F} = BDMatrices[h,\[Gamma],{f1,fL}];
DephasingSolve[W,F,\[CapitalGamma]]
];
BDCovMatDephasing[V_,L_,\[Gamma]_,{f1_,fL_},\[CapitalGamma]_]:=Module[{W,F} ,
{W,F} = BDMatrices[V,L,\[Gamma],{f1,fL}];
DephasingSolve[W,F,\[CapitalGamma]]
];



(* ::Input::Initialization:: *)
(* Only holds for nearest-neighbor tight-binding models *)
Clear[BDCurrentDephasing];
BDCurrentDephasing[\[ScriptCapitalC]_]:=(*Im@\[ScriptCapitalC]\[LeftDoubleBracket]2,1\[RightDoubleBracket]*) -I (\[ScriptCapitalC][[2,1]]-\[ScriptCapitalC][[1,2]])//Chop;
BDCurrentDephasing[W_,F_,\[CapitalGamma]_]:=BDCurrentDephasing[BDCovMatDephasing[W,F,\[CapitalGamma]]]
BDCurrentDephasing[h_,\[Gamma]_,{f1_,fL_},\[CapitalGamma]_]:=BDCurrentDephasing[BDCovMatDephasing[h,\[Gamma],{f1,fL},\[CapitalGamma]]];
BDCurrentDephasing[V_,L_,\[Gamma]_,{f1_,fL_},\[CapitalGamma]_]:=BDCurrentDephasing[BDCovMatDephasing[V,L,\[Gamma],{f1,fL},\[CapitalGamma]]];


(* ::Input::Initialization:: *)
Clear[CovMatRhoFromC];
CovMatRhoFromC[\[ScriptCapitalC]_,statistic_:"Fermions"]:=Module[{\[DoubleStruckCapitalI] = Eye[Length@\[ScriptCapitalC]],\[Lambda],V,Z,M},
{\[Lambda],V} = Eigsys[\[ScriptCapitalC]];
If[matchString["Fermions", statistic],
Z = 1/Det[\[DoubleStruckCapitalI]-\[ScriptCapitalC]];
M=V . DiagonalMatrix[Log[(1-\[Lambda])/\[Lambda]]] . V\[ConjugateTranspose];
,
Z = Det[\[DoubleStruckCapitalI]+\[ScriptCapitalC]];
M=V . DiagonalMatrix[Log[(1+\[Lambda])/\[Lambda]]] . V\[ConjugateTranspose];
];
{M,Z}//Chop
]


(* ::Input::Initialization:: *)
Clear[CovMatEntropy];
CovMatEntropy[\[ScriptCapitalC]_,\[Alpha]_:1,statistic_:"Fermions"]:=Module[{\[DoubleStruckCapitalI] = Eye[Length@\[ScriptCapitalC]],Z,M,\[Lambda],V},
{\[Lambda],V} = Eigsys[\[ScriptCapitalC]];
If[matchString["Fermions", statistic],
Z = 1/Det[\[DoubleStruckCapitalI]-\[ScriptCapitalC]];
M=V . DiagonalMatrix[Log[(1-\[Lambda])/\[Lambda]]] . V\[ConjugateTranspose];
,
Z = Det[\[DoubleStruckCapitalI]+\[ScriptCapitalC]];
M=V . DiagonalMatrix[Log[(1+\[Lambda])/\[Lambda]]] . V\[ConjugateTranspose];
];
Chop@If[Abs[\[Alpha]-1]<10^-12,
Log[Z] + Tr[M . \[ScriptCapitalC]],
-\[Alpha]/(1-\[Alpha]) Log[Z] + 1/(1-\[Alpha]) If[matchString["Fermions", statistic],
Total@Log[1+((1-\[Lambda])/\[Lambda])^-\[Alpha]],-Total@Log[1-((1+\[Lambda])/\[Lambda])^-\[Alpha]]]]
]


(* ::Input::Initialization:: *)
Clear[CovMatRelativeEntropy];
CovMatRelativeEntropy[\[ScriptCapitalC]1_,\[ScriptCapitalC]2_,\[Alpha]_:1,statistic_:"Fermions"]:=Module[{\[DoubleStruckCapitalI] = Eye[Length@\[ScriptCapitalC]1],Z1,M1,\[Lambda]1,V1,Z2,M2,\[Lambda]2,V2,s,\[Zeta],\[Xi]},
{\[Lambda]1,V1} = Eigsys[\[ScriptCapitalC]1];
{\[Lambda]2,V2} = Eigsys[\[ScriptCapitalC]2];
If[matchString["Fermions", statistic],
Z1 = 1/Det[\[DoubleStruckCapitalI]-\[ScriptCapitalC]1];
M1=V1 . DiagonalMatrix[Log[(1-\[Lambda]1)/\[Lambda]1]] . V1\[ConjugateTranspose];
Z2 = 1/Det[\[DoubleStruckCapitalI]-\[ScriptCapitalC]2];
M2=V2 . DiagonalMatrix[Log[(1-\[Lambda]2)/\[Lambda]2]] . V2\[ConjugateTranspose]; 
,
Z1 = Det[\[DoubleStruckCapitalI]+\[ScriptCapitalC]1];
M1=V1 . DiagonalMatrix[Log[(1+\[Lambda]1)/\[Lambda]1]] . V1\[ConjugateTranspose];
Z2 = Det[\[DoubleStruckCapitalI]+\[ScriptCapitalC]2];
M2=V2 . DiagonalMatrix[Log[(1+\[Lambda]2)/\[Lambda]2]] . V2\[ConjugateTranspose]; 
];
s = If[matchString["Fermions", statistic],1,-1];

Chop@If[Abs[\[Alpha]-1]<10^-12,
-(Log[Z1] + Tr[M1 . \[ScriptCapitalC]1]) + Log[Z2] + Tr[M2 . \[ScriptCapitalC]1]
,
\[Zeta] = DiagonalMatrix[(\[Lambda]2/(1-s \[Lambda]2))^((1-\[Alpha])/(2\[Alpha]))] . V2\[ConjugateTranspose] . V1 . DiagonalMatrix[(\[Lambda]1/(1-s \[Lambda]1))] . V1\[ConjugateTranspose] . V2 . DiagonalMatrix[(\[Lambda]2/(1-s \[Lambda]2))^((1-\[Alpha])/(2\[Alpha]))]; 
\[Xi] = Eigvals[\[Zeta]];
Log[Z2]+\[Alpha]/(1-\[Alpha]) Log[Z1] - 1/(1-\[Alpha]) s Total@Log[1+s \[Xi]^\[Alpha]]
]
]


(* ::Input::Initialization:: *)
Clear[ReactionCoordinateMappingNumerics];
ReactionCoordinateMappingNumerics[Js_,\[Omega]s_]:=Module[{\[CapitalLambda]1,\[CapitalOmega]1,P,\[Omega],\[Omega]min,\[Omega]max,d\[Omega],Jnew},

\[Omega]min = First@\[Omega]s;
\[Omega]max = Last@\[Omega]s;
d\[Omega] = \[Omega]s[[2]]-\[Omega]s[[1]];

\[CapitalLambda]1 = Sqrt[1/(2\[Pi]) Trapz[Js,d\[Omega]]];
\[CapitalOmega]1 = 1/(2\[Pi] \[CapitalLambda]1^2) Trapz[\[Omega]s Js,d\[Omega]];

P = 1/\[Pi] Table[Trapz[Drop[Js,{i}]/Drop[\[Omega]s-\[Omega]s[[i]],{i}],d\[Omega]],{i,Length@\[Omega]s}]; 
Jnew = (4 \[CapitalLambda]1^2 Js)/(P^2+Js^2);
{\[CapitalLambda]1,\[CapitalOmega]1,Jnew}
]


(* ::Input::Initialization:: *)
StarToChainMapping[\[ScriptCapitalJ]s_,\[Omega]s_,Lb_]:=Module[{\[CapitalLambda]1,\[CapitalOmega]1,P,\[Omega],\[Omega]min,\[Omega]max,d\[Omega],Jnew,Js},

\[Omega]min = First@\[Omega]s;
\[Omega]max = Last@\[Omega]s;
d\[Omega] = \[Omega]s[[2]]-\[Omega]s[[1]];
Js=\[ScriptCapitalJ]s;
Table[
\[CapitalLambda]1 = Sqrt[1/(2\[Pi]) Trapz[Js,d\[Omega]]];
\[CapitalOmega]1 = 1/(2\[Pi] \[CapitalLambda]1^2) Trapz[\[Omega]s Js,d\[Omega]];

P = 1/\[Pi] Table[Trapz[Drop[Js,{i}]/Drop[\[Omega]s-\[Omega]s[[i]],{i}],d\[Omega]],{i,Length@\[Omega]s}]; 
Js = (4 \[CapitalLambda]1^2 Js)/(P^2+Js^2);
{\[CapitalLambda]1^2,\[CapitalOmega]1}
,{Lb}]
]


(* ::Input::Initialization:: *)
(* Function for sampling the energies and couplings of the mesoscopic leads approach *)
Clear[ThermleadsEnergySamples];
ThermleadsEnergySamples[Lb_,w_,\[CapitalGamma]_,type_:"linear"]:=Module[{energies,gammas,kappas,\[CapitalGamma]s,Llog,Llin,Wstar =w/2,logsamp,samples},
Which[
type==="linear",
(energies = linspace[-w,w,Lb];
gammas = ConstantArray[First@Differences@energies,Lb];
kappas = Sqrt[\[CapitalGamma] gammas/(2\[Pi])]
),
type==="newns",
((* \[ScriptCapitalJ](\[Epsilon]) = 8\[CapitalGamma]/(2\[Pi])Sqrt[1-\[Epsilon]^2/w^2]\[Theta](w-|\[Epsilon]|) *)
(* Define with a factor of 8 to make it comparable to the wideband limit *)

energies = linspace[-w,w,Lb];
gammas = ConstantArray[First@Differences@energies,Lb];
 \[CapitalGamma]s= 8 \[CapitalGamma]/(2\[Pi]) Sqrt[1-#^2/w^2]&/@energies; 

kappas = Sqrt[\[CapitalGamma]s gammas/(2\[Pi])]
),
type==="loglin",
(Llog = Round[0.2 Lb];
Llin=Lb -2 Round[0.2 Lb];
logsamp = logspace[Log10[Wstar],Log10[w],Llog+1];
samples=Join[
Most@Reverse[-logsamp],
linspace[-Wstar,Wstar,Llin+1],
Rest@logsamp];
energies = (Most@samples+Rest@samples)/2;
gammas = Differences[samples];
kappas = Sqrt[\[CapitalGamma] gammas/(2\[Pi])];
)

];

{energies,kappas,gammas}

]


(* ::Input::Initialization:: *)
Clear[ThermleadsMatrices];
ThermleadsMatrices[h_,\[CapitalGamma]_,{TL_,TR_,\[Mu]L_,\[Mu]R_},Lb_,w_,type_:"linear"]:=Module[{energies,couplings,gamma,Ls=Length@h,HB1,HB2,VS1,VS2,H,W,F,Fermis,ws=w/2},

{energies,couplings,gamma} = ThermleadsEnergySamples[Lb,w,\[CapitalGamma],type];

HB1 = DiagonalMatrix[energies];
HB2 = HB1;

VS1=Sum[couplings[[n]] Proj[{Lb,Ls},n,1],{n,Length@couplings}];
VS2=Sum[couplings[[n]] Proj[{Ls,Lb},Ls,n],{n,Length@couplings}];


H=ArrayFlatten[({
 {HB1, VS1, 0},
 {VS1\[ConjugateTranspose], h, VS2},
 {0, VS2\[ConjugateTranspose], HB2}
})]; 

Fermis[T_,\[Mu]_,energies_]:=1/(Exp[(energies-\[Mu])/T]+1) ;


W = I H + 1/2 DiagonalMatrix@Join[gamma,ConstantArray[0,Ls],gamma];

F = Quiet@DiagonalMatrix@Join[Fermis[TL,\[Mu]L,energies]gamma,ConstantArray[0,Ls],Fermis[TR,\[Mu]R,energies]gamma];

{W,F}
]


(* ::Input::Initialization:: *)
Clear[ThermleadsGetSysCM];
ThermleadsGetSysCM[\[ScriptCapitalC]_,Lb_]:=Module[{Ls = Length@\[ScriptCapitalC]-2Lb},\[ScriptCapitalC][[Lb+1;;Lb+Ls,Lb+1;;Lb+Ls]]]


(* ::Input::Initialization:: *)
Clear[ThermleadsDecomposeW];
ThermleadsDecomposeW[W_,Lb_,bath_]:=Module[{\[Gamma],\[Epsilon],Ls = Length@W-2Lb,rg,\[Kappa]},
rg = If[bath==="left",1;;Lb,Lb+Ls+1;;Ls+2Lb];
\[Gamma] = Diagonal[(W+W\[ConjugateTranspose])][[rg]];
\[Epsilon] = Im[Diagonal@W][[rg]];
\[Kappa] = If[bath=="left",Im@W[[Lb+1,rg]],Im@W[[Lb+Ls,rg]]];
{\[Epsilon],\[Kappa],\[Gamma]}//Chop
]


(* ::Input::Initialization:: *)
Clear[ThermleadsParticleCurrent];
ThermleadsParticleCurrent[\[ScriptCapitalC]_,W_,F_,Lb_,bath_:"left",energyResolved_:False]:=Module[{Ls = Length@\[ScriptCapitalC]-2Lb,\[Epsilon],\[Kappa],\[Gamma],rg,J1,J2,c1},
If[bath=="difference",1/2 (ThermleadsParticleCurrent[\[ScriptCapitalC],W,F,Lb,"left",energyResolved]-ThermleadsParticleCurrent[\[ScriptCapitalC],W,F,Lb,"right",energyResolved]),
(
rg = If[bath==="left",
Range[1,Lb],
Range[Lb+Ls+1,Lb+Ls+Lb]];
c1 = If[bath==="left",Lb+1,Lb+Ls];
{\[Epsilon],\[Kappa],\[Gamma]} = ThermleadsDecomposeW[W,Lb,bath];
J1 = I Table[\[Kappa][[i]] (\[ScriptCapitalC][[c1,rg[[i]]]]-\[ScriptCapitalC][[c1,rg[[i]]]]\[Conjugate]),{i,Lb}];
(*J2 = Table[F[[rg[[i]],rg[[i]]]]-\[Gamma][[i]] \[ScriptCapitalC][[rg[[i]],rg[[i]]]],{i,Lb}];*)
If[energyResolved===True,J1,Total@J1]//Chop
)]
]


(* ::Input::Initialization:: *)
Clear[ThermleadsEnergyCurrent];
ThermleadsEnergyCurrent[\[ScriptCapitalC]_,W_,F_,Lb_,bath_:"left",energyResolved_:False]:=Module[{Ls = Length@\[ScriptCapitalC]-2Lb,\[Gamma],\[Epsilon],\[Kappa],JEprx,JEartur,term1,term2,term3,rg,c1},
rg = If[bath==="left",
Range[1,Lb],
Range[Lb+Ls+1,Lb+Ls+Lb]];
c1 = If[bath==="left",Lb+1,Lb+Ls];

{\[Epsilon],\[Kappa],\[Gamma]} = ThermleadsDecomposeW[W,Lb,bath];
(* Relevant terms *)
(* tr(Subscript[H, L]\[ScriptCapitalL](\[Rho])) = \!\(
\*SubscriptBox[\(\[Sum]\), \(\(\ \)\(k\)\)]\(
\*SubscriptBox[\(\[Epsilon]\), \(k\)]
\*SubscriptBox[\(\[Gamma]\), \(k\)]\((
\*SubscriptBox[\(f\), \(k\)] - \[LeftAngleBracket]
\*SubsuperscriptBox[\(a\), \(k\), \(\[ConjugateTranspose]\)]
\*SubscriptBox[\(a\), \(k\)]\[RightAngleBracket])\)\)\) *)
term1 = Table[\[Epsilon][[i]] (F[[rg[[i]],rg[[i]]]]-\[Gamma][[i]] \[ScriptCapitalC][[rg[[i]],rg[[i]]]]),{i,Lb}]//Chop;

(* tr(Subscript[V, SL]\[ScriptCapitalL](\[Rho])) = -(1/2)\!\(
\*SubscriptBox[\(\[Sum]\), \(\(\ \)\(k\)\)]\(
\*SubscriptBox[\(\[Kappa]\), \(k\)]\ 
\*SubscriptBox[\(\[Gamma]\), \(k\)]\[LeftAngleBracket]
\*SubsuperscriptBox[\(c\), \(1\), \(\[ConjugateTranspose]\)]
\*SubscriptBox[\(a\), \(k\)] + 
\*SubsuperscriptBox[\(a\), \(k\), \(\[ConjugateTranspose]\)]
\*SubscriptBox[\(c\), \(1\)]\[RightAngleBracket]\)\) *)
term2 =-(1/2)Table[\[Kappa][[i]] \[Gamma][[i]](\[ScriptCapitalC][[c1,rg[[i]]]]+\[ScriptCapitalC][[c1,rg[[i]]]]\[Conjugate]),{i,Lb}]//Chop;

(* i \[LeftAngleBracket][Subscript[H, L],Subscript[V, SL]]\[RightAngleBracket] = -i Subscript[\[Epsilon], k]Subscript[\[Kappa], k] \[LeftAngleBracket]\!\(
\*SubsuperscriptBox[\(c\), \(1\), \(\[ConjugateTranspose]\)]
\*SubscriptBox[\(a\), \(k\)]\)-\!\(
\*SubsuperscriptBox[\(a\), \(k\), \(\[ConjugateTranspose]\)]
\*SubscriptBox[\(c\), \(1\)]\)\[RightAngleBracket] *)
term3 = I Table[\[Kappa][[i]] \[Epsilon][[i]](\[ScriptCapitalC][[c1,rg[[i]]]]-\[ScriptCapitalC][[c1,rg[[i]]]]\[Conjugate]),{i,Lb}]//Chop;


(* The two energy currents below only coincide in steady-state. Otherwise, JEartur is the correct one *);
(* Energy current in Marlon's PRX https://journals.aps.org/prx/pdf/10.1103/PhysRevX.10.031040*)
(* tr(Subscript[H, L]\[ScriptCapitalL](\[Rho])) + tr(Subscript[V, SL]\[ScriptCapitalL](\[Rho])) *)
JEprx = term1+term2;

(* Energy current in Artur's PRB https://journals.aps.org/prb/pdf/10.1103/PhysRevB.107.195117) *)
(* i \[LeftAngleBracket][Subscript[H, L],Subscript[V, SL]]\[RightAngleBracket] + tr(Subscript[V, SL]\[ScriptCapitalL](\[Rho])) *)
JEartur = term3+term2;

If[energyResolved===True,
{{JEprx,JEartur},{term1,term2,term3}},
{{Total@JEprx,Total@JEartur},{Total@term1,Total@term2,Total@term3}}]
]


(* ::Input::Initialization:: *)
(* Gives a matrix with entry \[ImaginaryI]  in site i of the system *)
Clear[ThermleadsDriveMatrix];
ThermleadsDriveMatrix[Lb_,Ls_,site_]:=SparseArray[{{j_,j_}/;j==Lb+site:>I},{Lb+Ls+Lb,Lb+Ls+Lb}]


(* ::Input::Initialization:: *)
Clear[BDFCSload];
BDFCSload[A_,{\[Gamma]\[Gamma]m_,\[Gamma]\[Gamma]p_},{\[Nu]\[Nu]m_,\[Nu]\[Nu]p_},\[Epsilon]\[Epsilon]_:0,statistic_:"boson",B_:0,{\[Phi]\[Phi]m_:0,\[Phi]\[Phi]p_:0}]:=Module[{tol = 10^-12,L = Length@A,size,fixMatSize,\[Gamma]p,\[Gamma]m,\[Nu]p,\[Nu]m,\[ScriptCapitalW],\[CapitalUpsilon],s,Vj, Vj2,Vd,\[CapitalGamma],\[CapitalOmega],\[CapitalTheta],f,r,\[Epsilon],\[DoubleStruckCapitalI],o,Kj,Kd,Jj,Jd,\[Phi]m,\[Phi]p},
LoadPauliMatrices[];

s = If[matchString[statistic,"boson"],1,-1] ;
\[CapitalOmega] = If[matchString[statistic,"boson"],I kron[\[Sigma]y,Eye[L]],-I Eye[2L]];
size = 2L;
(*size = If[Norm[B]< tol, L,2L];*)

\[DoubleStruckCapitalI]=Eye[size];

(* Adjust the matrices \[Gamma]p, \[Gamma]m, \[Nu]p, \[Nu]m to allow for multiple types of inputs *);
fixMatSize[mat_]:=Which[
Length@Dimensions@mat===1 &&Length@mat===2,
SparseArray[{{1,1}->mat[[1]],{L,L}->mat[[2]]},{L,L}],
Length@Dimensions@mat===1 &&Length@mat===L,
DiagonalMatrix@mat,
True,
mat];

\[Phi]m = \[Phi]\[Phi]m//DiagonalMatrix;
\[Phi]p = \[Phi]\[Phi]p//DiagonalMatrix;

\[Gamma]p = fixMatSize[\[Gamma]\[Gamma]p];
\[Gamma]m = fixMatSize[\[Gamma]\[Gamma]m];
\[Nu]p = fixMatSize[\[Nu]\[Nu]p];
\[Nu]m = fixMatSize[\[Nu]\[Nu]m];

\[CapitalGamma] = \[Gamma]m - s \[Gamma]p;

Vj = 1/2 \[Sigma]0\[CircleTimes] (\[Nu]p . \[Gamma]p + \[Nu]m . \[Gamma]m)+1/2 \[Sigma]y \[CircleTimes] (\[Nu]p . \[Gamma]p - \[Nu]m . \[Gamma]m);
Vj2 = 1/2 \[Sigma]0\[CircleTimes] (\[Nu]p . \[Nu]p . \[Gamma]p +\[Nu]m . \[Nu]m . \[Gamma]m)+1/2 \[Sigma]y \[CircleTimes] (\[Nu]p . \[Nu]p . \[Gamma]p -\[Nu]m . \[Nu]m . \[Gamma]m);
Vd=If[\[Phi]\[Phi]m===0&&\[Phi]\[Phi]p===0,
1/Sqrt[2] Join[Diagonal[\[Nu]p . Sqrt[\[Gamma]p]+\[Nu]m . Sqrt[\[Gamma]m]],I Diagonal[\[Nu]m . Sqrt[\[Gamma]m]-\[Nu]p . Sqrt[\[Gamma]p]]]//DiagonalMatrix,
1/Sqrt[2] Join[Diagonal[E^(-I \[Phi]p) \[Nu]p . Sqrt[\[Gamma]p]+E^(-I \[Phi]m) . \[Nu]m . Sqrt[\[Gamma]m]],I Diagonal[E^(-I \[Phi]m) . \[Nu]m . Sqrt[\[Gamma]m]-E^(-I \[Phi]p) . \[Nu]p . Sqrt[\[Gamma]p]]]//DiagonalMatrix
];

\[ScriptCapitalW] = I/2 (\[Sigma]0 \[CircleTimes] (A-A\[Transpose]) -\[Sigma]y \[CircleTimes] (A+A\[Transpose]) - I \[Sigma]x \[CircleTimes] (B+B\[Conjugate]) +\[Sigma]z \[CircleTimes] (B-B\[Conjugate])) + 1/2 \[Sigma]0 \[CircleTimes] \[CapitalGamma] ;
\[CapitalUpsilon] = If[matchString[statistic,"boson"],1/2 \[Sigma]0\[CircleTimes](\[Gamma]p + \[Gamma]m), -(1/2)\[Sigma]y \[CircleTimes] (\[Gamma]m-\[Gamma]p)];
\[CapitalTheta] = LyapunovSolve[\[ScriptCapitalW],\[CapitalUpsilon]];

\[Epsilon] = If[Norm[\[Epsilon]\[Epsilon]]<tol||matchString[statistic,"fermion"],ConstantArray[0,L],\[Epsilon]\[Epsilon]];

r = LinearSolve[\[ScriptCapitalW],\[CapitalOmega] . kron[1/Sqrt[2] ({
 {1, 1},
 {-I , I}
}),Eye[L]] . Join[\[Epsilon],\[Epsilon]\[Conjugate]]];
o = ConstantArray[1,size];

Jj = Tr[Vj . (s (\[CapitalTheta]-I \[CapitalOmega]/2)+out[r,r])]//Chop;
Kj = Tr[Vj2 . (s (\[CapitalTheta]-I \[CapitalOmega]/2)+out[r,r])];

Jd = o . (Vd+Vd\[ConjugateTranspose]) . r//Chop;
Kd = \[Nu]m^2+\[Nu]p^2//Total//First;

<|"size"->size,
"s"->s,
"statistic"->statistic,
"\[CapitalOmega]"->\[CapitalOmega]//Normal//Chop,
"\[DoubleStruckCapitalI]"->\[DoubleStruckCapitalI]//Normal//Chop,
"\[Gamma]p"->\[Gamma]p//Normal//Chop,
"\[Gamma]m"->\[Gamma]m//Normal//Chop,
"\[Nu]p"->\[Nu]p//Normal//Chop,
"\[Nu]m"->\[Nu]m//Normal//Chop,
"\[CapitalGamma]"->\[CapitalGamma]//Normal//Chop,
"\[ScriptCapitalW]"->\[ScriptCapitalW]//Normal//Chop,
"\[CapitalUpsilon]"->\[CapitalUpsilon]//Normal//Chop,
"Vj"->Vj//Normal//Chop,
"Vd"->Vd//Normal//Chop,
"\[CapitalTheta]"->\[CapitalTheta]//Normal//Chop,
"r"->r//Normal//Chop,
"o"->o//Normal//Chop,
"Jj"->Jj//Normal//Chop,
"Jd"->Jd//Normal//Chop,
"Kj"->Kj//Normal//Chop,
"Kd"->Kd//Normal//Chop
|>
]


(* ::Input::Initialization:: *)
Clear[BDFCSTwoPointFunction];
BDFCSTwoPointFunction[tts_,\[DoubleStruckCapitalL]_,type_:"jump"]:=Module[{G,\[CapitalTheta]t,g,V,r = \[DoubleStruckCapitalL]["r"],s = \[DoubleStruckCapitalL]["s"],ts,o = \[DoubleStruckCapitalL]["o"],F},
ts = Flatten@{tts};
G[\[Tau]_]:=MatrixExp[-\[DoubleStruckCapitalL]["\[ScriptCapitalW]"] \[Tau]];
\[CapitalTheta]t =\[DoubleStruckCapitalL]["\[CapitalTheta]"]-I \[DoubleStruckCapitalL]["\[CapitalOmega]"]/2; 

F = If[matchString[type,"jump"],
V = \[DoubleStruckCapitalL]["Vj"];
Table[g = G[\[Tau]]; {\[Tau],Tr[g\[ConjugateTranspose] . (V\[Transpose]+s V) . g . \[CapitalTheta]t . V . \[CapitalTheta]t] + r . (V . \[CapitalTheta]t . g\[ConjugateTranspose] . (V\[Transpose]+V) + (V\[Transpose]+V) . g . \[CapitalTheta]t . V) . r},{\[Tau],ts}],
V = \[DoubleStruckCapitalL]["Vd"];
Table[g = G[\[Tau]]; {\[Tau],o . ((V+V\[ConjugateTranspose]) . g . \[CapitalTheta]t . V\[ConjugateTranspose]+V . \[CapitalTheta]t . g\[ConjugateTranspose] . (V+V\[ConjugateTranspose])) . o},{\[Tau],ts}]
];
If[Length@tts===0,F[[1,2]],F]//Chop
];


(* ::Input::Initialization:: *)
Clear[BDFCSPowerSpectrum];
BDFCSPowerSpectrum[\[Omega]\[Omega]s_,\[DoubleStruckCapitalL]_,type_:"jump"]:=Module[{\[Omega]s,K,\[CapitalTheta]t,V,rhs,Bp,Bm,\[Xi],\[ScriptCapitalW] = \[DoubleStruckCapitalL]["\[ScriptCapitalW]"],r = \[DoubleStruckCapitalL]["r"],s = \[DoubleStruckCapitalL]["s"],o = \[DoubleStruckCapitalL]["o"],S,\[DoubleStruckCapitalI]=\[DoubleStruckCapitalL]["\[DoubleStruckCapitalI]"]},
\[Omega]s = Flatten@{\[Omega]\[Omega]s};
K = If[matchString[type,"jump"],\[DoubleStruckCapitalL]["Kj"],\[DoubleStruckCapitalL]["Kd"]];
\[CapitalTheta]t =\[DoubleStruckCapitalL]["\[CapitalTheta]"]-I \[DoubleStruckCapitalL]["\[CapitalOmega]"]/2; 

S=If[matchString[type,"jump"],

V = \[DoubleStruckCapitalL]["Vj"];
rhs = \[CapitalTheta]t . V . \[CapitalTheta]t;
Table[
Bp = LyapunovSolve[\[ScriptCapitalW]-I (\[Omega]/2) \[DoubleStruckCapitalI],\[ScriptCapitalW]\[ConjugateTranspose]-I (\[Omega]/2) \[DoubleStruckCapitalI],rhs];
Bm = LyapunovSolve[\[ScriptCapitalW]+I( \[Omega]/2) \[DoubleStruckCapitalI],\[ScriptCapitalW]\[ConjugateTranspose]+I( \[Omega]/2) \[DoubleStruckCapitalI],rhs];
\[Xi] =LinearSolve[\[ScriptCapitalW] . \[ScriptCapitalW] + \[Omega]^2 \[DoubleStruckCapitalI],\[ScriptCapitalW] . \[CapitalTheta]t . V];
{\[Omega],K+Tr[(Bp+Bm) . (V\[Transpose]+s V)] + 2r . ((V\[Transpose]+V) . \[Xi] + \[Xi]\[ConjugateTranspose] . (V\[Transpose]+V)) . r},{\[Omega],\[Omega]s}]

,(* *)

V = \[DoubleStruckCapitalL]["Vd"];
Table[
\[Xi] =LinearSolve[\[ScriptCapitalW] . \[ScriptCapitalW] + \[Omega]^2 \[DoubleStruckCapitalI],\[ScriptCapitalW] . \[CapitalTheta]t . V\[ConjugateTranspose]];
{\[Omega],K+ 2o . ((V\[ConjugateTranspose]+V) . \[Xi] + \[Xi]\[ConjugateTranspose] . (V\[ConjugateTranspose]+V)) . o},{\[Omega],\[Omega]s}]
];

If[Length@\[Omega]\[Omega]s===0,S[[1,2]],S]//Chop

]


(* ::Input::Initialization:: *)
Clear[BDFCSNoise];
BDFCSNoise[\[DoubleStruckCapitalL]_,type_:"jump"]:=Module[{K,\[CapitalTheta]t,rhs,B0,\[Xi],V,\[ScriptCapitalW] = \[DoubleStruckCapitalL]["\[ScriptCapitalW]"],r = \[DoubleStruckCapitalL]["r"],s = \[DoubleStruckCapitalL]["s"],o = \[DoubleStruckCapitalL]["o"],S,\[DoubleStruckCapitalI]=\[DoubleStruckCapitalL]["\[DoubleStruckCapitalI]"]},
K = If[matchString[type,"jump"],\[DoubleStruckCapitalL]["Kj"],\[DoubleStruckCapitalL]["Kd"]];
\[CapitalTheta]t =\[DoubleStruckCapitalL]["\[CapitalTheta]"]-I \[DoubleStruckCapitalL]["\[CapitalOmega]"]/2; 

If[matchString[type,"jump"],

V = \[DoubleStruckCapitalL]["Vj"];
rhs = \[CapitalTheta]t . V . \[CapitalTheta]t;
B0 = LyapunovSolve[\[ScriptCapitalW],rhs];
\[Xi] =LinearSolve[\[ScriptCapitalW],\[CapitalTheta]t . V];
K+2Tr[B0 . (V\[Transpose]+s V)] + 2r . ((V\[Transpose]+V) . \[Xi] + \[Xi]\[ConjugateTranspose] . (V\[Transpose]+V)) . r

, (* *)
V = \[DoubleStruckCapitalL]["Vd"];
\[Xi] =LinearSolve[\[ScriptCapitalW],\[CapitalTheta]t . V\[ConjugateTranspose]];
K+ 2o . ((V\[ConjugateTranspose]+V) . \[Xi] + \[Xi]\[ConjugateTranspose] . (V\[ConjugateTranspose]+V)) . o
]//Chop

]


(* ::Input::Initialization:: *)
Clear[BDEmissionSpectra];
BDEmissionSpectra[W_,F_,\[Omega]s_]:=Module[{\[ScriptCapitalC],\[DoubleStruckCapitalI],inv1,inv2},
\[ScriptCapitalC] = BDCovMat[W,F];
\[DoubleStruckCapitalI] = Eye[Length@W];
Table[
inv1 = Inverse[W\[ConjugateTranspose]+I \[Omega] \[DoubleStruckCapitalI] ];
inv2 = Inverse[W-I \[Omega] \[DoubleStruckCapitalI]];
\[ScriptCapitalC] . inv1+inv2 . \[ScriptCapitalC],{\[Omega],\[Omega]s}]//Chop
]


(* ::Input::Initialization:: *)
(* Fermions *) 
Clear[BDAbsorptionSpectra];
BDAbsorptionSpectra[W_,F_,\[Omega]s_]:=Module[{\[ScriptCapitalC],\[DoubleStruckCapitalI],inv1,inv2,\[ScriptCapitalC]b},
\[DoubleStruckCapitalI] = Eye[Length@W];
\[ScriptCapitalC] = BDCovMat[W,F];
\[ScriptCapitalC]b = \[DoubleStruckCapitalI]-\[ScriptCapitalC];

Table[
inv1 = Inverse[W\[ConjugateTranspose]+I \[Omega] \[DoubleStruckCapitalI] ];
inv2 = Inverse[W-I \[Omega] \[DoubleStruckCapitalI]];
\[ScriptCapitalC]b . inv1+inv2 . \[ScriptCapitalC]b,{\[Omega],\[Omega]s}]//Chop
]


(* ::Input::Initialization:: *)
Clear[ThermleadsFCSGMatrix];
ThermleadsFCSGMatrix[W_,Lb_,type_:"particle",bath_:"left"]:=Module[{\[Gamma],\[Epsilon],\[CapitalLambda],G,Ls = Length@W-2Lb},
{\[Gamma],\[Epsilon],\[CapitalLambda]}= ThermleadsDecomposeW[W,Lb,bath];
G=Which[
type=="particle"&&bath=="left",
SparseArray[{{Lb+1,j_}/;1<=j<=Lb:>\[CapitalLambda][[j]]},{Lb+Ls+Lb,Lb+Ls+Lb}],
type=="energy"&&bath=="left",
SparseArray[{{Lb+1,j_}/;1<=j<=Lb:>(\[CapitalLambda](\[Epsilon]-I \[Gamma]/2))[[j]]},{Lb+Ls+Lb,Lb+Ls+Lb}],
type=="particle"&&bath=="right",
SparseArray[{{Lb+Ls,j_}/;Lb+Ls+1<=j<=2Lb+Ls:>\[CapitalLambda][[j-Lb-Ls]]},{Lb+Ls+Lb,Lb+Ls+Lb}],
type=="energy"&&bath=="right",
SparseArray[{{Lb+Ls,j_}/;Lb+Ls+1<=j<=2Lb+Ls:>(\[CapitalLambda](\[Epsilon]-I \[Gamma]/2))[[j-Lb-Ls]]},{Lb+Ls+Lb,Lb+Ls+Lb}],
type=="particle"&&bath=="difference",
SparseArray[{
{Lb+1,j_}/;1<=j<=Lb:>\[CapitalLambda][[j]],
{Lb+Ls,j_}/;Lb+Ls+1<=j<=2Lb+Ls:>-\[CapitalLambda][[j-Lb-Ls]]
},{Lb+Ls+Lb,Lb+Ls+Lb}]
];
G=G-G\[ConjugateTranspose]
]


(* ::Input::Initialization:: *)
Clear[ThermleadsFCSCurrent];
ThermleadsFCSCurrent[\[ScriptCapitalC]_,W_,F_,Lb_,bath_:"left"]:=Module[{G,Ls = Length@W-2Lb},
G=ThermleadsFCSGMatrix[W,Lb,"particle",bath];
-I Tr[G . \[ScriptCapitalC]]//Chop
]


(* ::Input::Initialization:: *)
Clear[ThermleadsFCSNoise]
ThermleadsFCSNoise[\[ScriptCapitalC]_,W_,F_,Lb_,bath_:"left"]:=Module[{\[DoubleStruckCapitalI] = Eye[Length@W],\[ScriptCapitalC]t,Ls = Length@W-2Lb,G,\[Psi]},
\[DoubleStruckCapitalI] = Eye[Lb+Ls+Lb];
G=ThermleadsFCSGMatrix[W,Lb,"particle",bath];
\[ScriptCapitalC]t = BDCovMat[W,- (1/2)((\[DoubleStruckCapitalI]-\[ScriptCapitalC]) . G . \[ScriptCapitalC]+ \[ScriptCapitalC] . G . (\[DoubleStruckCapitalI]-\[ScriptCapitalC]))];
2Tr[G . \[ScriptCapitalC]t]//Chop
]


(* ::Input::Initialization:: *)
Clear[ThermleadsFCSCurrentEnergyResolved];
ThermleadsFCSCurrentEnergyResolved[\[ScriptCapitalC]_,W_,F_,Lb_,bath_:"left"]:=Module[{\[CapitalLambda],Ls = Length@W-2Lb},
\[CapitalLambda]= Last@ThermleadsDecomposeW[W,Lb,bath];
If[bath=="left",
Table[2\[CapitalLambda][[j]] Im@\[ScriptCapitalC][[j,Lb+1]],{j,Lb}],
Table[2\[CapitalLambda][[j]] Im@\[ScriptCapitalC][[Lb+Ls+j,Lb+Ls]],{j,Lb}]
]//Chop
]


(* ::Input::Initialization:: *)
(* \[ScriptCapitalT]=tr(Subscript[\[CapitalGamma], 1]Subscript[G\[CapitalGamma], L]G\[ConjugateTranspose]) = \[LeftAngleBracket]1|S1/(\[CapitalLambda]-i \[Epsilon])S^-1|L\[RightAngleBracket]\[LeftAngleBracket]L| S^-1\[ConjugateTranspose]1/(\[CapitalLambda]\[ConjugateTranspose]+i \[Epsilon])S\[ConjugateTranspose]|1\[RightAngleBracket] = |\!\(
\*SubscriptBox[\(\[Sum]\), \(k\)]\ 
\*FractionBox[
SubscriptBox[\(
\*SubscriptBox[\(S\), \(1 k\)](
\*SuperscriptBox[\(S\), \(-1\)])\), \(kL\)], \(
\*SubscriptBox[\(\[CapitalLambda]\), \(k\)] - i\ \[Epsilon]\)]\)(|^2) *)
NEGFTransmissionFunction[h_,\[Gamma]_]:=Module[{L=Length@h,\[CapitalGamma]1,\[CapitalGamma]L,W,\[CapitalLambda],S,Sinv},
\[CapitalGamma]1 = \[Gamma] Proj[L,1];
\[CapitalGamma]L = \[Gamma] Proj[L,L];
(*W = \[ImaginaryI] h + (\[CapitalGamma]1 + \[CapitalGamma]L)/2;*)
W = -(I/2)(\[CapitalGamma]1+\[CapitalGamma]L)+ h;
{\[CapitalLambda],S}=Quiet@Eigensystem[W];
S = S\[Transpose]//SparseArray;
\[CapitalLambda] = I \[CapitalLambda]//SparseArray;
Sinv = Inverse[S]//SparseArray;

Function[With[{u = S[[1]],v=Sinv[[All,L]],\[Lambda] = \[CapitalLambda]},Abs[\[Gamma] u . (1/(\[Lambda]-I #) v)]^2]]

];

NEGFTransmissionFunction[V_,L_,\[Gamma]_]:=NEGFTransmissionFunction[TightBindingHamiltonian[L,V],\[Gamma]]
NEGFTransmissionFunction[V_,L_,\[Gamma]_,J_]:=NEGFTransmissionFunction[TightBindingHamiltonian[L,V,J],\[Gamma]]


(* ::Input::Initialization:: *)
Clear[NEGFTransmissionFunctionFiniteBand]
NEGFTransmissionFunctionFiniteBand[h_,\[Gamma]_,bandwidth_,npts_:10^2]:=Module[{L=Length@h,\[CapitalGamma]1,\[CapitalGamma]L,W0,\[CapitalLambda]0,\[Epsilon]min,\[Epsilon]max,G,\[Epsilon]s,\[DoubleStruckCapitalI] = NEye[Length@h],tab,\[CapitalDelta]\[Epsilon]},
{\[Epsilon]min,\[Epsilon]max} = If[ArrayQ[bandwidth],bandwidth,{-bandwidth,bandwidth}];
\[Epsilon]s = Rest@Most@linspace[\[Epsilon]min,\[Epsilon]max,npts];
\[CapitalGamma]1 = \[Gamma] Proj[L,1];
\[CapitalGamma]L = \[Gamma] Proj[L,L];
\[CapitalDelta]\[Epsilon] =\[Epsilon]s[[2]]-\[Epsilon]s[[1]];

W0 = h - I/2 (\[CapitalGamma]1+\[CapitalGamma]L);
\[CapitalLambda]0 = 1/(2\[Pi]) (\[CapitalGamma]1+\[CapitalGamma]L);
tab=Table[
G = I Inverse[\[Epsilon] \[DoubleStruckCapitalI] - W0 - \[CapitalLambda]0 Log[(\[Epsilon]-\[Epsilon]min)/(\[Epsilon]max-\[Epsilon])]]; 
{\[Epsilon], Tr[\[CapitalGamma]1 . G . \[CapitalGamma]L . G\[ConjugateTranspose]]}
,{\[Epsilon],\[Epsilon]s}];
AppendTo[tab,{\[Epsilon]max,0}];
PrependTo[tab,{\[Epsilon]min,0}];

tab//Interpolation
]


(* ::Input::Initialization:: *)
Clear[FermiEnergyRegion];
FermiEnergyRegion[T_?NumberQ,\[Mu]_?NumberQ,prec_:10^-8]:=Module[{\[Beta]=1/T,log,emin,emax,energ},
log = Log[prec];
emin = \[Mu] + log/\[Beta];
emax = \[Mu] - log/\[Beta];
{emin,emax}//N
]

FermiEnergyRegion[{TL_,TR_,\[Mu]L_,\[Mu]R_},prec_:10^-8]:=Module[{rL,rR},
rL = FermiEnergyRegion[TL,\[Mu]L,prec];
rR = FermiEnergyRegion[TR,\[Mu]R,prec];
{Min[rL[[1]],rR[[1]]],Max[rL[[2]],rR[[2]]]}
]


(* ::Input::Initialization:: *)
LandauerButtikerAllAvailableProperties = {
"IN","IE","\[CapitalDelta]N","\[CapitalDelta]E","\[ScriptCapitalC]","Shyp","IQL","IQR","P","\[Sigma]","\[CapitalDelta]P","\[CapitalDelta]QL","\[CapitalDelta]QR","\[CapitalDelta]\[Sigma]","turN","turE","turP","turQL","turQR","fcorr","SNRN","SNRE","SNRP","SNRQL","SNRQR","SNR\[Sigma]","a","b","Slhyp","turlhyp","turhyp","RateIn","RateOut","Scl","Squ"
};


(* ::Input::Initialization:: *)
Clear[LandauerButtiker];
LandauerButtiker[\[ScriptCapitalT]_,{TL_,TR_,\[Mu]L_,\[Mu]R_},pprops_:All,em_:\[Infinity],pres_:MachinePrecision,maxrec_:\[Infinity]]:=Module[{\[Beta]L = 1/TL,\[Beta]R=1/TR,\[Delta]\[Beta],\[Delta]\[Mu],\[Delta]\[Beta]\[Mu],fL,fR,IN,IE,IQL,IQR,P,\[Sigma],\[CapitalDelta]N,\[CapitalDelta]E,\[ScriptCapitalC],\[CapitalDelta]P,\[CapitalDelta]QL,\[CapitalDelta]QR,\[CapitalDelta]\[Sigma],turN,turE,turP,turQL,turQR,a,b,Jlhyp,\[CapitalDelta]lhyp,SNRN,SNRE,SNRP,SNRQL,SNRQR,Slhyp,Shyp,hyperparameters,fcorr,turlhyp,turhyp,SNR\[Sigma],g,G,integralsNeeded,intsNeeded,\[DoubleStruckCapitalI],result,LandauerButtikerIntegrals,emm,tab,props},

props = Flatten@{pprops};
(* DEFINE AUXILIARY VARIABLES & FUNCTIONS *)
\[Delta]\[Beta] = \[Beta]L-\[Beta]R;
\[Delta]\[Mu] = \[Mu]L-\[Mu]R;
\[Delta]\[Beta]\[Mu] = \[Beta]L \[Mu]L - \[Beta]R \[Mu]R;
fL[\[Epsilon]_]:=1/(Exp[Rationalize[\[Beta]L,10^-8](\[Epsilon]-Rationalize[\[Mu]L,10^-8])]+1); 
fR[\[Epsilon]_]:=1/(Exp[Rationalize[\[Beta]R,10^-8](\[Epsilon]-Rationalize[\[Mu]R,10^-8])]+1);  
g[\[Epsilon]_]:=fL[\[Epsilon]](1-fL[\[Epsilon]])+fR[\[Epsilon]](1-fR[\[Epsilon]]);
G[\[Epsilon]_]:=\[ScriptCapitalT][\[Epsilon]](g[\[Epsilon]] + (fL[\[Epsilon]]-fR[\[Epsilon]])^2 (1-\[ScriptCapitalT][\[Epsilon]]));

(* LIST ALL INTEGRALS NEEDED, BASED ON WHICH PROPS THE USER PASSED TO THE FUNCTION *)
integralsNeeded[prop_]:=Which[
prop==="IN",{"IN"},
prop==="IE",{"IE"},
prop==="\[CapitalDelta]N",{"\[CapitalDelta]N"},
prop==="\[CapitalDelta]E",{"\[CapitalDelta]E"},
prop==="\[ScriptCapitalC]",{"\[ScriptCapitalC]"},
prop==="Shyp",{"Shyp"},
prop==="IQL",{"IN","IE"},
prop==="IQR",{"IN","IE"},
prop==="P",{"IN"},
prop==="\[Sigma]",{"IN","IE"},
prop==="\[CapitalDelta]P",{"\[CapitalDelta]N"},
prop==="\[CapitalDelta]QL",{"\[CapitalDelta]N","\[CapitalDelta]E","\[ScriptCapitalC]"},
prop==="\[CapitalDelta]QR",{"\[CapitalDelta]N","\[CapitalDelta]E","\[ScriptCapitalC]"},
prop==="\[CapitalDelta]\[Sigma]",{"\[CapitalDelta]N","\[CapitalDelta]E","\[ScriptCapitalC]"},
prop==="turN",{"IN","IE","\[CapitalDelta]N"},
prop==="turE",{"IN","IE","\[CapitalDelta]E"},
prop==="turP",{"IN","IE","\[CapitalDelta]N"},
prop==="turQL",{"IN","IE","\[CapitalDelta]N","\[CapitalDelta]E","\[ScriptCapitalC]"},
prop==="turQR",{"IN","IE","\[CapitalDelta]N","\[CapitalDelta]E","\[ScriptCapitalC]"},
prop==="fcorr",{"\[CapitalDelta]N","\[CapitalDelta]E","\[ScriptCapitalC]"},
prop==="SNRN",{"IN","\[CapitalDelta]N"},
prop==="SNRE",{"IE","\[CapitalDelta]E"},
prop==="SNRP",{"IN","\[CapitalDelta]N"},
prop==="SNRQL",{"IN","IE","\[CapitalDelta]N","\[CapitalDelta]E","\[ScriptCapitalC]"},
prop==="SNRQR",{"IN","IE","\[CapitalDelta]N","\[CapitalDelta]E","\[ScriptCapitalC]"},
prop==="SNR\[Sigma]",{"IN","IE","\[CapitalDelta]N","\[CapitalDelta]E","\[ScriptCapitalC]"},
prop==="a",{"IN","IE","\[CapitalDelta]N","\[ScriptCapitalC]"},
prop==="b",{"IN","IE","\[CapitalDelta]E","\[ScriptCapitalC]"},
prop==="Slhyp",{"IN","IE","\[CapitalDelta]N","\[CapitalDelta]E","\[ScriptCapitalC]"},
prop==="turlhyp",{"IN","IE","\[CapitalDelta]N","\[CapitalDelta]E","\[ScriptCapitalC]"},
prop==="turhyp",{"IN","IE","Shyp"},
prop==="RateIn",{"RateIn"},
prop==="RateOut",{"RateOut"},
prop==="RateOut",{"RateOut"},
prop==="Scl",{"Scl"},
prop==="Squ",{"Squ"},
prop==="Sth",{"Sth"},
prop==="Ssh",{"Ssh"},
prop===All,{"IN","IE","\[CapitalDelta]N","\[CapitalDelta]E","\[ScriptCapitalC]","Shyp"}
];
intsNeeded=DeleteDuplicates@Flatten@Map[integralsNeeded,Flatten@{props}];

emm = If[ArrayQ[em],em,{-em,em}];
(* COMPUTE SAID INTEGRALS *)
LandauerButtikerIntegrals[int_,emm_]:=Module[{func,\[Epsilon]},
func = Which[
int==="IN",\[ScriptCapitalT][\[Epsilon]](fL[\[Epsilon]]-fR[\[Epsilon]]),
int==="IE",\[Epsilon] \[ScriptCapitalT][\[Epsilon]](fL[\[Epsilon]]-fR[\[Epsilon]]),
int==="\[CapitalDelta]N",G[\[Epsilon]],
int==="\[CapitalDelta]E",\[Epsilon]^2 G[\[Epsilon]],
int==="\[ScriptCapitalC]",\[Epsilon] G[\[Epsilon]],
int==="Shyp",(\[ScriptCapitalT][\[Epsilon]](fL[\[Epsilon]]-fR[\[Epsilon]])^2)/(fL[\[Epsilon]]+fR[\[Epsilon]]-2 fL[\[Epsilon]] fR[\[Epsilon]]-\[ScriptCapitalT][\[Epsilon]](fL[\[Epsilon]]-fR[\[Epsilon]])^2) ,
int==="RateIn",\[ScriptCapitalT][\[Epsilon]] fL[\[Epsilon]](1-fR[\[Epsilon]]),
int==="RateOut",\[ScriptCapitalT][\[Epsilon]] fR[\[Epsilon]](1-fL[\[Epsilon]]),
int==="Scl",\[ScriptCapitalT][\[Epsilon]] (fL[\[Epsilon]](1-fR[\[Epsilon]]) + fR[\[Epsilon]](1-fL[\[Epsilon]])),
int==="Squ",\[ScriptCapitalT][\[Epsilon]]^2 (fL[\[Epsilon]]-fR[\[Epsilon]])^2,
int==="Sth",\[ScriptCapitalT][\[Epsilon]] g[\[Epsilon]],
int==="Ssh",\[ScriptCapitalT][\[Epsilon]](1-\[ScriptCapitalT][\[Epsilon]]) (fL[\[Epsilon]]-fR[\[Epsilon]])^2
];
1/(2\[Pi]) NIntegrate[func,{\[Epsilon],emm[[1]],0},WorkingPrecision->pres,MaxRecursion->maxrec]
+1/(2\[Pi]) NIntegrate[func,{\[Epsilon],0,emm[[2]]},WorkingPrecision->pres,MaxRecursion->maxrec]
];

Do[\[DoubleStruckCapitalI][int]=LandauerButtikerIntegrals[int,emm],{int,intsNeeded}];

(* USE INTEGRALS TO CONSTRUCT ALL DESIRED RESULTS *)
result[prop_]:=Which[
prop==="IN",\[DoubleStruckCapitalI]["IN"],
prop==="IE",\[DoubleStruckCapitalI]["IE"],
prop==="\[CapitalDelta]N",\[DoubleStruckCapitalI]["\[CapitalDelta]N"],
prop==="\[CapitalDelta]E",\[DoubleStruckCapitalI]["\[CapitalDelta]E"],
prop==="\[ScriptCapitalC]",\[DoubleStruckCapitalI]["\[ScriptCapitalC]"],
prop==="Shyp",\[DoubleStruckCapitalI]["Shyp"],
prop==="IQL",\[DoubleStruckCapitalI]["IE"] - \[Mu]L \[DoubleStruckCapitalI]["IN"],
prop==="IQR",\[DoubleStruckCapitalI]["IE"] - \[Mu]R \[DoubleStruckCapitalI]["IN"],
prop==="P",-\[Delta]\[Mu] \[DoubleStruckCapitalI]["IN"],
prop==="\[Sigma]",-\[Delta]\[Beta] \[DoubleStruckCapitalI]["IE"] + \[Delta]\[Beta]\[Mu] \[DoubleStruckCapitalI]["IN"],
prop==="\[CapitalDelta]P",\[Delta]\[Mu]^2 \[DoubleStruckCapitalI]["\[CapitalDelta]N"],
prop==="\[CapitalDelta]QL",\[DoubleStruckCapitalI]["\[CapitalDelta]E"] - 2 \[Mu]L \[DoubleStruckCapitalI]["\[ScriptCapitalC]"] + \[Mu]L^2 \[DoubleStruckCapitalI]["\[CapitalDelta]N"],
prop==="\[CapitalDelta]QR", \[DoubleStruckCapitalI]["\[CapitalDelta]E"] - 2 \[Mu]R \[DoubleStruckCapitalI]["\[ScriptCapitalC]"] + \[Mu]R^2 \[DoubleStruckCapitalI]["\[CapitalDelta]N"],
prop==="\[CapitalDelta]\[Sigma]",\[Delta]\[Beta]^2 \[DoubleStruckCapitalI]["\[CapitalDelta]E"] - 2 \[Delta]\[Beta] \[Delta]\[Beta]\[Mu] \[DoubleStruckCapitalI]["\[ScriptCapitalC]"] + \[Delta]\[Beta]\[Mu]^2 \[DoubleStruckCapitalI]["\[CapitalDelta]N"],
prop==="turN",\[DoubleStruckCapitalI]["\[CapitalDelta]N"]/\[DoubleStruckCapitalI]["IN"]^2 result["\[Sigma]"]//Quiet,
prop==="turE",\[DoubleStruckCapitalI]["\[CapitalDelta]E"]/\[DoubleStruckCapitalI]["IE"]^2 result["\[Sigma]"]//Quiet,
prop==="turP",result["\[CapitalDelta]P"]/result["P"]^2 result["\[Sigma]"]//Quiet, 
prop==="turQL",result["\[CapitalDelta]QL"]/result["IQL"]^2 result["\[Sigma]"]//Quiet, 
prop==="turQR",result["\[CapitalDelta]QR"]/result["IQR"]^2 result["\[Sigma]"]//Quiet, 
prop==="fcorr",\[DoubleStruckCapitalI]["\[ScriptCapitalC]"]/Sqrt[\[DoubleStruckCapitalI]["\[CapitalDelta]N"] \[DoubleStruckCapitalI]["\[CapitalDelta]E"]],
prop==="SNRN",\[DoubleStruckCapitalI]["IN"]^2/\[DoubleStruckCapitalI]["\[CapitalDelta]N"], 
prop==="SNRE",\[DoubleStruckCapitalI]["IE"]^2/\[DoubleStruckCapitalI]["\[CapitalDelta]E"],
prop==="SNRP",result["P"]^2/result["\[CapitalDelta]P"],
prop==="SNRQL",result["IQL"]^2/result["\[CapitalDelta]QL"],
prop==="SNRQR",result["IQR"]^2/result["\[CapitalDelta]QR"],
prop==="SNR\[Sigma]",result["\[Sigma]"]^2/result["\[CapitalDelta]\[Sigma]"],
(* Hyperaccurate results from arXiv:2108.05325 *)
prop==="a",\[DoubleStruckCapitalI]["IE"] \[DoubleStruckCapitalI]["\[CapitalDelta]N"] - \[DoubleStruckCapitalI]["IN"] \[DoubleStruckCapitalI]["\[ScriptCapitalC]"],
prop==="b",\[DoubleStruckCapitalI]["IN"] \[DoubleStruckCapitalI]["\[CapitalDelta]E"]-\[DoubleStruckCapitalI]["IE"] \[DoubleStruckCapitalI]["\[ScriptCapitalC]"], 
prop==="Slhyp",(result["a"] \[DoubleStruckCapitalI]["IE"] + result["b"] \[DoubleStruckCapitalI]["IN"])^2/(result["a"]^2 \[DoubleStruckCapitalI]["\[CapitalDelta]E"]+result["b"]^2 \[DoubleStruckCapitalI]["\[CapitalDelta]N"]+ 2 result["a"] result["b"] \[DoubleStruckCapitalI]["\[ScriptCapitalC]"]), 
prop==="turlhyp",result["\[Sigma]"]/result["Slhyp"],
prop==="turhyp",result["\[Sigma]"]/\[DoubleStruckCapitalI]["Shyp"],
prop==="RateIn",\[DoubleStruckCapitalI]["RateIn"],
prop==="RateOut",\[DoubleStruckCapitalI]["RateOut"],
prop==="Scl",\[DoubleStruckCapitalI]["Scl"],
prop==="Squ",\[DoubleStruckCapitalI]["Squ"],
prop==="Sth",\[DoubleStruckCapitalI]["Sth"],
prop==="Ssh",\[DoubleStruckCapitalI]["Ssh"]
];

tab=If[pprops ===All,
Chop@Table[p->result[p],{p,LandauerButtikerAllAvailableProperties}],
Chop@Table[p->result[p],{p,props}]];
If[Length@props==1 && Not[pprops ===All],
tab[[1,2]],
Association[tab]
]

]


(* ::Input::Initialization:: *)
(* Auxiliary function, pre-compiled for speed *)
Clear[NEGFAuxMat];
NEGFAuxMat= Compile[{{\[CapitalLambda],_Complex,1},{\[Beta],_Real},{\[Mu],_Real}}, 

Module[{x,y,\[Psi]p,\[Psi]m},

x = I \[CapitalLambda]\[Conjugate]-\[Mu];
y=-I \[CapitalLambda]-\[Mu];
\[Psi]p = Table[PolyGamma[(I \[Beta] y[[i]])/(2\[Pi])+1/2],{i,Length@\[CapitalLambda]}];
\[Psi]m = Table[PolyGamma[-((I \[Beta] x[[j]])/(2\[Pi]))+1/2],{j,Length@\[CapitalLambda]}];

Table[1/(x[[j]]-y[[i]] ) (I/2+1/(2\[Pi]) (\[Psi]m[[j]]-\[Psi]p[[i]])),{i,Length@\[CapitalLambda]},{j,Length@\[CapitalLambda]}]

](*,CompilationTarget\[Rule]"C"*)
];


(* ::Input::Initialization:: *)
NEGFCovMat[h_,\[Gamma]_,{TL_,TR_,\[Mu]L_,\[Mu]R_}]:=Module[{L = Length@h,\[CapitalGamma],W,\[CapitalLambda],S,Sinv,g,ppart,K,Y,\[ScriptCapitalI],amat,\[CapitalGamma]1,\[CapitalGamma]L,A1,AL},

\[CapitalGamma]1 = SparseArray[{{1,1}->\[Gamma]},{L,L}];
\[CapitalGamma]L = SparseArray[{{L,L}->\[Gamma]},{L,L}];
\[CapitalGamma] = \[CapitalGamma]1+\[CapitalGamma]L;
W = -I \[CapitalGamma]/2+ h;
{\[CapitalLambda],S}=Quiet@Eigensystem[W];
S = S\[Transpose]//SparseArray;
\[CapitalLambda] = I \[CapitalLambda]//SparseArray;
Sinv = Inverse[S]//SparseArray;
A1 =SparseArray@NEGFAuxMat[Normal@\[CapitalLambda],1/TL,\[Mu]L];
AL=SparseArray@NEGFAuxMat[Normal@\[CapitalLambda],1/TR,\[Mu]R];
Y = A1 (Sinv . \[CapitalGamma]1 . Sinv\[ConjugateTranspose])+AL (Sinv . \[CapitalGamma]L . Sinv\[ConjugateTranspose]);
S . Y . S\[ConjugateTranspose]//Chop
]


(* ::Input::Initialization:: *)
NEGFCurrents[V_,L_,\[Gamma]_,\[Beta]L_,\[Beta]R_,\[Mu]L_,\[Mu]R_]:=Module[{\[ScriptCapitalC],JN,JE,JQL,JQR,P,\[Sigma],v,i=2},

\[ScriptCapitalC] = NEGFCovMat[V,L,\[Gamma],\[Beta]L,\[Beta]R,\[Mu]L,\[Mu]R];
JN =  -I (\[ScriptCapitalC][[2,1]]-\[ScriptCapitalC][[1,2]])//Chop;
v = If[VectorQ[V],V[[1]],V]//Chop;
JE = I v ((\[ScriptCapitalC][[i-1,i]]-\[ScriptCapitalC][[i,i-1]])-(\[ScriptCapitalC][[i+1,i]]-\[ScriptCapitalC][[i,i+1]]))+ I (\[ScriptCapitalC][[i+1,i-1]]-\[ScriptCapitalC][[i-1,i+1]])//Chop;
JQL = JE - \[Mu]L JN//Chop;
JQR = JE - \[Mu]R JN//Chop;
P = -(\[Mu]L-\[Mu]R) JN//Chop;
\[Sigma] = -(\[Beta]L-\[Beta]R) JE + (\[Beta]L \[Mu]L - \[Beta]R \[Mu]R) JN//Chop;
<|"JN"->JN,"JE"->JE,"JQL"->JQL,"JQR"->JQR,"P"->P,"\[Sigma]"->\[Sigma]|>
]



(* ::Input::Initialization:: *)
Clear[FermionicChainWaitingTimeDistributionVacuum];
FermionicChainWaitingTimeDistributionVacuum[W_,F_,trange_,{i_,diri_},j_]:=Module[{L = Length@W,\[ScriptCapitalC],EM,EmM,Q,\[CapitalGamma],EX,EZ,P,\[Gamma]},

Q = W - F;
\[CapitalGamma] = Tr[F];
\[Gamma] = If[diri =="-",2 Re@W[[i,i]]-F[[i,i]],F[[i,i]]];

If[diri=="-",
Table[
EX = MatrixExp[-Q t];
EZ = EX\[ConjugateTranspose];
{t,\[Gamma] E^(-\[CapitalGamma] t) EX [[i,j]] EZ[[j,i]]},{t,trange}],

Table[
EX = MatrixExp[-Q t];
EZ = EX\[ConjugateTranspose];
{t,\[Gamma] E^(-\[CapitalGamma] t) ((EZ . EX)[[j,j]] - EX [[i,j]] EZ[[j,i]])},{t,trange}]]//Chop

]

Clear[FermionicChainWaitingTimeDistribution];
FermionicChainWaitingTimeDistribution[WW_,FF_,ttrange_,{i_,diri_},{j_,dirj_},CC_:"ss",pres_:MachinePrecision]:=Module[{L = Length@WW,W,F,\[ScriptCapitalC],EM,EmM,Q,X,\[CapitalGamma],c,\[DoubleStruckCapitalI],\[ScriptCapitalT],\[DoubleStruckCapitalD],\[Gamma],deno,trange,\[ScriptCapitalZ],EX,EmX,EZ,EmZ},

trange = SetPrecision[Rationalize@ttrange,pres];
W =SparseArray@SetPrecision[Rationalize@Normal@WW,pres];
F =SparseArray@SetPrecision[Rationalize@Normal@FF,pres];
\[DoubleStruckCapitalI] = Eye[L];

If[CC=="vac",Return[FermionicChainWaitingTimeDistributionVacuum[W,F,trange,{i,diri},j]]];

\[ScriptCapitalC]=If[CC==="ss",Chop@LyapunovSolve[W,F],CC];
EM = Inverse[\[ScriptCapitalC]]-\[DoubleStruckCapitalI];
EmM = Inverse[EM];

Q = W - F;
\[ScriptCapitalZ] = Det[\[DoubleStruckCapitalI] + EmM];
\[CapitalGamma] = Tr[F];

\[Gamma] = If[diri =="-",2 Re@W[[i,i]]-F[[i,i]],F[[i,i]]];
c = If[dirj=="-",\[ScriptCapitalC][[j,j]],1-\[ScriptCapitalC][[j,j]]];

Table[
X = -Q t;
(*Z = - Q\[ConjugateTranspose] t; (* X\[ConjugateTranspose] *)*)
EX = MatrixExp[X];
EmX = MatrixExp[-X];
EZ = EX\[ConjugateTranspose] (* \[ScriptCapitalE][Z]*);
EmZ=EmX\[ConjugateTranspose];

\[ScriptCapitalT] = Inverse[EmZ . EM . EmX+\[DoubleStruckCapitalI]];
\[DoubleStruckCapitalD] = Det[\[DoubleStruckCapitalI] + EX . EmM . EZ];


{t,\[Gamma]/c Exp[-\[CapitalGamma] t]/\[ScriptCapitalZ]  \[DoubleStruckCapitalD] Which[
(* \!\(
\*SubsuperscriptBox[\(c\), \(i\), \(\[ConjugateTranspose]\)]
\*SubscriptBox[\(c\), \(i\)]\ and\ 
\*SubsuperscriptBox[\(c\), \(j\), \(\[ConjugateTranspose]\)]
\*SubscriptBox[\(\[Rho]c\), \(j\)]\) *)diri=="-" && dirj=="+",  
((EM . EmX . \[ScriptCapitalT] . EX)[[j,j]] \[ScriptCapitalT][[i,i]] + (\[ScriptCapitalT] . EmZ . EM)[[i,j]] (EM . EmX . \[ScriptCapitalT])[[j,i]]),
(* Subscript[c, i]Subsuperscript[c, i, \[ConjugateTranspose]] and Subsuperscript[c, j, \[ConjugateTranspose]]Subscript[\[Rho]c, j] *)diri=="+" && dirj=="+", 
((EM . EmX . \[ScriptCapitalT] . EX)[[j,j]] (\[DoubleStruckCapitalI][[i,i]]-\[ScriptCapitalT][[i,i]]) - (\[ScriptCapitalT] . EmZ . EM)[[i,j]] (EM . EmX . \[ScriptCapitalT])[[j,i]]),
(* \!\(
\*SubsuperscriptBox[\(c\), \(i\), \(\[ConjugateTranspose]\)]
\*SubscriptBox[\(c\), \(i\)]\ and\ 
\*SubscriptBox[\(c\), \(j\)]
\*SubsuperscriptBox[\(\[Rho]c\), \(j\), \(\[ConjugateTranspose]\)]\) *)diri=="-" && dirj=="-", 
(\[ScriptCapitalT][[i,i]] (EmM[[j,j]]-(EmX . \[ScriptCapitalT] . EX . EmM)[[j,j]]) - (\[ScriptCapitalT] . EmZ)[[i,j]] (EmX . \[ScriptCapitalT])[[j,i]]),
(* Subscript[c, i]Subsuperscript[c, i, \[ConjugateTranspose]] and Subscript[c, j]Subsuperscript[\[Rho]c, j, \[ConjugateTranspose]] *)diri=="+" && dirj=="-", 
((\[DoubleStruckCapitalI][[i,i]]-\[ScriptCapitalT][[i,i]]) (EmM[[j,j]]-(EmX . \[ScriptCapitalT] . EX . EmM)[[j,j]]) + (\[ScriptCapitalT] . EmZ)[[i,j]] (EmX . \[ScriptCapitalT])[[j,i]])
]},
{t,trange}]//Chop

]

FermionicChainWaitingTimeDistribution[V_,L_,\[Gamma]_,{f1_,fL_},ttrange_,{i_,diri_},{j_,dirj_},CC_:"ss",pres_:MachinePrecision]:=Module[{W,F},
{W,F} = BDMatrices[V,L,\[Gamma],{f1,fL}];
FermionicChainWaitingTimeDistribution[W,F,ttrange,{i,diri},{j,dirj},CC,pres]]


(* ::Input::Initialization:: *)
Clear[FermionicChainNoJump];
FermionicChainNoJump[WW_,FF_,ttrange_,CC_:"ss",pres_:MachinePrecision]:=Module[{L = Length@WW,trange,W,F,\[DoubleStruckCapitalI],\[ScriptCapitalC],EM,EmM,Q,\[ScriptCapitalZ],\[CapitalGamma],EX},
trange = SetPrecision[Rationalize@ttrange,pres];
W =SparseArray@SetPrecision[Rationalize@Normal@WW,pres];
F =SparseArray@SetPrecision[Rationalize@Normal@FF,pres];
\[DoubleStruckCapitalI] = Eye[L];

\[ScriptCapitalC]=If[CC==="ss",Chop@LyapunovSolve[W,F],CC];
EM = Inverse[\[ScriptCapitalC]]-\[DoubleStruckCapitalI];
EmM = Inverse[EM];

Q = W - F;
\[ScriptCapitalZ] = Det[\[DoubleStruckCapitalI] + EmM];
\[CapitalGamma] = Tr[F];

Table[
EX = MatrixExp[-Q t];
{t,E^(-\[CapitalGamma] t)/\[ScriptCapitalZ] Det[\[DoubleStruckCapitalI] + EX . EmM . EX\[ConjugateTranspose]]},{t,trange}]//Chop
]

FermionicChainNoJump[V_,L_,\[Gamma]_,{f1_,fL_},ttrange_,CC_,pres_:MachinePrecision]:=Module[{W,F},
{W,F} = BDMatrices[V,L,\[Gamma],{f1,fL}];
FermionicChainNoJump[W,F,ttrange,CC,pres]]


(* ::Input::Initialization:: *)
Clear[RiccatiEigen];
RiccatiEigen[a_,q_,brb_]:=Module[{Z,U,d,U11,U21},

Z =ArrayFlatten[({
 {a, -brb},
 {-q, -a\[ConjugateTranspose]}
})];
(*U = Eigvecs[Z,Length[Z]/2];*)
U=Transpose[(Reverse@Eigenvectors[Z + 10^5 Eye@Length@Z,-Length[Z]/2])];
d=Length[Z]/2;
U11 = U[[1;;d,1;;d]];
U21 = U[[d+1;;2d,1;;d]];
U21 . Inverse[U11]
]



(* ::Input::Initialization:: *)
Clear[ConditionalFermionicDynamics];
ConditionalFermionicDynamics[H_,\[Gamma]_,f_,{\[Eta]m_,\[Eta]p_},tf_,CC_:"ss",solver_:"NDSolve",dt_:0.01]:=Module[{L,W,\[CapitalUpsilon],\[ScriptCapitalW],\[ScriptCapitalF],\[Gamma]p,\[Gamma]m,\[DoubleStruckCapitalC],\[ScriptCapitalC],\[ScriptCapitalC]0,\[ScriptCapitalA]m,\[ScriptCapitalA]p,\[CapitalTheta]0,\[CapitalTheta],\[DoubleStruckCapitalI],\[CapitalPhi]},

L=Length[\[Eta]m];
{W,\[Gamma]p} = BDMatrices[Eye[L],\[Gamma],f];
\[Gamma]m = W+W\[ConjugateTranspose]-\[Gamma]p;
\[ScriptCapitalA]m = Normal@DiagonalMatrix[\[Eta]m];
\[ScriptCapitalA]p = Normal@DiagonalMatrix[\[Eta]p];

If[L==Length@H,
W = I H + W;
(\[ScriptCapitalC]0=Normal@If[CC==="ss",Chop@LyapunovSolve[W,\[Gamma]p],CC];
If[solver ==="NDSolve",
NDSolveValue[{
\[ScriptCapitalC]'[t]==-(W . \[ScriptCapitalC][t] + \[ScriptCapitalC][t] . W\[ConjugateTranspose]) + \[Gamma]p+ \[ScriptCapitalC][t] . \[Gamma]m . \[ScriptCapitalA]m . \[ScriptCapitalC][t]-\[Gamma]p . \[ScriptCapitalA]p+ \[Gamma]p . \[ScriptCapitalA]p . \[ScriptCapitalC][t]+ \[ScriptCapitalC][t] . \[Gamma]p . \[ScriptCapitalA]p-\[ScriptCapitalC][t] . \[Gamma]p . \[ScriptCapitalA]p . \[ScriptCapitalC][t] ,
\[ScriptCapitalC][0]==\[ScriptCapitalC]0},\[ScriptCapitalC],{t,0,tf}],
Interpolation@RK4[-(W . # + # . W\[ConjugateTranspose]) + \[Gamma]p+ # . \[Gamma]m . \[ScriptCapitalA]m . #-\[Gamma]p . \[ScriptCapitalA]p+ \[Gamma]p . \[ScriptCapitalA]p . #+ # . \[Gamma]p . \[ScriptCapitalA]p-# . \[Gamma]p . \[ScriptCapitalA]p . #&,\[ScriptCapitalC]0,dt,tf]
]),
(
\[CapitalUpsilon] = 1/4 ArrayFlatten[({
 {\[Gamma]p+\[Gamma]m, I(\[Gamma]p-\[Gamma]m)},
 {-I (\[Gamma]p-\[Gamma]m), \[Gamma]p+\[Gamma]m}
})];
\[ScriptCapitalW] = I H + \[CapitalUpsilon]+\[CapitalUpsilon]\[Transpose];
\[ScriptCapitalF] = - 2(\[CapitalUpsilon]-\[CapitalUpsilon]\[Transpose]);

\[CapitalTheta]0 = Normal@If[CC==="ss",Chop@LyapunovSolve[\[ScriptCapitalW],\[ScriptCapitalF]],CC];
 \[CapitalPhi]=1/4 ArrayFlatten[({
 {\[Gamma]p . \[ScriptCapitalA]p+\[Gamma]m . \[ScriptCapitalA]m, I(\[Gamma]p . \[ScriptCapitalA]p-\[Gamma]m . \[ScriptCapitalA]m)},
 {-I (\[Gamma]p . \[ScriptCapitalA]p-\[Gamma]m . \[ScriptCapitalA]m), \[Gamma]p . \[ScriptCapitalA]p+\[Gamma]m . \[ScriptCapitalA]m}
})];
\[ScriptCapitalW] = \[ScriptCapitalW] -( \[CapitalPhi]+\[CapitalPhi]\[Transpose]);
\[ScriptCapitalF] = \[ScriptCapitalF] + \[CapitalPhi] - \[CapitalPhi]\[Transpose];
If[solver ==="NDSolve",
NDSolveValue[{
\[CapitalTheta]'[t]==-(\[ScriptCapitalW] . \[CapitalTheta][t] + \[CapitalTheta][t] . \[ScriptCapitalW]\[ConjugateTranspose]) + \[ScriptCapitalF]+\[CapitalTheta][t] . (\[CapitalPhi]-\[CapitalPhi]\[Transpose]) . \[CapitalTheta][t],
\[CapitalTheta][0]==\[CapitalTheta]0},\[CapitalTheta],{t,0,tf}],
Interpolation@RK4[-(\[ScriptCapitalW] . # + # . \[ScriptCapitalW]\[ConjugateTranspose]) + \[ScriptCapitalF]+# . (\[CapitalPhi]-\[CapitalPhi]\[Transpose]) . #&,\[CapitalTheta]0,dt,tf]
]
)]
];


(* ::Input::Initialization:: *)
Clear[ConditionalFermionicNoJumpDistribution];
ConditionalFermionicNoJumpDistribution[H_,\[Gamma]_,f_,{\[Eta]m_,\[Eta]p_},tf_,\[CapitalDelta]t_,\[ScriptCapitalC]_]:=Module[{\[Lambda],\[Gamma]p,\[Gamma]m,\[ScriptCapitalA]m,\[ScriptCapitalA]p,\[DoubleStruckCapitalI],Z0,\[Zeta],Zt,Pno,L,W},
L=Length[\[Eta]m];
{W,\[Gamma]p} = BDMatrices[Eye[L],\[Gamma],f];
\[Gamma]m = W+W\[ConjugateTranspose]-\[Gamma]p;
\[DoubleStruckCapitalI] = Eye[L];
\[ScriptCapitalA]m = Normal@DiagonalMatrix[\[Eta]m];
\[ScriptCapitalA]p = Normal@DiagonalMatrix[\[Eta]p];

\[Lambda]=If[L==Length@H,
Table[Tr[\[Gamma]p . \[ScriptCapitalA]p . (\[DoubleStruckCapitalI]-\[ScriptCapitalC][t]) + \[Gamma]m . \[ScriptCapitalA]m . \[ScriptCapitalC][t]],{t,0,tf,\[CapitalDelta]t}],Table[Tr[\[Gamma]p . \[ScriptCapitalA]p . (\[DoubleStruckCapitalI]-FermionsReducedC@\[ScriptCapitalC][t]) + \[Gamma]m . \[ScriptCapitalA]m . FermionsReducedC@\[ScriptCapitalC][t]],{t,0,tf,\[CapitalDelta]t}]
];
(*{Range[\[CapitalDelta]t,tf,\[CapitalDelta]t],Table[Exp[-Trapz[\[Lambda]\[LeftDoubleBracket]1;;j\[RightDoubleBracket],\[CapitalDelta]t]],{j,2,Length@\[Lambda]}]}\[Transpose]//Chop*)
{Range[\[CapitalDelta]t,tf,\[CapitalDelta]t],Table[-Trapz[\[Lambda][[1;;j]],\[CapitalDelta]t],{j,2,Length@\[Lambda]}]}\[Transpose]//Chop
]


(* ::Input::Initialization:: *)
Clear[ConditionalFermionicSteadyState];
ConditionalFermionicSteadyState[H_,\[Gamma]_,f_,{\[Eta]m_,\[Eta]p_},pres_:MachinePrecision]:=Module[{a,\[Gamma]p,\[Gamma]m,W,\[ScriptCapitalA]p,\[ScriptCapitalA]m,L,\[CapitalUpsilon],\[ScriptCapitalW],\[ScriptCapitalF],\[CapitalPhi]},
L=Length[\[Eta]m];
{W,\[Gamma]p} = BDMatrices[Eye[L],\[Gamma],f];
\[Gamma]m = W+W\[ConjugateTranspose]-\[Gamma]p;
\[ScriptCapitalA]m = Normal@DiagonalMatrix[\[Eta]m];
\[ScriptCapitalA]p = Normal@DiagonalMatrix[\[Eta]p];

If[L==Length@H,
W = I H + W;
(*RiccatiEigen[- W\[ConjugateTranspose]+\[Gamma]p.\[ScriptCapitalA]p, \[Gamma]p-\[Gamma]p.\[ScriptCapitalA]p, -(\[Gamma]m.\[ScriptCapitalA]m-\[Gamma]p.\[ScriptCapitalA]p)]*)
RiccatiSolve[{- W\[ConjugateTranspose]+\[Gamma]p . \[ScriptCapitalA]p,Chop@Sqrt[-(\[Gamma]m . \[ScriptCapitalA]m-\[Gamma]p . \[ScriptCapitalA]p)]},{ \[Gamma]p-\[Gamma]p . \[ScriptCapitalA]p,-NEye[L]} ]
,
\[CapitalUpsilon] = 1/4 ArrayFlatten[({
 {\[Gamma]p+\[Gamma]m, I(\[Gamma]p-\[Gamma]m)},
 {-I (\[Gamma]p-\[Gamma]m), \[Gamma]p+\[Gamma]m}
})];
\[ScriptCapitalW] = SetPrecision[I H + \[CapitalUpsilon]+\[CapitalUpsilon]\[Transpose],pres];
\[ScriptCapitalF] = SetPrecision[- 2(\[CapitalUpsilon]-\[CapitalUpsilon]\[Transpose]),pres];
 \[CapitalPhi]=SetPrecision[1/4 ArrayFlatten[({
 {\[Gamma]p . \[ScriptCapitalA]p+\[Gamma]m . \[ScriptCapitalA]m, I(\[Gamma]p . \[ScriptCapitalA]p-\[Gamma]m . \[ScriptCapitalA]m)},
 {-I (\[Gamma]p . \[ScriptCapitalA]p-\[Gamma]m . \[ScriptCapitalA]m), \[Gamma]p . \[ScriptCapitalA]p+\[Gamma]m . \[ScriptCapitalA]m}
})],pres];
(*RiccatiEigen[-\[ScriptCapitalW]\[ConjugateTranspose]+(\[CapitalPhi]+\[CapitalPhi]\[Transpose]),\[ScriptCapitalF]+\[CapitalPhi]-\[CapitalPhi]\[Transpose],-(\[CapitalPhi]-\[CapitalPhi]\[Transpose])]*)
RiccatiSolve[{-\[ScriptCapitalW]\[ConjugateTranspose]+(\[CapitalPhi]+\[CapitalPhi]\[Transpose]),Chop@Sqrt[-(\[CapitalPhi]-\[CapitalPhi]\[Transpose])]},{\[ScriptCapitalF]+\[CapitalPhi]-\[CapitalPhi]\[Transpose],kron[\[Sigma]x,NEye[L]]}]
]
]


(* ::Input::Initialization:: *)
Clear[GPTr];
GPTr[\[Sigma]_,list_]:=Module[{blist,clist,L = Length[\[Sigma]]/2},

blist = Riffle[2list-1,2list];
clist = Complement[Range[1,2L],blist];
If[2Length@list==Length@\[Sigma],\[Sigma],\[Sigma][[clist,clist]]]
]


(* ::Input::Initialization:: *)
Clear[SymplecticForm];
SymplecticForm[\[ScriptCapitalN]_]:=kron[Eye[\[ScriptCapitalN]],{{0,1},{-1,0}}];


(* ::Input::Initialization:: *)
Clear[SymplecticEigenvalues];
SymplecticEigenvalues[\[Sigma]_]:=Module[{\[ScriptCapitalN] = Length[\[Sigma]]/2,\[CapitalOmega]},
\[CapitalOmega] = SymplecticForm[\[ScriptCapitalN]];
Chop@Drop[Sort@Quiet@Eigenvalues[N[I \[CapitalOmega] . \[Sigma]]],\[ScriptCapitalN]]
]


(* ::Input::Initialization:: *)
(* Valid CM should have BonaFide \[GreaterEqual] 0 *)
Clear[BonaFide];
BonaFide[\[Sigma]_]:=Module[{\[CapitalOmega],\[ScriptCapitalN] = Length[\[Sigma]]/2},
\[CapitalOmega] = SymplecticForm[\[ScriptCapitalN]];
First@Sort@Eigenvalues[N[\[Sigma]+I \[CapitalOmega]/2]]//Chop
]


(* ::Input::Initialization:: *)
(* Transforms from (a,a\[ConjugateTranspose]) to quadratures *)
Clear[ModeQuadratureRotation];
ModeQuadratureRotation[\[ScriptCapitalN]_]:=kron[Eye[\[ScriptCapitalN]],1/Sqrt[2] ({
 {1, 1},
 {-I, I}
})];


(* ::Input::Initialization:: *)
Clear[GaussianPurity]
GaussianPurity[\[Sigma]_]:=1/Sqrt[Det[2\[Sigma]]];


(* ::Input::Initialization:: *)
Williamson[\[Sigma]_]:=Module[{\[ScriptCapitalN]=Length[\[Sigma]]/2,\[CapitalOmega],W,V,vals,vecs,list,perm,X,U,\[Gamma],\[CapitalGamma],S,P,error1,error2},
(*PhysRevA_79_052327*)
\[CapitalOmega]=SymplecticForm[\[ScriptCapitalN]];
\[CapitalGamma] = ModeQuadratureRotation[\[ScriptCapitalN]];
W =DiagonalMatrix@Abs@Eigenvalues[I \[CapitalOmega] . \[Sigma]];

V = MatrixPower[\[Sigma],-1/2];
X=V . \[CapitalOmega] . V;
{vals,vecs}=Chop@Eigensystem[X];

list=I Reverse[ Abs@vals Table[(-1)^i,{i,0,2\[ScriptCapitalN]-1}]];
perm=FindPermutation[vals,list];
U=Permute[vecs,perm]\[Transpose];
S=Inverse@(Sqrt[W] . (\[CapitalGamma] . U\[ConjugateTranspose]) . V);
error1 = Max@Flatten@Abs[S . W . S\[Transpose]-\[Sigma]]//Chop;
error2 = Max@Flatten@Abs[S . \[CapitalOmega] . S\[Transpose]-\[CapitalOmega]]//Chop;
{W,Chop@S,{error1,error2}}
]


(* ::Input::Initialization:: *)
GaussianVonNeumann[\[Sigma]_]:=Module[{h,g,\[ScriptCapitalN]=Length[\[Sigma]]/2,\[CapitalOmega],\[Nu]s},h[x_]:=If[x==0||x==1,0,x Log[x]];
g[x_]:=h[(x+1)/2]-h[(x-1)/2];
\[CapitalOmega]=kron[Eye[\[ScriptCapitalN]],{{0,1},{-1,0}}];
(*\[Nu]s=Chop@Drop[Sort@Quiet@Eigenvalues[I 2 \[CapitalOmega].\[Sigma]],\[ScriptCapitalN]];*)
\[Nu]s = 2 SymplecticEigenvalues[\[Sigma]];
Total@Table[g[\[Nu]],{\[Nu],\[Nu]s}]//Chop
];

GaussianRenyiEntropy[\[Sigma]_,\[Alpha]_]:=Module[{\[ScriptCapitalN]=Length[\[Sigma]]/2,\[CapitalOmega],\[Nu]s},
\[CapitalOmega]=kron[Eye[\[ScriptCapitalN]],{{0,1},{-1,0}}];
(*\[Nu]s=Chop@Drop[Sort@Quiet@Eigenvalues[I 2 \[CapitalOmega].\[Sigma]],\[ScriptCapitalN]];*)
\[Nu]s = 2 SymplecticEigenvalues[\[Sigma]];
If[\[Alpha]==1,GaussianVonNeumann[\[Sigma]],
1/(\[Alpha]-1) Total@Table[Log[((\[Nu]+1)/2)^\[Alpha]-((\[Nu]-1)/2)^\[Alpha]],{\[Nu],\[Nu]s}]]

]


(* ::Input::Initialization:: *)
GaussianMutualInformation[\[Sigma]_,Alist_,Blist_]:=GaussianVonNeumann[GPTr[\[Sigma],Blist]]+GaussianVonNeumann[GPTr[\[Sigma],Alist]]-GaussianVonNeumann[\[Sigma]]

GaussianMutualInformation[\[Sigma]_,Alist_,Blist_,\[Alpha]_]:=GaussianRenyiEntropy[GPTr[\[Sigma],Blist],\[Alpha]]+GaussianRenyiEntropy[GPTr[\[Sigma],Alist],\[Alpha]]-GaussianRenyiEntropy[\[Sigma],\[Alpha]]


(* ::Input::Initialization:: *)
nGmeasure[\[Rho]_]:=Module[{\[Sigma],\[ScriptCapitalN],a,X,P},
\[ScriptCapitalN]= Length@\[Rho];
a = SparseArray@Table[Sqrt[n]KroneckerDelta[m,n-1],{m,0,\[ScriptCapitalN]-1},{n,0,\[ScriptCapitalN]-1}];
X = 1/Sqrt[2] (a\[ConjugateTranspose]+a);
P = I/Sqrt[2] (a\[ConjugateTranspose]-a);

\[Sigma] = ({
 {Tr[\[Rho] . X . X]-Tr[\[Rho] . X]^2, 1/2 Tr[\[Rho] . (X . P+P . X)]-Tr[\[Rho] . X] Tr[\[Rho] . P]},
 {1/2 Tr[\[Rho] . (X . P+P . X)]-Tr[\[Rho] . X] Tr[\[Rho] . P], Tr[\[Rho] . P . P]-Tr[\[Rho] . P]^2}
});
GaussianVonNeumann[\[Sigma]]-vonNeumann[\[Rho]]
]


(* ::Input::Initialization:: *)
(* vacuum is 1/2 *)
TwoModeCanonicalForm[\[Sigma]_]:=Module[{\[Sigma]A,\[Sigma]B,\[Xi],DA,VA,ZA,DB,VB,ZB,M,\[CapitalSigma],UA,UB,S,\[Sigma]canon},
\[Sigma]A = \[Sigma][[1;;2,1;;2]];
\[Sigma]B = \[Sigma][[3;;4,3;;4]];
\[Xi] = \[Sigma][[1;;2,3;;4]];

{DA,VA} = Eigensystem[\[Sigma]A];
VA = VA\[Transpose];
ZA = DiagonalMatrix[{(DA[[2]]/DA[[1]])^(1/4),(DA[[2]]/DA[[1]])^(-1/4)}];

{DB,VB} = Eigensystem[\[Sigma]B];
VB = VB\[Transpose];
ZB = DiagonalMatrix[{(DB[[2]]/DB[[1]])^(1/4),(DB[[2]]/DB[[1]])^(-1/4)}];

M= ZA . VA\[Transpose] . \[Xi] . VB . ZB\[Transpose];

(*{UA,\[CapitalSigma]A,UB} = SingularValueDecomposition[ZA.VA\[Transpose].\[Xi].VB.ZB\[Transpose]];*)
(*UA = UA\[ConjugateTranspose]; *)
(*UB = UB\[ConjugateTranspose];*)

{\[CapitalSigma],UA} = Eigensystem[M . M\[Transpose]];
{\[CapitalSigma],UB} = Eigensystem[M\[Transpose] . M];
S = ArrayFlatten[({
 {UA . ZA . VA\[Transpose], 0},
 {0, UB . ZB . VB\[Transpose]}
})];
\[Sigma]canon = S . \[Sigma] . S\[Transpose];
{\[Sigma]canon,S}//Chop
]


(* ::Input::Initialization:: *)
Clear[GaussianEoF];
GaussianEoF[\[Sigma]bare_]:=Module[{\[Sigma],\[Theta],na,nb,kq,kp,L,Cp,Cq,X,sol,det1,det2,tab1,tab2,opt1,opt2,x0,x,\[Theta]min,detmin,Xmin,\[Gamma]p},
LoadPauliMatrices[];
\[Sigma] = First@TwoModeCanonicalForm[2\[Sigma]bare]; (* Factor of 2 because the calculations are done with vacuum being 1.*)

na = \[Sigma][[1,1]];
nb = \[Sigma][[3,3]];
kq = \[Sigma][[1,3]];
kp = \[Sigma][[2,4]];

L = \!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"1", "0", "0", "0"},
{"0", "0", "1", "0"},
{"0", "1", "0", "0"},
{"0", "0", "0", "1"}
},
GridBoxAlignment->{"Columns" -> {{Center}}, "Rows" -> {{Baseline}}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[SparseArray[Automatic, {4, 4}, 0, {1, {{0, 1, 2, 3, 4}, {{1}, {3}, {2}, {4}}}, {1, 1, 1, 1}}]]]]\);
Cq = ({
 {na, kq},
 {kq, nb}
});
Cp = ({
 {na, kp},
 {kp, nb}
});
X = x0 \[Sigma]0 + x Cos[\[Theta]] \[Sigma]z + x Sin[\[Theta]] \[Sigma]x;

sol=Quiet@Solve[{Det[Cq-X]==0,Det[X-Inverse[Cp]]==0},{x0,x}];
{det1,det2} = X[[1,1]] Inverse[X][[1,1]]/.sol//Simplify;

tab1 =Select[ Table[{\[Theta],det1},{\[Theta],linspace[10^-5,\[Pi]-10^-5,1000]}],Im[#[[2]]]==0.&];
opt1=First@MinimalBy[tab1,Last];

tab2 =Select[ Table[{\[Theta],det2},{\[Theta],linspace[10^-5,\[Pi]-10^-5,1000]}],Im[#[[2]]]==0&];
(*Print[tab2];*)
opt2=First@MinimalBy[tab2,Last];

(*Print[{opt1,opt2}];*)
If[opt1[[2]] < opt2[[2]],
(
{\[Theta]min,detmin} = opt1; 
Xmin = X/.sol[[1]]/.\[Theta]->\[Theta]min
),
(
{\[Theta]min,detmin} = opt2; 
Xmin = X/.sol[[2]]/.\[Theta]->\[Theta]min
)
];

\[Gamma]p = L\[Transpose] . ArrayFlatten[({
 {Xmin, 0},
 {0, Inverse[Xmin]}
})] . L//Chop;

{1/2 Log[Abs@detmin](*detmin*),\[Gamma]p/2}//Chop
(* 1st term has no 2 inside det because we were working with 2\[Sigma]*)
(* 2nd term is divided by 1/2 to get back to vacuum being 1/2 *)

]


(* ::Input::Initialization:: *)
Clear[SqueezedThermalState];
SqueezedThermalState[nmax_,\[ScriptCapitalN]_,r_,\[Theta]_:0]:=Module[{\[Beta],Z,b},
If[nmax>0,LoadBosonicOperators[nmax]];
\[Beta] =Log[(1+\[ScriptCapitalN])/\[ScriptCapitalN]];
Z=E^\[Beta]/(-1+E^\[Beta]);
b = a Cosh[r] + a\[ConjugateTranspose] E^(I \[Theta]) Sinh[r];
1/Z MatrixExp[-\[Beta] b\[ConjugateTranspose] . b]
]

(* Technical note: if input is nmax<0, the function will not load the bosonic operators. *)
(*This is useful when this function is being used within other calculations, which already used LoadBosonicOperators[nmax] *)


(* ::Input::Initialization:: *)
(* This is only a part of the SLD actually. It is the part called L^(2) in 1303.3682 *)
Clear[GaussianSLD]
GaussianSLD[\[Sigma]_,d\[Sigma]_]:=Module[{\[CapitalOmega]},
\[CapitalOmega] = SymplecticForm[Length[\[Sigma]]/2];
Unvec@LinearSolve[2 kron[\[Sigma]\[Transpose],\[Sigma]] + 1/2 kron[\[CapitalOmega]\[Transpose],\[CapitalOmega]],Vec[d\[Sigma]]]
]


(* ::Input::Initialization:: *)
GaussianQFI[\[Sigma]_,d\[Sigma]_]:=Module[{W,S,w,errors,\[CapitalOmega],M,vec,\[ScriptCapitalD]},
{W,S,errors}=Williamson[2*\[Sigma]];
\[CapitalOmega] = SymplecticForm[Length[W]/2];
M = \[CapitalOmega] . S\[Transpose] . \[CapitalOmega];
vec = Vec[M . d\[Sigma] . Transpose[M]];

w = SparseArray[W];
\[ScriptCapitalD] = 1/2 (kron[w,w]-kron[\[CapitalOmega],\[CapitalOmega]]);
vec\[Conjugate] . LinearSolve[\[ScriptCapitalD],vec]
]

GaussianQFI[\[Sigma]_,d\[Sigma]_,d\[Mu]_]:=d\[Mu] . LinearSolve[\[Sigma],d\[Mu]] + GaussianQFI[\[Sigma],d\[Sigma]]


(* ::Input::Initialization:: *)
Clear[WignerFunction];
WignerFunction[\[Rho]_,xmax_,\[CapitalDelta]x_]:=WignerFunction[\[Rho],Tuples[Range[-xmax,xmax,\[CapitalDelta]x],2]];

WignerFunction[\[Rho]_,grid_]:=Module[{A2,B,w0,M,\[Rho]2,L,WigLaguerreVal},

WigLaguerreVal[L_,x_,c_]:=Module[{y0,y1,y,k},
{y0,y1}=Which[
Length@c==1,
{c[[1]],0},
Length@c==2,
{c[[1]],c[[2]]},
True,
(y = {c[[-2]],c[[-1]]};
k = Length@c;
Do[
k = k-1;
y = {c[[-i]]-y[[2]] Sqrt[((k-1)(L+k-1))/((L+k)k)],y[[1]]-y[[2]] (L+2k-1-x)/Sqrt[(L+k)k]};
,{i,3,Length@c}];
y)
];

y0 -y1 (L+1-x)/Sqrt[L+1]

];

A2 = Sqrt[2] (grid[[All,1]] + I grid[[All,2]]);
B = Abs[A2]^2;
w0 = ConstantArray[2 \[Rho][[1,-1]],Length@A2];
M = Length@\[Rho];

\[Rho]2 = \[Rho] (2 ConstantArray[1,{M,M}]-Eye[M]); 
Do[
w0= WigLaguerreVal[L,B,Diagonal[\[Rho]2,L]]+w0 A2/Sqrt[L+1];
,{L,M-1,0,-1}];

{1/Sqrt[2] grid[[All,1]],1/Sqrt[2] grid[[All,2]],Re[w0] E^(-B/2)/\[Pi]}//Transpose//Chop
]


(* ::Input::Initialization:: *)
Clear[DisplacementOperator];
DisplacementOperator[\[Alpha]_,m_,n_]:=If[m>=n,
Sqrt[n!/m!] \[Alpha]^(m-n) E^(-Abs[\[Alpha]]^2/2) LaguerreL[n,m-n,Abs[\[Alpha]]^2],
Sqrt[m!/n!] (-\[Alpha]\[Conjugate])^(n-m) E^(-Abs[\[Alpha]]^2/2) LaguerreL[m,n-m,Abs[\[Alpha]]^2]
]


(* ::Input::Initialization:: *)
FermionicFullCM[\[ScriptCapitalC]_,S_:0]:=Module[{L = Length[\[ScriptCapitalC]],vp={1,I},vm={1,-I}},
-kron[\[Sigma]y,Eye[L]] + kron[out[vp,vp],\[ScriptCapitalC]\[Transpose]]-kron[out[vm,vm],\[ScriptCapitalC]] +If[MatrixQ[S], kron[out[vm,vp],S]+kron[out[vp,vm],S\[ConjugateTranspose]],0]
]


(* ::Input::Initialization:: *)
(* Recovers the reduced (L\[Times]L) covariance matrix from the full (2L\[Times]2L) one *)
(* Still need to implement the local version *)
Clear[FermionsReducedC];
FermionsReducedC[\[CapitalTheta]_,ord_:"global"]:=Module[{L=Length[\[CapitalTheta]]/2},
If[ord==="global",
-(1/4)PTr[kron[\!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"1", "I"},
{
RowBox[{"-", "I"}], "1"}
},
GridBoxAlignment->{"Columns" -> {{Center}}, "Rows" -> {{Baseline}}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\),Eye[L]] . (\[CapitalTheta]+kron[\[Sigma]y,Eye[L]]),{1},{2,L}]]
];

Clear[FermionsReducedS];
FermionsReducedS[\[CapitalTheta]_,ord_:"global"]:=Module[{L=Length[\[CapitalTheta]]/2},
If[ord==="global",
1/4 PTr[kron[\!\(\*
TagBox[
TagBox[
RowBox[{"(", "", GridBox[{
{"1", "I"},
{"I", 
RowBox[{"-", "1"}]}
},
GridBoxAlignment->{"Columns" -> {{Center}}, "Rows" -> {{Baseline}}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\),Eye[L]] . (\[CapitalTheta]+kron[\[Sigma]y,Eye[L]]),{1},{2,L}]]
];


(* ::Input::Initialization:: *)
Clear[MajoranaHamiltonian];
MajoranaHamiltonian[h_,G_:0,ord_:"global"]:=
If[ord==="local",If[MatrixQ[h],-kron[h,\!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"0", 
RowBox[{"-", "I"}]},
{"I", "0"}
},
GridBoxAlignment->{"Columns" -> {{Center}}, "Rows" -> {{Baseline}}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\)],0] +If[MatrixQ[G],- I kron[(G-G\[ConjugateTranspose])/2,\!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"0", "1"},
{"1", "0"}
},
GridBoxAlignment->{"Columns" -> {{Center}}, "Rows" -> {{Baseline}}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\)],0] +If[MatrixQ[G], kron[(G+G\[ConjugateTranspose])/2,\!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"1", "0"},
{"0", 
RowBox[{"-", "1"}]}
},
GridBoxAlignment->{"Columns" -> {{Center}}, "Rows" -> {{Baseline}}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\)],0] ,
If[MatrixQ[h],-kron[\!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"0", 
RowBox[{"-", "I"}]},
{"I", "0"}
},
GridBoxAlignment->{"Columns" -> {{Center}}, "Rows" -> {{Baseline}}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\),h],0] +If[MatrixQ[G],- I kron[{{0,1},{1,0}},(G-G\[ConjugateTranspose])/2],0] +If[MatrixQ[G], kron[{{1,0},{0,-1}},(G+G\[ConjugateTranspose])/2],0]  ] 

Clear[MajoranaTightBinding];
MajoranaTightBinding[V_,L_,ord_:"global"]:=MajoranaHamiltonian[TightBindingHamiltonian[L,V],0,ord]

Clear[MajoranaXY];
MajoranaXY[L_,h0_,\[Kappa]_]:=Module[{\[CapitalDelta]},
\[CapitalDelta]=h0 Eye[L]+ SparseArray[{Band[{1,2}]->(1-\[Kappa])/2(*Jy*),Band[{2,1}]->(1+\[Kappa])/2(*Jx*)},{L,L}] ;
I ArrayFlatten[({
 {0, -\[CapitalDelta]},
 {\[CapitalDelta]\[ConjugateTranspose], 0}
})]]


(* ::Input::Initialization:: *)
Clear[BDPairingMatrices];
BDPairingMatrices[\[ScriptCapitalT]_,\[Gamma]_,f_]:=Module[{L,W,\[Gamma]m,\[Gamma]p,\[CapitalUpsilon],\[ScriptCapitalW],\[ScriptCapitalF]},

L=Length[\[ScriptCapitalT]]/2;
{W,\[Gamma]p} = BDMatrices[Eye[L],\[Gamma],f];
\[Gamma]m = W+W\[ConjugateTranspose]-\[Gamma]p;

\[CapitalUpsilon] = 1/4 ArrayFlatten[({
 {\[Gamma]p+\[Gamma]m, I(\[Gamma]p-\[Gamma]m)},
 {-I (\[Gamma]p-\[Gamma]m), \[Gamma]p+\[Gamma]m}
})];
\[ScriptCapitalW] = I \[ScriptCapitalT] + \[CapitalUpsilon]+\[CapitalUpsilon]\[Transpose];
\[ScriptCapitalF] = - 2(\[CapitalUpsilon]-\[CapitalUpsilon]\[Transpose]);
{\[ScriptCapitalW],\[ScriptCapitalF]}
]

BDPairingMatrices[h_,G_,\[Gamma]_,f_]:=BDPairingMatrices[MajoranaHamiltonian[h,G],\[Gamma],f]

(* XY chain, with z-field h0 and anisotropy \[Kappa] *)
BDPairingMatrices[L_,h0_,\[Kappa]_,\[Gamma]_,f_]:=Module[{\[CapitalDelta]},
\[CapitalDelta]=h0 Eye[L]+ SparseArray[{Band[{1,2}]->(1-\[Kappa])/2(*Jy*),Band[{2,1}]->(1+\[Kappa])/2(*Jx*)},{L,L}] ;
 BDPairingMatrices[I ArrayFlatten[({
 {0, -\[CapitalDelta]},
 {\[CapitalDelta]\[ConjugateTranspose], 0}
})],\[Gamma],f]
]


(* ::Input::Initialization:: *)
Clear[BDPairingCovMat];
BDPairingCovMat[\[ScriptCapitalW]_,\[ScriptCapitalF]_]:=LyapunovEigen[\[ScriptCapitalW],\[ScriptCapitalF]]
BDPairingCovMat[\[ScriptCapitalT]_,\[Gamma]_,f_]:=LyapunovEigen@@BDPairingMatrices[\[ScriptCapitalT],\[Gamma],f];
BDPairingCovMat[h_,G_,\[Gamma]_,f_]:=LyapunovEigen@@BDPairingMatrices[h,G,\[Gamma],f];
BDPairingCovMat[L_,h0_,\[Kappa]_,\[Gamma]_,f_]:=LyapunovEigen@@BDPairingMatrices[L,h0,\[Kappa],\[Gamma],f];


(* ::Input::Initialization:: *)
BDPairingCurrent[\[CapitalTheta]_,\[Gamma]_,f_]:=Module[{\[Gamma]\[Gamma] = First@Flatten@{\[Gamma]},ff=First@Flatten@{f}},
{First@Flatten@{\[Gamma]} (First@Flatten@{f}-FermionsReducedC[\[CapitalTheta]][[1,1]]),
Last@Flatten@{\[Gamma]} (Last@Flatten@{f}-FermionsReducedC[\[CapitalTheta]][[-1,-1]])}//Chop
]


(* ::Input::Initialization:: *)
(* Abhay's new version to include images *)
Clear[grid];
grid[items_,nrows_:1,lettpos_:{0.93,0.93},tight_:True,letters_:True]:=Module[{i,p2,LettList,tab,pads,L,R,T,B,ncols,imgsize,plots,images,existingEpilog,xLabelOffset,imageLabelPos},ncols=Ceiling[Length[items]/nrows];
plots=Select[items,Head[#]=!=Image&];
images=Select[items,Head[#]===Image&];
imgsize=Max/@Transpose[Table[ImageSize/. AbsoluteOptions[p,ImageSize],{p,plots}]];
tab=Table[Flatten[ImagePadding/. AbsoluteOptions[p,ImagePadding]],{p,plots}];
{L,R,B,T}=Transpose[tab];
B=Max[B];
T=Max[T];
R=Max[R];
If[tight===False,L=ConstantArray[Max[L],Length[plots]],L=Transpose[Partition[L,ncols]];
L=Flatten[Transpose[Table[ConstantArray[Max[L[[i]]],nrows],{i,ncols}]]]];
LettList=("("<>#1<>")"&)/@CharacterRange["a","z"];
(*LettList=Style[#,FontFamily->"Roboto",Black,28]&/@LettList;*)
(*Calculate x offset to account for plot labels and ticks*)xLabelOffset=0.1;(*Adjust this value if necessary*)imageLabelPos={lettpos[[1]]-xLabelOffset,lettpos[[2]]};
p2=If[letters===False,
Table[If[Head[items[[i]]]===Image,items[[i]],Show[items[[i]],
ImageSize->{Automatic,imgsize[[2]]},
ImagePadding->{{L[[i]],R},{B,T}}]],{i,Length[items]}],
Table[If[Head[items[[i]]]===Image,ImageCompose[items[[i]],Text[LettList[[i]]],Scaled[imageLabelPos]],existingEpilog=Epilog/. AbsoluteOptions[items[[i]],Epilog];
Show[items[[i]],
ImageSize->{Automatic,imgsize[[2]]},
ImagePadding->{{L[[i]],R},{B,T}},
Epilog->{existingEpilog,Text[LettList[[i]],Scaled[lettpos]]}]],{i,Length[items]}]];
(*Grid[Partition[p2,ncols]]*)
Grid[PartitionIn[p2,nrows]]
]


(* ::Input::Initialization:: *)
LoadPlotStyling[]:=Module[{},
Clear[blue,blue2,blue3,navy,yellow,purple,purple2,green,red,orange,opts];

(*LettList  = "("<>#<>")"&/@CharacterRange["a","z"];*)
blue = RGBColor[0.368417, 0.506779, 0.709798];
blue2 = RGBColor[68/256,151/256,151/256];
blue3 = RGBColor[205/256,205/256,222/256];
navy = RGBColor[{65,97,150}/255];

yellow=RGBColor[1, 0.75, 0];
purple = RGBColor[{158,137,183}/255];
purple2 = RGBColor[158/256,67/256,149/256];
green = Darker[RGBColor[{123,216,187}/255],.1];
red=RGBColor[{238,105,105}/255];
orange = RGBColor[224/256,148/256,57/256];
graphite = RGBColor[{95,95,95}/255];

(*nicePalette={Black,purple,navy,green,graphite,red};*)

opts = {
BaseStyle->Directive[FontFamily->"Times",FontSize->17,FontColor->Black],
FrameStyle->Directive[FontFamily->"Times",FontSize->16,FontColor->Black],
Axes->False,
ImageSize->330,
GridLinesStyle->Directive[Black,Dashed],
PlotRangePadding->None,
Frame->True
};
SetOptions[ListLinePlot,opts];
SetOptions[ListPlot,opts];
SetOptions[ListLogPlot,opts];
SetOptions[ListLogLinearPlot,opts];
SetOptions[ListLogLogPlot,opts];
SetOptions[Plot,opts];
SetOptions[LogPlot,opts];
SetOptions[LogLinearPlot,opts];
SetOptions[LogLogPlot,opts];
SetOptions[ParametricPlot,opts];
SetOptions[DiscretePlot,opts];
SetOptions[ListStepPlot,opts];
SetOptions[ListDensityPlot,opts];
SetOptions[DensityPlot,opts];
(*SetOptions[Graphics,opts];*)
];


(* ::Input::Initialization:: *)
Clear[legend];
legend[labels_,pos_,OptionsPattern[{
FontSize->16,
LegendMarkerSize->20,
LegendLayout->"Column",
framed->True,
BackgroundColor->Gray,
FrameColor->Gray
}]]:=Placed[LineLegend[Automatic,labels,
LabelStyle->{
FontFamily->"Times",
FontSize->OptionValue[FontSize]},
LegendLayout->OptionValue[LegendLayout],
LegendMarkerSize->{OptionValue[LegendMarkerSize],2},LegendFunction->If[OptionValue[framed],(Framed[#,RoundingRadius->4,FrameStyle->OptionValue[FrameColor],Background->Lighter[OptionValue[BackgroundColor],0.9]]&),None]],Scaled[pos]]


(* ::Input::Initialization:: *)
Clear[pointlegend];
pointlegend[labels_,pos_,OptionsPattern[{
FontSize->16,
LegendMarkerSize->10,
LegendLayout->"Column",
framed->True,
BackgroundColor->Gray,
FrameColor->Gray
}]]:=Placed[PointLegend[Automatic,labels,
LabelStyle->{
FontFamily->"Times",
FontSize->OptionValue[FontSize]},
Joined->False,
LegendLayout->OptionValue[LegendLayout],
LegendMarkerSize->OptionValue[LegendMarkerSize],LegendFunction->If[OptionValue[framed],(Framed[#,RoundingRadius->4,FrameStyle->OptionValue[FrameColor],Background->Lighter[OptionValue[BackgroundColor],0.9]]&),None]],Scaled[pos]]


(* ::Input::Initialization:: *)
Clear[LoadBetterDensityPlots];
LoadBetterDensityPlots[colorScheme_,{min_,max_},label_:"",PADDIND_:30,HSIZE_:300,VSIZE_:300,LSIZE_:20,SIZE_:1000]:=Module[{DATA,MIN,MAX},
Clear[COLOR,LEGEND,OPTS];
MIN=min;
MAX=max;
COLOR=With[{BACKGROUND=White,SCHEME=parulaCM(*ColorData[colorScheme]*)},If[MIN<=#<=MAX,SCHEME[Rescale[#,{MIN,MAX}]],BACKGROUND]&];
DATA=Reverse[Transpose[{Subdivide[MIN,MAX,SIZE]}]];
LEGEND=ArrayPlot[DATA,PlotLegends->False,Frame->False,ImagePadding->None,PlotRangePadding->None,ColorFunction->COLOR,ColorFunctionScaling->False,DataRange->{{0,1},{MIN,MAX}}];
LEGEND=Show[Graphics[{
White,
Opacity[0],
Apply[Rectangle,Transpose[N[{{0.0,1.0},{MIN,MAX}}]]]
},
AspectRatio->HSIZE/LSIZE,
Frame->True,
FrameTicks->{{None,All},{None,None}},
FrameStyle->Directive[{Black}],
FrameTicksStyle->Directive[{Black,FontFamily->"Times",13}],
PlotRangePadding->None,
ImagePadding->{{0,PADDIND},{PADDIND,0.3PADDIND}},
ImageSize->{Automatic,VSIZE}],LEGEND];
LEGEND = Labeled[LEGEND,Style[label,FontFamily->"Times",12],Left,RotateLabel->True,Spacings->0.1];

OPTS = {
PlotLegends->False,
ColorFunction->COLOR,
ColorFunctionScaling->False,
(*ImagePadding->PADDIND,*)
PlotRangePadding->None,
ImageSize->{VSIZE,HSIZE}};

"Variables loaded: COLOR, LEGEND, OPTS (pass as Evaluate@OPTS to DensityPlot)"
];


(* ::Input::Initialization:: *)
(* Ticks for logscale plots *)
(* Output appropriate for functions like FrameTicks or Ticks *)
(*logticks[i_,f_,\[Delta]_,log_:False]:=
Table[{k,Superscript["10",ToString[k]]},{k,i,f,\[Delta]}] *)

Clear[logticks];
logticks[i_,f_,\[Delta]_,ts_:0.8,label_:1]:=
Flatten[Table[{
{10^k,If[label==1,Superscript["10",ToString[k]],""],ts{0.026,0}},
{0.9 10^k,"",ts{0.012,0}},
{0.8 10^k,"",ts{0.011,0}},
{0.7 10^k,"",ts{0.010,0}},
{0.6 10^k,"",ts{0.009,0}},
{0.5 10^k,"",ts{0.008,0}},
{0.4 10^k,"",ts{0.007,0}},
{0.3 10^k,"",ts{0.006,0}},
{0.2 10^k,"",ts{0.005,0}}
},{k,i,f,\[Delta]}],1]


(* ::Input::Initialization:: *)
rasta[plot_,res_:100,sz_:400]:=Rasterize[plot,ImageResolution->res,ImageSize->sz];


(* ::Input::Initialization:: *)
BlochSphere[labels_:True,shell_:False]:=Module[{splineCircle,pointsAndConnection,surroundingCircles,texKet,bloch,sphere},
(*Needs["MaTeX`"];*)

splineCircle[m_List,r_,angles_List: {0,2 \[Pi]}]:=Module[{seg,\[Phi],start,end,pts,w,k},{start,end}=Mod[angles//N,2 \[Pi]];
If[end<=start,end+=2 \[Pi]];
seg=Quotient[end-start//N,\[Pi]/2];
\[Phi]=Mod[end-start//N,\[Pi]/2];
If[seg==4,seg=3;\[Phi]=\[Pi]/2];
pts=r RotationMatrix[start] . #&/@Join[Take[{{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1}},2 seg+1],RotationMatrix[seg \[Pi]/2] . #&/@{{1,Tan[\[Phi]/2]},{Cos[\[Phi]],Sin[\[Phi]]}}];
If[Length[m]==2,pts=m+#&/@pts,pts=m+#&/@Transpose[Append[Transpose[pts],ConstantArray[0,Length[pts]]]]];
w=Join[Take[{1,1/Sqrt[2],1,1/Sqrt[2],1,1/Sqrt[2],1},2 seg+1],{Cos[\[Phi]/2],1}];
k=Join[{0,0,0},Riffle[#,#]&@Range[seg+1],{seg+1}];
BSplineCurve[pts,SplineDegree->2,SplineKnots->k,SplineWeights->w]]/;Length[m]==2||Length[m]==3;

pointsAndConnection[points_]:=Sequence@@{Sequence@@Point/@#,Line@#}&@points;

surroundingCircles=GeometricTransformation[splineCircle[{0,0,0},1],{{RotationMatrix[0,{1,0,0}],{0,0,0}},{RotationMatrix[Pi/2,{1,0,0}],{0,0,0}},{RotationMatrix[Pi/2,{0,1,0}],{0,0,0}}}];

texKet[n_]:=Text@Style[StringTemplate["\!\(\*TemplateBox[{\"`1`\"},\n\"Ket\"]\)"][ToString@n] ,FontFamily->"Times",20];
sphere=SphericalPlot3D[{0.991},{\[Theta],0,Pi},{\[Phi],0,3\[Pi]/2},AxesOrigin->{0,0,0},Axes->False,ColorFunction->"Aquamarine"];
bloch = Graphics3D[{White,Opacity@0.3,Sphere[{0,0,0},1],Opacity@1,Thickness@0.004,PointSize@0.02,Red,pointsAndConnection@{{0,0,1},{0,0,-1}},Blue,pointsAndConnection@{{1,0,0},{-1,0,0}},Darker@Green,pointsAndConnection@{{0,1,0},{0,-1,0}},Black,Point[{0,0,0}],
If[labels==True,
{Text[texKet[0],{0,0,1.2}],Text[texKet[1],{0,0,-1.2}],Text[texKet["+"],{1.2,0,0}],Text[texKet["-"],{-1.2,0,0}],Text[texKet["y+"],{0,1.2,0}],Text[texKet["y-"],{0,-1.2,0}]}],Gray,Thin,surroundingCircles},Boxed->False,PlotRange->ConstantArray[{-1.2,1.2},3],ImageSize->500,RotationAction->"Clip"];
If[shell===True,Show[bloch,sphere],bloch]
]



(* ::Input::Initialization:: *)
Clear[COLORLIST];
COLORLIST=Join[ColorData[3,"ColorList"][[{1,2,6,4,8,9}]],ColorData[7,"ColorList"][[{-1}]],ColorData[4,"ColorList"][[{6}]],ColorData[3,"ColorList"][[{5}]],ColorData[17,"ColorList"][[{-1}]]]


(* ::Input::Initialization:: *)
Clear[colorGradient];
colorGradient[color_,dir_:1,conv_:1,q_:1.5]:=Which[
dir===1&&conv===1,Function[x,Lighter[color,Tanh[q x]/Tanh[q]]],
dir===1&&conv===-1,Function[x,Lighter[color,Tanh[q (x-1)]/Tanh[q]+1]],
dir===-1&&conv===1,Function[x,Lighter[color,1-Tanh[q x]/Tanh[q]]],
dir===-1&&conv===-1,Function[x,Lighter[color,Tanh[q (1-x)]/Tanh[q]]]
]


(* ::Input::Initialization:: *)
Clear[colorGradient2];
colorGradient2[colorScheme_,dir_:1,conv_:1,q_:1.5]:=Which[
dir===1&&conv===1,Function[x,ColorData[colorScheme][Tanh[q x]/Tanh[q]]],
dir===1&&conv===-1,Function[x,ColorData[colorScheme][Tanh[q (x-1)]/Tanh[q]+1]],
dir===-1&&conv===1,Function[x,ColorData[colorScheme][1-Tanh[q x]/Tanh[q]]],
dir===-1&&conv===-1,Function[x,ColorData[colorScheme][Tanh[q (1-x)]/Tanh[q]]]
]


(* ::Input::Initialization:: *)
Clear[colorPosNeg]
colorPosNeg[z_,\[Lambda]_,zmax_]:=Which[z<0,Lighter[Blue,Tanh[\[Lambda] (1-Rescale[z,{-zmax,0},{1,0}])]/Tanh[\[Lambda]]],z>0,Lighter[Red,Tanh[\[Lambda] (1-Rescale[z,{0,zmax},{0,1}])]/Tanh[\[Lambda]]],True,White]


(* ::Input::Initialization:: *)
Clear[parulaColors,parulaCM]
parulaColors={{0.2081,0.1663,0.5292},{0.2116238095,0.1897809524,0.5776761905},{0.212252381,0.2137714286,0.6269714286},{0.2081,0.2386,0.6770857143},{0.1959047619,0.2644571429,0.7279},{0.1707285714,0.2919380952,0.779247619},{0.1252714286,0.3242428571,0.8302714286},{0.0591333333,0.3598333333,0.8683333333},{0.0116952381,0.3875095238,0.8819571429},{0.0059571429,0.4086142857,0.8828428571},{0.0165142857,0.4266,0.8786333333},{0.032852381,0.4430428571,0.8719571429},{0.0498142857,0.4585714286,0.8640571429},{0.0629333333,0.4736904762,0.8554380952},{0.0722666667,0.4886666667,0.8467},{0.0779428571,0.5039857143,0.8383714286},{0.079347619,0.5200238095,0.8311809524},{0.0749428571,0.5375428571,0.8262714286},{0.0640571429,0.5569857143,0.8239571429},{0.0487714286,0.5772238095,0.8228285714},{0.0343428571,0.5965809524,0.819852381},{0.0265,0.6137,0.8135},{0.0238904762,0.6286619048,0.8037619048},{0.0230904762,0.6417857143,0.7912666667},{0.0227714286,0.6534857143,0.7767571429},{0.0266619048,0.6641952381,0.7607190476},{0.0383714286,0.6742714286,0.743552381},{0.0589714286,0.6837571429,0.7253857143},{0.0843,0.6928333333,0.7061666667},{0.1132952381,0.7015,0.6858571429},{0.1452714286,0.7097571429,0.6646285714},{0.1801333333,0.7176571429,0.6424333333},{0.2178285714,0.7250428571,0.6192619048},{0.2586428571,0.7317142857,0.5954285714},{0.3021714286,0.7376047619,0.5711857143},{0.3481666667,0.7424333333,0.5472666667},{0.3952571429,0.7459,0.5244428571},{0.4420095238,0.7480809524,0.5033142857},{0.4871238095,0.7490619048,0.4839761905},{0.5300285714,0.7491142857,0.4661142857},{0.5708571429,0.7485190476,0.4493904762},{0.609852381,0.7473142857,0.4336857143},{0.6473,0.7456,0.4188},{0.6834190476,0.7434761905,0.4044333333},{0.7184095238,0.7411333333,0.3904761905},{0.7524857143,0.7384,0.3768142857},{0.7858428571,0.7355666667,0.3632714286},{0.8185047619,0.7327333333,0.3497904762},{0.8506571429,0.7299,0.3360285714},{0.8824333333,0.7274333333,0.3217},{0.9139333333,0.7257857143,0.3062761905},{0.9449571429,0.7261142857,0.2886428571},{0.9738952381,0.7313952381,0.266647619},{0.9937714286,0.7454571429,0.240347619},{0.9990428571,0.7653142857,0.2164142857},{0.9955333333,0.7860571429,0.196652381},{0.988,0.8066,0.1793666667},{0.9788571429,0.8271428571,0.1633142857},{0.9697,0.8481380952,0.147452381},{0.9625857143,0.8705142857,0.1309},{0.9588714286,0.8949,0.1132428571},{0.9598238095,0.9218333333,0.0948380952},{0.9661,0.9514428571,0.0755333333},{0.9763,0.9831,0.0538}};
parulaCM=With[{colorlist=RGBColor@@@parulaColors},Blend[colorlist,#]&];


(* ::Input::Initialization:: *)
Clear[stdstyle];
stdstyle[str_,fontSize_:18,italic_:True]:=
If[italic===True,
Style[ToString@str,Black,Italic,FontFamily->"Times New Roman",FontSize->fontSize],
Style[ToString@str,Black,FontFamily->"Times New Roman",FontSize->fontSize]
]


(* ::Input::Initialization:: *)
Clear[matexStyle]
matexStyle[str_,fontSize_:18]:=Quiet@MaTeX[str,FontSize->fontSize]


(* ::Input::Initialization:: *)
(* Can also be adapted to show all defined functions *)
Clear[ListAllVariables]
ListAllVariables[]:=Module[{names = Names["Global`*"],variables,functions},
variables = Select[names,ToExpression[#,StandardForm,Function[sym,OwnValues[sym]=!={},HoldAll]]&];
functions = Complement[names,variables];
(*{variables,functions}*)
variables
]


(* ::Input::Initialization:: *)
Clear[matchString];
matchString[str1_?StringQ,str2_]:=StringMatchQ[str1,str2,SpellingCorrection->True]

matchString[stringList_?ArrayQ,str2_]:=Or@@Table[matchString[str1,str2],{str1,stringList}]


(* ::Input::Initialization:: *)
matex[symbol_]:=MaTeX[symbol,FontSize->18,"Preamble"->{"\\usepackage{bm}"}];


(* ::Input::Initialization:: *)
MbCount[expr_]:=ToString[Round[ByteCount[expr]/10^6.]]<>" Mb" 


(* ::Input::Initialization:: *)
MemoryUsageTable[]:=Module[{variables, memoryUsage, sortedMemoryUsage},
variables=Names["Global`*"];
memoryUsage=Table[{var,ByteCount[Symbol[var]]},{var,variables}];
sortedMemoryUsage=SortBy[memoryUsage,-Last[#]&];
Grid[Prepend[sortedMemoryUsage,{"Variable","Memory (bytes)"}],Frame->All]
]


(* ::Input::Initialization:: *)
Clear[SetGlobalPrecision];
SetGlobalPrecision[n_]:=$PreRead=(#/. s_String/;StringMatchQ[s,NumberString]&&Precision@ToExpression@s==MachinePrecision:>s<>"`"<>ToString@n<>"."&);


(* ::Input::Initialization:: *)
SetAttributes[BlockRules,HoldRest];
BlockRules[rules_,expr_]:=Block@@Append[Apply[Set,Hold[rules],{2}],Unevaluated[expr]];


(* ::Input::Initialization:: *)
subExpressions[f_,num_:3]:=SortBy[Select[Tally[Level[f,-1]],LeafCount[First[#]]>num&],Last][[-num;;]]//Column


(* ::Input::Initialization:: *)
CompleteSquares[poly_,var_]:=Module[{c,b,a,B,\[ScriptCapitalC]},
{c,b,a} = CoefficientList[poly,var];
B = b/(2a);
\[ScriptCapitalC] = c-b^2/(4a);
{a,B,\[ScriptCapitalC]}//cf
]



